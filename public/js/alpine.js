/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@alpinejs/mask/dist/module.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@alpinejs/mask/dist/module.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ module_default),\n/* harmony export */   \"stripDown\": () => (/* binding */ stripDown)\n/* harmony export */ });\n// packages/mask/src/index.js\r\nfunction src_default(Alpine) {\r\n  Alpine.directive(\"mask\", (el, { value, expression }, { effect, evaluateLater }) => {\r\n    let templateFn = () => expression;\r\n    let lastInputValue = \"\";\r\n    queueMicrotask(() => {\r\n      if ([\"function\", \"dynamic\"].includes(value)) {\r\n        let evaluator = evaluateLater(expression);\r\n        effect(() => {\r\n          templateFn = (input) => {\r\n            let result;\r\n            Alpine.dontAutoEvaluateFunctions(() => {\r\n              evaluator((value2) => {\r\n                result = typeof value2 === \"function\" ? value2(input) : value2;\r\n              }, { scope: {\r\n                // These are \"magics\" we'll make available to the x-mask:function:\r\n                \"$input\": input,\r\n                \"$money\": formatMoney.bind({ el })\r\n              } });\r\n            });\r\n            return result;\r\n          };\r\n          processInputValue(el, false);\r\n        });\r\n      } else {\r\n        processInputValue(el, false);\r\n      }\r\n      if (el._x_model)\r\n        el._x_model.set(el.value);\r\n    });\r\n    el.addEventListener(\"input\", () => processInputValue(el));\r\n    el.addEventListener(\"blur\", () => processInputValue(el, false));\r\n    function processInputValue(el2, shouldRestoreCursor = true) {\r\n      let input = el2.value;\r\n      let template = templateFn(input);\r\n      if (!template || template === \"false\")\r\n        return false;\r\n      if (lastInputValue.length - el2.value.length === 1) {\r\n        return lastInputValue = el2.value;\r\n      }\r\n      let setInput = () => {\r\n        lastInputValue = el2.value = formatInput(input, template);\r\n      };\r\n      if (shouldRestoreCursor) {\r\n        restoreCursorPosition(el2, template, () => {\r\n          setInput();\r\n        });\r\n      } else {\r\n        setInput();\r\n      }\r\n    }\r\n    function formatInput(input, template) {\r\n      if (input === \"\")\r\n        return \"\";\r\n      let strippedDownInput = stripDown(template, input);\r\n      let rebuiltInput = buildUp(template, strippedDownInput);\r\n      return rebuiltInput;\r\n    }\r\n  }).before(\"model\");\r\n}\r\nfunction restoreCursorPosition(el, template, callback) {\r\n  let cursorPosition = el.selectionStart;\r\n  let unformattedValue = el.value;\r\n  callback();\r\n  let beforeLeftOfCursorBeforeFormatting = unformattedValue.slice(0, cursorPosition);\r\n  let newPosition = buildUp(\r\n    template,\r\n    stripDown(\r\n      template,\r\n      beforeLeftOfCursorBeforeFormatting\r\n    )\r\n  ).length;\r\n  el.setSelectionRange(newPosition, newPosition);\r\n}\r\nfunction stripDown(template, input) {\r\n  let inputToBeStripped = input;\r\n  let output = \"\";\r\n  let regexes = {\r\n    \"9\": /[0-9]/,\r\n    \"a\": /[a-zA-Z]/,\r\n    \"*\": /[a-zA-Z0-9]/\r\n  };\r\n  let wildcardTemplate = \"\";\r\n  for (let i = 0; i < template.length; i++) {\r\n    if ([\"9\", \"a\", \"*\"].includes(template[i])) {\r\n      wildcardTemplate += template[i];\r\n      continue;\r\n    }\r\n    for (let j = 0; j < inputToBeStripped.length; j++) {\r\n      if (inputToBeStripped[j] === template[i]) {\r\n        inputToBeStripped = inputToBeStripped.slice(0, j) + inputToBeStripped.slice(j + 1);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  for (let i = 0; i < wildcardTemplate.length; i++) {\r\n    let found = false;\r\n    for (let j = 0; j < inputToBeStripped.length; j++) {\r\n      if (regexes[wildcardTemplate[i]].test(inputToBeStripped[j])) {\r\n        output += inputToBeStripped[j];\r\n        inputToBeStripped = inputToBeStripped.slice(0, j) + inputToBeStripped.slice(j + 1);\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found)\r\n      break;\r\n  }\r\n  return output;\r\n}\r\nfunction buildUp(template, input) {\r\n  let clean = Array.from(input);\r\n  let output = \"\";\r\n  for (let i = 0; i < template.length; i++) {\r\n    if (![\"9\", \"a\", \"*\"].includes(template[i])) {\r\n      output += template[i];\r\n      continue;\r\n    }\r\n    if (clean.length === 0)\r\n      break;\r\n    output += clean.shift();\r\n  }\r\n  return output;\r\n}\r\nfunction formatMoney(input, delimiter = \".\", thousands, precision = 2) {\r\n  if (input === \"-\")\r\n    return \"-\";\r\n  if (/^\\D+$/.test(input))\r\n    return \"9\";\r\n  thousands = thousands ?? (delimiter === \",\" ? \".\" : \",\");\r\n  let addThousands = (input2, thousands2) => {\r\n    let output = \"\";\r\n    let counter = 0;\r\n    for (let i = input2.length - 1; i >= 0; i--) {\r\n      if (input2[i] === thousands2)\r\n        continue;\r\n      if (counter === 3) {\r\n        output = input2[i] + thousands2 + output;\r\n        counter = 0;\r\n      } else {\r\n        output = input2[i] + output;\r\n      }\r\n      counter++;\r\n    }\r\n    return output;\r\n  };\r\n  let minus = input.startsWith(\"-\") ? \"-\" : \"\";\r\n  let strippedInput = input.replaceAll(new RegExp(`[^0-9\\\\${delimiter}]`, \"g\"), \"\");\r\n  let template = Array.from({ length: strippedInput.split(delimiter)[0].length }).fill(\"9\").join(\"\");\r\n  template = `${minus}${addThousands(template, thousands)}`;\r\n  if (precision > 0 && input.includes(delimiter))\r\n    template += `${delimiter}` + \"9\".repeat(precision);\r\n  queueMicrotask(() => {\r\n    if (this.el.value.endsWith(delimiter))\r\n      return;\r\n    if (this.el.value[this.el.selectionStart - 1] === delimiter) {\r\n      this.el.setSelectionRange(this.el.selectionStart - 1, this.el.selectionStart - 1);\r\n    }\r\n  });\r\n  return template;\r\n}\r\n\r\n// packages/mask/builds/module.js\r\nvar module_default = src_default;\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFscGluZWpzL21hc2svZGlzdC9tb2R1bGUuZXNtLmpzPzY3NTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQixHQUFHLHdCQUF3QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRCxlQUFlLEVBQUU7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVU7QUFDdEUsNkJBQTZCLG1EQUFtRDtBQUNoRixnQkFBZ0IsTUFBTSxFQUFFLGtDQUFrQztBQUMxRDtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFJRSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYWxwaW5lanMvbWFzay9kaXN0L21vZHVsZS5lc20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYWNrYWdlcy9tYXNrL3NyYy9pbmRleC5qc1xyXG5mdW5jdGlvbiBzcmNfZGVmYXVsdChBbHBpbmUpIHtcclxuICBBbHBpbmUuZGlyZWN0aXZlKFwibWFza1wiLCAoZWwsIHsgdmFsdWUsIGV4cHJlc3Npb24gfSwgeyBlZmZlY3QsIGV2YWx1YXRlTGF0ZXIgfSkgPT4ge1xyXG4gICAgbGV0IHRlbXBsYXRlRm4gPSAoKSA9PiBleHByZXNzaW9uO1xyXG4gICAgbGV0IGxhc3RJbnB1dFZhbHVlID0gXCJcIjtcclxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgICAgaWYgKFtcImZ1bmN0aW9uXCIsIFwiZHluYW1pY1wiXS5pbmNsdWRlcyh2YWx1ZSkpIHtcclxuICAgICAgICBsZXQgZXZhbHVhdG9yID0gZXZhbHVhdGVMYXRlcihleHByZXNzaW9uKTtcclxuICAgICAgICBlZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgdGVtcGxhdGVGbiA9IChpbnB1dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICBBbHBpbmUuZG9udEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgZXZhbHVhdG9yKCh2YWx1ZTIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHR5cGVvZiB2YWx1ZTIgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlMihpbnB1dCkgOiB2YWx1ZTI7XHJcbiAgICAgICAgICAgICAgfSwgeyBzY29wZToge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIFwibWFnaWNzXCIgd2UnbGwgbWFrZSBhdmFpbGFibGUgdG8gdGhlIHgtbWFzazpmdW5jdGlvbjpcclxuICAgICAgICAgICAgICAgIFwiJGlucHV0XCI6IGlucHV0LFxyXG4gICAgICAgICAgICAgICAgXCIkbW9uZXlcIjogZm9ybWF0TW9uZXkuYmluZCh7IGVsIH0pXHJcbiAgICAgICAgICAgICAgfSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgcHJvY2Vzc0lucHV0VmFsdWUoZWwsIGZhbHNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9jZXNzSW5wdXRWYWx1ZShlbCwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChlbC5feF9tb2RlbClcclxuICAgICAgICBlbC5feF9tb2RlbC5zZXQoZWwudmFsdWUpO1xyXG4gICAgfSk7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gcHJvY2Vzc0lucHV0VmFsdWUoZWwpKTtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHByb2Nlc3NJbnB1dFZhbHVlKGVsLCBmYWxzZSkpO1xyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0lucHV0VmFsdWUoZWwyLCBzaG91bGRSZXN0b3JlQ3Vyc29yID0gdHJ1ZSkge1xyXG4gICAgICBsZXQgaW5wdXQgPSBlbDIudmFsdWU7XHJcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlRm4oaW5wdXQpO1xyXG4gICAgICBpZiAoIXRlbXBsYXRlIHx8IHRlbXBsYXRlID09PSBcImZhbHNlXCIpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAobGFzdElucHV0VmFsdWUubGVuZ3RoIC0gZWwyLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBsYXN0SW5wdXRWYWx1ZSA9IGVsMi52YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgc2V0SW5wdXQgPSAoKSA9PiB7XHJcbiAgICAgICAgbGFzdElucHV0VmFsdWUgPSBlbDIudmFsdWUgPSBmb3JtYXRJbnB1dChpbnB1dCwgdGVtcGxhdGUpO1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAoc2hvdWxkUmVzdG9yZUN1cnNvcikge1xyXG4gICAgICAgIHJlc3RvcmVDdXJzb3JQb3NpdGlvbihlbDIsIHRlbXBsYXRlLCAoKSA9PiB7XHJcbiAgICAgICAgICBzZXRJbnB1dCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldElucHV0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdElucHV0KGlucHV0LCB0ZW1wbGF0ZSkge1xyXG4gICAgICBpZiAoaW5wdXQgPT09IFwiXCIpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgIGxldCBzdHJpcHBlZERvd25JbnB1dCA9IHN0cmlwRG93bih0ZW1wbGF0ZSwgaW5wdXQpO1xyXG4gICAgICBsZXQgcmVidWlsdElucHV0ID0gYnVpbGRVcCh0ZW1wbGF0ZSwgc3RyaXBwZWREb3duSW5wdXQpO1xyXG4gICAgICByZXR1cm4gcmVidWlsdElucHV0O1xyXG4gICAgfVxyXG4gIH0pLmJlZm9yZShcIm1vZGVsXCIpO1xyXG59XHJcbmZ1bmN0aW9uIHJlc3RvcmVDdXJzb3JQb3NpdGlvbihlbCwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XHJcbiAgbGV0IGN1cnNvclBvc2l0aW9uID0gZWwuc2VsZWN0aW9uU3RhcnQ7XHJcbiAgbGV0IHVuZm9ybWF0dGVkVmFsdWUgPSBlbC52YWx1ZTtcclxuICBjYWxsYmFjaygpO1xyXG4gIGxldCBiZWZvcmVMZWZ0T2ZDdXJzb3JCZWZvcmVGb3JtYXR0aW5nID0gdW5mb3JtYXR0ZWRWYWx1ZS5zbGljZSgwLCBjdXJzb3JQb3NpdGlvbik7XHJcbiAgbGV0IG5ld1Bvc2l0aW9uID0gYnVpbGRVcChcclxuICAgIHRlbXBsYXRlLFxyXG4gICAgc3RyaXBEb3duKFxyXG4gICAgICB0ZW1wbGF0ZSxcclxuICAgICAgYmVmb3JlTGVmdE9mQ3Vyc29yQmVmb3JlRm9ybWF0dGluZ1xyXG4gICAgKVxyXG4gICkubGVuZ3RoO1xyXG4gIGVsLnNldFNlbGVjdGlvblJhbmdlKG5ld1Bvc2l0aW9uLCBuZXdQb3NpdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gc3RyaXBEb3duKHRlbXBsYXRlLCBpbnB1dCkge1xyXG4gIGxldCBpbnB1dFRvQmVTdHJpcHBlZCA9IGlucHV0O1xyXG4gIGxldCBvdXRwdXQgPSBcIlwiO1xyXG4gIGxldCByZWdleGVzID0ge1xyXG4gICAgXCI5XCI6IC9bMC05XS8sXHJcbiAgICBcImFcIjogL1thLXpBLVpdLyxcclxuICAgIFwiKlwiOiAvW2EtekEtWjAtOV0vXHJcbiAgfTtcclxuICBsZXQgd2lsZGNhcmRUZW1wbGF0ZSA9IFwiXCI7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wbGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKFtcIjlcIiwgXCJhXCIsIFwiKlwiXS5pbmNsdWRlcyh0ZW1wbGF0ZVtpXSkpIHtcclxuICAgICAgd2lsZGNhcmRUZW1wbGF0ZSArPSB0ZW1wbGF0ZVtpXTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGlucHV0VG9CZVN0cmlwcGVkLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIGlmIChpbnB1dFRvQmVTdHJpcHBlZFtqXSA9PT0gdGVtcGxhdGVbaV0pIHtcclxuICAgICAgICBpbnB1dFRvQmVTdHJpcHBlZCA9IGlucHV0VG9CZVN0cmlwcGVkLnNsaWNlKDAsIGopICsgaW5wdXRUb0JlU3RyaXBwZWQuc2xpY2UoaiArIDEpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2lsZGNhcmRUZW1wbGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGlucHV0VG9CZVN0cmlwcGVkLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIGlmIChyZWdleGVzW3dpbGRjYXJkVGVtcGxhdGVbaV1dLnRlc3QoaW5wdXRUb0JlU3RyaXBwZWRbal0pKSB7XHJcbiAgICAgICAgb3V0cHV0ICs9IGlucHV0VG9CZVN0cmlwcGVkW2pdO1xyXG4gICAgICAgIGlucHV0VG9CZVN0cmlwcGVkID0gaW5wdXRUb0JlU3RyaXBwZWQuc2xpY2UoMCwgaikgKyBpbnB1dFRvQmVTdHJpcHBlZC5zbGljZShqICsgMSk7XHJcbiAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWZvdW5kKVxyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIG91dHB1dDtcclxufVxyXG5mdW5jdGlvbiBidWlsZFVwKHRlbXBsYXRlLCBpbnB1dCkge1xyXG4gIGxldCBjbGVhbiA9IEFycmF5LmZyb20oaW5wdXQpO1xyXG4gIGxldCBvdXRwdXQgPSBcIlwiO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghW1wiOVwiLCBcImFcIiwgXCIqXCJdLmluY2x1ZGVzKHRlbXBsYXRlW2ldKSkge1xyXG4gICAgICBvdXRwdXQgKz0gdGVtcGxhdGVbaV07XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGNsZWFuLmxlbmd0aCA9PT0gMClcclxuICAgICAgYnJlYWs7XHJcbiAgICBvdXRwdXQgKz0gY2xlYW4uc2hpZnQoKTtcclxuICB9XHJcbiAgcmV0dXJuIG91dHB1dDtcclxufVxyXG5mdW5jdGlvbiBmb3JtYXRNb25leShpbnB1dCwgZGVsaW1pdGVyID0gXCIuXCIsIHRob3VzYW5kcywgcHJlY2lzaW9uID0gMikge1xyXG4gIGlmIChpbnB1dCA9PT0gXCItXCIpXHJcbiAgICByZXR1cm4gXCItXCI7XHJcbiAgaWYgKC9eXFxEKyQvLnRlc3QoaW5wdXQpKVxyXG4gICAgcmV0dXJuIFwiOVwiO1xyXG4gIHRob3VzYW5kcyA9IHRob3VzYW5kcyA/PyAoZGVsaW1pdGVyID09PSBcIixcIiA/IFwiLlwiIDogXCIsXCIpO1xyXG4gIGxldCBhZGRUaG91c2FuZHMgPSAoaW5wdXQyLCB0aG91c2FuZHMyKSA9PiB7XHJcbiAgICBsZXQgb3V0cHV0ID0gXCJcIjtcclxuICAgIGxldCBjb3VudGVyID0gMDtcclxuICAgIGZvciAobGV0IGkgPSBpbnB1dDIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgaWYgKGlucHV0MltpXSA9PT0gdGhvdXNhbmRzMilcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgaWYgKGNvdW50ZXIgPT09IDMpIHtcclxuICAgICAgICBvdXRwdXQgPSBpbnB1dDJbaV0gKyB0aG91c2FuZHMyICsgb3V0cHV0O1xyXG4gICAgICAgIGNvdW50ZXIgPSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG91dHB1dCA9IGlucHV0MltpXSArIG91dHB1dDtcclxuICAgICAgfVxyXG4gICAgICBjb3VudGVyKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG4gIH07XHJcbiAgbGV0IG1pbnVzID0gaW5wdXQuc3RhcnRzV2l0aChcIi1cIikgPyBcIi1cIiA6IFwiXCI7XHJcbiAgbGV0IHN0cmlwcGVkSW5wdXQgPSBpbnB1dC5yZXBsYWNlQWxsKG5ldyBSZWdFeHAoYFteMC05XFxcXCR7ZGVsaW1pdGVyfV1gLCBcImdcIiksIFwiXCIpO1xyXG4gIGxldCB0ZW1wbGF0ZSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHN0cmlwcGVkSW5wdXQuc3BsaXQoZGVsaW1pdGVyKVswXS5sZW5ndGggfSkuZmlsbChcIjlcIikuam9pbihcIlwiKTtcclxuICB0ZW1wbGF0ZSA9IGAke21pbnVzfSR7YWRkVGhvdXNhbmRzKHRlbXBsYXRlLCB0aG91c2FuZHMpfWA7XHJcbiAgaWYgKHByZWNpc2lvbiA+IDAgJiYgaW5wdXQuaW5jbHVkZXMoZGVsaW1pdGVyKSlcclxuICAgIHRlbXBsYXRlICs9IGAke2RlbGltaXRlcn1gICsgXCI5XCIucmVwZWF0KHByZWNpc2lvbik7XHJcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgaWYgKHRoaXMuZWwudmFsdWUuZW5kc1dpdGgoZGVsaW1pdGVyKSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMuZWwudmFsdWVbdGhpcy5lbC5zZWxlY3Rpb25TdGFydCAtIDFdID09PSBkZWxpbWl0ZXIpIHtcclxuICAgICAgdGhpcy5lbC5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmVsLnNlbGVjdGlvblN0YXJ0IC0gMSwgdGhpcy5lbC5zZWxlY3Rpb25TdGFydCAtIDEpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiB0ZW1wbGF0ZTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvbWFzay9idWlsZHMvbW9kdWxlLmpzXHJcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xyXG5leHBvcnQge1xyXG4gIG1vZHVsZV9kZWZhdWx0IGFzIGRlZmF1bHQsXHJcbiAgc3RyaXBEb3duXHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@alpinejs/mask/dist/module.esm.js\n");

/***/ }),

/***/ "./node_modules/alpinejs/dist/module.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/alpinejs/dist/module.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ module_default)\n/* harmony export */ });\n// packages/alpinejs/src/scheduler.js\r\nvar flushPending = false;\r\nvar flushing = false;\r\nvar queue = [];\r\nvar lastFlushedIndex = -1;\r\nfunction scheduler(callback) {\r\n  queueJob(callback);\r\n}\r\nfunction queueJob(job) {\r\n  if (!queue.includes(job))\r\n    queue.push(job);\r\n  queueFlush();\r\n}\r\nfunction dequeueJob(job) {\r\n  let index = queue.indexOf(job);\r\n  if (index !== -1 && index > lastFlushedIndex)\r\n    queue.splice(index, 1);\r\n}\r\nfunction queueFlush() {\r\n  if (!flushing && !flushPending) {\r\n    flushPending = true;\r\n    queueMicrotask(flushJobs);\r\n  }\r\n}\r\nfunction flushJobs() {\r\n  flushPending = false;\r\n  flushing = true;\r\n  for (let i = 0; i < queue.length; i++) {\r\n    queue[i]();\r\n    lastFlushedIndex = i;\r\n  }\r\n  queue.length = 0;\r\n  lastFlushedIndex = -1;\r\n  flushing = false;\r\n}\r\n\r\n// packages/alpinejs/src/reactivity.js\r\nvar reactive;\r\nvar effect;\r\nvar release;\r\nvar raw;\r\nvar shouldSchedule = true;\r\nfunction disableEffectScheduling(callback) {\r\n  shouldSchedule = false;\r\n  callback();\r\n  shouldSchedule = true;\r\n}\r\nfunction setReactivityEngine(engine) {\r\n  reactive = engine.reactive;\r\n  release = engine.release;\r\n  effect = (callback) => engine.effect(callback, { scheduler: (task) => {\r\n    if (shouldSchedule) {\r\n      scheduler(task);\r\n    } else {\r\n      task();\r\n    }\r\n  } });\r\n  raw = engine.raw;\r\n}\r\nfunction overrideEffect(override) {\r\n  effect = override;\r\n}\r\nfunction elementBoundEffect(el) {\r\n  let cleanup2 = () => {\r\n  };\r\n  let wrappedEffect = (callback) => {\r\n    let effectReference = effect(callback);\r\n    if (!el._x_effects) {\r\n      el._x_effects = /* @__PURE__ */ new Set();\r\n      el._x_runEffects = () => {\r\n        el._x_effects.forEach((i) => i());\r\n      };\r\n    }\r\n    el._x_effects.add(effectReference);\r\n    cleanup2 = () => {\r\n      if (effectReference === void 0)\r\n        return;\r\n      el._x_effects.delete(effectReference);\r\n      release(effectReference);\r\n    };\r\n    return effectReference;\r\n  };\r\n  return [wrappedEffect, () => {\r\n    cleanup2();\r\n  }];\r\n}\r\n\r\n// packages/alpinejs/src/mutation.js\r\nvar onAttributeAddeds = [];\r\nvar onElRemoveds = [];\r\nvar onElAddeds = [];\r\nfunction onElAdded(callback) {\r\n  onElAddeds.push(callback);\r\n}\r\nfunction onElRemoved(el, callback) {\r\n  if (typeof callback === \"function\") {\r\n    if (!el._x_cleanups)\r\n      el._x_cleanups = [];\r\n    el._x_cleanups.push(callback);\r\n  } else {\r\n    callback = el;\r\n    onElRemoveds.push(callback);\r\n  }\r\n}\r\nfunction onAttributesAdded(callback) {\r\n  onAttributeAddeds.push(callback);\r\n}\r\nfunction onAttributeRemoved(el, name, callback) {\r\n  if (!el._x_attributeCleanups)\r\n    el._x_attributeCleanups = {};\r\n  if (!el._x_attributeCleanups[name])\r\n    el._x_attributeCleanups[name] = [];\r\n  el._x_attributeCleanups[name].push(callback);\r\n}\r\nfunction cleanupAttributes(el, names) {\r\n  if (!el._x_attributeCleanups)\r\n    return;\r\n  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\r\n    if (names === void 0 || names.includes(name)) {\r\n      value.forEach((i) => i());\r\n      delete el._x_attributeCleanups[name];\r\n    }\r\n  });\r\n}\r\nvar observer = new MutationObserver(onMutate);\r\nvar currentlyObserving = false;\r\nfunction startObservingMutations() {\r\n  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });\r\n  currentlyObserving = true;\r\n}\r\nfunction stopObservingMutations() {\r\n  flushObserver();\r\n  observer.disconnect();\r\n  currentlyObserving = false;\r\n}\r\nvar recordQueue = [];\r\nvar willProcessRecordQueue = false;\r\nfunction flushObserver() {\r\n  recordQueue = recordQueue.concat(observer.takeRecords());\r\n  if (recordQueue.length && !willProcessRecordQueue) {\r\n    willProcessRecordQueue = true;\r\n    queueMicrotask(() => {\r\n      processRecordQueue();\r\n      willProcessRecordQueue = false;\r\n    });\r\n  }\r\n}\r\nfunction processRecordQueue() {\r\n  onMutate(recordQueue);\r\n  recordQueue.length = 0;\r\n}\r\nfunction mutateDom(callback) {\r\n  if (!currentlyObserving)\r\n    return callback();\r\n  stopObservingMutations();\r\n  let result = callback();\r\n  startObservingMutations();\r\n  return result;\r\n}\r\nvar isCollecting = false;\r\nvar deferredMutations = [];\r\nfunction deferMutations() {\r\n  isCollecting = true;\r\n}\r\nfunction flushAndStopDeferringMutations() {\r\n  isCollecting = false;\r\n  onMutate(deferredMutations);\r\n  deferredMutations = [];\r\n}\r\nfunction onMutate(mutations) {\r\n  if (isCollecting) {\r\n    deferredMutations = deferredMutations.concat(mutations);\r\n    return;\r\n  }\r\n  let addedNodes = [];\r\n  let removedNodes = [];\r\n  let addedAttributes = /* @__PURE__ */ new Map();\r\n  let removedAttributes = /* @__PURE__ */ new Map();\r\n  for (let i = 0; i < mutations.length; i++) {\r\n    if (mutations[i].target._x_ignoreMutationObserver)\r\n      continue;\r\n    if (mutations[i].type === \"childList\") {\r\n      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));\r\n      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));\r\n    }\r\n    if (mutations[i].type === \"attributes\") {\r\n      let el = mutations[i].target;\r\n      let name = mutations[i].attributeName;\r\n      let oldValue = mutations[i].oldValue;\r\n      let add2 = () => {\r\n        if (!addedAttributes.has(el))\r\n          addedAttributes.set(el, []);\r\n        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });\r\n      };\r\n      let remove = () => {\r\n        if (!removedAttributes.has(el))\r\n          removedAttributes.set(el, []);\r\n        removedAttributes.get(el).push(name);\r\n      };\r\n      if (el.hasAttribute(name) && oldValue === null) {\r\n        add2();\r\n      } else if (el.hasAttribute(name)) {\r\n        remove();\r\n        add2();\r\n      } else {\r\n        remove();\r\n      }\r\n    }\r\n  }\r\n  removedAttributes.forEach((attrs, el) => {\r\n    cleanupAttributes(el, attrs);\r\n  });\r\n  addedAttributes.forEach((attrs, el) => {\r\n    onAttributeAddeds.forEach((i) => i(el, attrs));\r\n  });\r\n  for (let node of removedNodes) {\r\n    if (addedNodes.includes(node))\r\n      continue;\r\n    onElRemoveds.forEach((i) => i(node));\r\n    if (node._x_cleanups) {\r\n      while (node._x_cleanups.length)\r\n        node._x_cleanups.pop()();\r\n    }\r\n  }\r\n  addedNodes.forEach((node) => {\r\n    node._x_ignoreSelf = true;\r\n    node._x_ignore = true;\r\n  });\r\n  for (let node of addedNodes) {\r\n    if (removedNodes.includes(node))\r\n      continue;\r\n    if (!node.isConnected)\r\n      continue;\r\n    delete node._x_ignoreSelf;\r\n    delete node._x_ignore;\r\n    onElAddeds.forEach((i) => i(node));\r\n    node._x_ignore = true;\r\n    node._x_ignoreSelf = true;\r\n  }\r\n  addedNodes.forEach((node) => {\r\n    delete node._x_ignoreSelf;\r\n    delete node._x_ignore;\r\n  });\r\n  addedNodes = null;\r\n  removedNodes = null;\r\n  addedAttributes = null;\r\n  removedAttributes = null;\r\n}\r\n\r\n// packages/alpinejs/src/scope.js\r\nfunction scope(node) {\r\n  return mergeProxies(closestDataStack(node));\r\n}\r\nfunction addScopeToNode(node, data2, referenceNode) {\r\n  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];\r\n  return () => {\r\n    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);\r\n  };\r\n}\r\nfunction refreshScope(element, scope2) {\r\n  let existingScope = element._x_dataStack[0];\r\n  Object.entries(scope2).forEach(([key, value]) => {\r\n    existingScope[key] = value;\r\n  });\r\n}\r\nfunction closestDataStack(node) {\r\n  if (node._x_dataStack)\r\n    return node._x_dataStack;\r\n  if (typeof ShadowRoot === \"function\" && node instanceof ShadowRoot) {\r\n    return closestDataStack(node.host);\r\n  }\r\n  if (!node.parentNode) {\r\n    return [];\r\n  }\r\n  return closestDataStack(node.parentNode);\r\n}\r\nfunction mergeProxies(objects) {\r\n  let thisProxy = new Proxy({}, {\r\n    ownKeys: () => {\r\n      return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));\r\n    },\r\n    has: (target, name) => {\r\n      return objects.some((obj) => obj.hasOwnProperty(name));\r\n    },\r\n    get: (target, name) => {\r\n      return (objects.find((obj) => {\r\n        if (obj.hasOwnProperty(name)) {\r\n          let descriptor = Object.getOwnPropertyDescriptor(obj, name);\r\n          if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {\r\n            return true;\r\n          }\r\n          if ((descriptor.get || descriptor.set) && descriptor.enumerable) {\r\n            let getter = descriptor.get;\r\n            let setter = descriptor.set;\r\n            let property = descriptor;\r\n            getter = getter && getter.bind(thisProxy);\r\n            setter = setter && setter.bind(thisProxy);\r\n            if (getter)\r\n              getter._x_alreadyBound = true;\r\n            if (setter)\r\n              setter._x_alreadyBound = true;\r\n            Object.defineProperty(obj, name, {\r\n              ...property,\r\n              get: getter,\r\n              set: setter\r\n            });\r\n          }\r\n          return true;\r\n        }\r\n        return false;\r\n      }) || {})[name];\r\n    },\r\n    set: (target, name, value) => {\r\n      let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));\r\n      if (closestObjectWithKey) {\r\n        closestObjectWithKey[name] = value;\r\n      } else {\r\n        objects[objects.length - 1][name] = value;\r\n      }\r\n      return true;\r\n    }\r\n  });\r\n  return thisProxy;\r\n}\r\n\r\n// packages/alpinejs/src/interceptor.js\r\nfunction initInterceptors(data2) {\r\n  let isObject2 = (val) => typeof val === \"object\" && !Array.isArray(val) && val !== null;\r\n  let recurse = (obj, basePath = \"\") => {\r\n    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {\r\n      if (enumerable === false || value === void 0)\r\n        return;\r\n      let path = basePath === \"\" ? key : `${basePath}.${key}`;\r\n      if (typeof value === \"object\" && value !== null && value._x_interceptor) {\r\n        obj[key] = value.initialize(data2, path, key);\r\n      } else {\r\n        if (isObject2(value) && value !== obj && !(value instanceof Element)) {\r\n          recurse(value, path);\r\n        }\r\n      }\r\n    });\r\n  };\r\n  return recurse(data2);\r\n}\r\nfunction interceptor(callback, mutateObj = () => {\r\n}) {\r\n  let obj = {\r\n    initialValue: void 0,\r\n    _x_interceptor: true,\r\n    initialize(data2, path, key) {\r\n      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);\r\n    }\r\n  };\r\n  mutateObj(obj);\r\n  return (initialValue) => {\r\n    if (typeof initialValue === \"object\" && initialValue !== null && initialValue._x_interceptor) {\r\n      let initialize = obj.initialize.bind(obj);\r\n      obj.initialize = (data2, path, key) => {\r\n        let innerValue = initialValue.initialize(data2, path, key);\r\n        obj.initialValue = innerValue;\r\n        return initialize(data2, path, key);\r\n      };\r\n    } else {\r\n      obj.initialValue = initialValue;\r\n    }\r\n    return obj;\r\n  };\r\n}\r\nfunction get(obj, path) {\r\n  return path.split(\".\").reduce((carry, segment) => carry[segment], obj);\r\n}\r\nfunction set(obj, path, value) {\r\n  if (typeof path === \"string\")\r\n    path = path.split(\".\");\r\n  if (path.length === 1)\r\n    obj[path[0]] = value;\r\n  else if (path.length === 0)\r\n    throw error;\r\n  else {\r\n    if (obj[path[0]])\r\n      return set(obj[path[0]], path.slice(1), value);\r\n    else {\r\n      obj[path[0]] = {};\r\n      return set(obj[path[0]], path.slice(1), value);\r\n    }\r\n  }\r\n}\r\n\r\n// packages/alpinejs/src/magics.js\r\nvar magics = {};\r\nfunction magic(name, callback) {\r\n  magics[name] = callback;\r\n}\r\nfunction injectMagics(obj, el) {\r\n  Object.entries(magics).forEach(([name, callback]) => {\r\n    Object.defineProperty(obj, `$${name}`, {\r\n      get() {\r\n        let [utilities, cleanup2] = getElementBoundUtilities(el);\r\n        utilities = { interceptor, ...utilities };\r\n        onElRemoved(el, cleanup2);\r\n        return callback(el, utilities);\r\n      },\r\n      enumerable: false\r\n    });\r\n  });\r\n  return obj;\r\n}\r\n\r\n// packages/alpinejs/src/utils/error.js\r\nfunction tryCatch(el, expression, callback, ...args) {\r\n  try {\r\n    return callback(...args);\r\n  } catch (e) {\r\n    handleError(e, el, expression);\r\n  }\r\n}\r\nfunction handleError(error2, el, expression = void 0) {\r\n  Object.assign(error2, { el, expression });\r\n  console.warn(`Alpine Expression Error: ${error2.message}\r\n\r\n${expression ? 'Expression: \"' + expression + '\"\\n\\n' : \"\"}`, el);\r\n  setTimeout(() => {\r\n    throw error2;\r\n  }, 0);\r\n}\r\n\r\n// packages/alpinejs/src/evaluator.js\r\nvar shouldAutoEvaluateFunctions = true;\r\nfunction dontAutoEvaluateFunctions(callback) {\r\n  let cache = shouldAutoEvaluateFunctions;\r\n  shouldAutoEvaluateFunctions = false;\r\n  callback();\r\n  shouldAutoEvaluateFunctions = cache;\r\n}\r\nfunction evaluate(el, expression, extras = {}) {\r\n  let result;\r\n  evaluateLater(el, expression)((value) => result = value, extras);\r\n  return result;\r\n}\r\nfunction evaluateLater(...args) {\r\n  return theEvaluatorFunction(...args);\r\n}\r\nvar theEvaluatorFunction = normalEvaluator;\r\nfunction setEvaluator(newEvaluator) {\r\n  theEvaluatorFunction = newEvaluator;\r\n}\r\nfunction normalEvaluator(el, expression) {\r\n  let overriddenMagics = {};\r\n  injectMagics(overriddenMagics, el);\r\n  let dataStack = [overriddenMagics, ...closestDataStack(el)];\r\n  let evaluator = typeof expression === \"function\" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);\r\n  return tryCatch.bind(null, el, expression, evaluator);\r\n}\r\nfunction generateEvaluatorFromFunction(dataStack, func) {\r\n  return (receiver = () => {\r\n  }, { scope: scope2 = {}, params = [] } = {}) => {\r\n    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);\r\n    runIfTypeOfFunction(receiver, result);\r\n  };\r\n}\r\nvar evaluatorMemo = {};\r\nfunction generateFunctionFromString(expression, el) {\r\n  if (evaluatorMemo[expression]) {\r\n    return evaluatorMemo[expression];\r\n  }\r\n  let AsyncFunction = Object.getPrototypeOf(async function() {\r\n  }).constructor;\r\n  let rightSideSafeExpression = /^[\\n\\s]*if.*\\(.*\\)/.test(expression) || /^(let|const)\\s/.test(expression) ? `(async()=>{ ${expression} })()` : expression;\r\n  const safeAsyncFunction = () => {\r\n    try {\r\n      return new AsyncFunction([\"__self\", \"scope\"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);\r\n    } catch (error2) {\r\n      handleError(error2, el, expression);\r\n      return Promise.resolve();\r\n    }\r\n  };\r\n  let func = safeAsyncFunction();\r\n  evaluatorMemo[expression] = func;\r\n  return func;\r\n}\r\nfunction generateEvaluatorFromString(dataStack, expression, el) {\r\n  let func = generateFunctionFromString(expression, el);\r\n  return (receiver = () => {\r\n  }, { scope: scope2 = {}, params = [] } = {}) => {\r\n    func.result = void 0;\r\n    func.finished = false;\r\n    let completeScope = mergeProxies([scope2, ...dataStack]);\r\n    if (typeof func === \"function\") {\r\n      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));\r\n      if (func.finished) {\r\n        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);\r\n        func.result = void 0;\r\n      } else {\r\n        promise.then((result) => {\r\n          runIfTypeOfFunction(receiver, result, completeScope, params, el);\r\n        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);\r\n      }\r\n    }\r\n  };\r\n}\r\nfunction runIfTypeOfFunction(receiver, value, scope2, params, el) {\r\n  if (shouldAutoEvaluateFunctions && typeof value === \"function\") {\r\n    let result = value.apply(scope2, params);\r\n    if (result instanceof Promise) {\r\n      result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));\r\n    } else {\r\n      receiver(result);\r\n    }\r\n  } else if (typeof value === \"object\" && value instanceof Promise) {\r\n    value.then((i) => receiver(i));\r\n  } else {\r\n    receiver(value);\r\n  }\r\n}\r\n\r\n// packages/alpinejs/src/directives.js\r\nvar prefixAsString = \"x-\";\r\nfunction prefix(subject = \"\") {\r\n  return prefixAsString + subject;\r\n}\r\nfunction setPrefix(newPrefix) {\r\n  prefixAsString = newPrefix;\r\n}\r\nvar directiveHandlers = {};\r\nfunction directive(name, callback) {\r\n  directiveHandlers[name] = callback;\r\n  return {\r\n    before(directive2) {\r\n      if (!directiveHandlers[directive2]) {\r\n        console.warn(\r\n          \"Cannot find directive `${directive}`. `${name}` will use the default order of execution\"\r\n        );\r\n        return;\r\n      }\r\n      const pos = directiveOrder.indexOf(directive2);\r\n      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf(\"DEFAULT\"), 0, name);\r\n    }\r\n  };\r\n}\r\nfunction directives(el, attributes, originalAttributeOverride) {\r\n  attributes = Array.from(attributes);\r\n  if (el._x_virtualDirectives) {\r\n    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));\r\n    let staticAttributes = attributesOnly(vAttributes);\r\n    vAttributes = vAttributes.map((attribute) => {\r\n      if (staticAttributes.find((attr) => attr.name === attribute.name)) {\r\n        return {\r\n          name: `x-bind:${attribute.name}`,\r\n          value: `\"${attribute.value}\"`\r\n        };\r\n      }\r\n      return attribute;\r\n    });\r\n    attributes = attributes.concat(vAttributes);\r\n  }\r\n  let transformedAttributeMap = {};\r\n  let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);\r\n  return directives2.map((directive2) => {\r\n    return getDirectiveHandler(el, directive2);\r\n  });\r\n}\r\nfunction attributesOnly(attributes) {\r\n  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));\r\n}\r\nvar isDeferringHandlers = false;\r\nvar directiveHandlerStacks = /* @__PURE__ */ new Map();\r\nvar currentHandlerStackKey = Symbol();\r\nfunction deferHandlingDirectives(callback) {\r\n  isDeferringHandlers = true;\r\n  let key = Symbol();\r\n  currentHandlerStackKey = key;\r\n  directiveHandlerStacks.set(key, []);\r\n  let flushHandlers = () => {\r\n    while (directiveHandlerStacks.get(key).length)\r\n      directiveHandlerStacks.get(key).shift()();\r\n    directiveHandlerStacks.delete(key);\r\n  };\r\n  let stopDeferring = () => {\r\n    isDeferringHandlers = false;\r\n    flushHandlers();\r\n  };\r\n  callback(flushHandlers);\r\n  stopDeferring();\r\n}\r\nfunction getElementBoundUtilities(el) {\r\n  let cleanups = [];\r\n  let cleanup2 = (callback) => cleanups.push(callback);\r\n  let [effect3, cleanupEffect] = elementBoundEffect(el);\r\n  cleanups.push(cleanupEffect);\r\n  let utilities = {\r\n    Alpine: alpine_default,\r\n    effect: effect3,\r\n    cleanup: cleanup2,\r\n    evaluateLater: evaluateLater.bind(evaluateLater, el),\r\n    evaluate: evaluate.bind(evaluate, el)\r\n  };\r\n  let doCleanup = () => cleanups.forEach((i) => i());\r\n  return [utilities, doCleanup];\r\n}\r\nfunction getDirectiveHandler(el, directive2) {\r\n  let noop = () => {\r\n  };\r\n  let handler3 = directiveHandlers[directive2.type] || noop;\r\n  let [utilities, cleanup2] = getElementBoundUtilities(el);\r\n  onAttributeRemoved(el, directive2.original, cleanup2);\r\n  let fullHandler = () => {\r\n    if (el._x_ignore || el._x_ignoreSelf)\r\n      return;\r\n    handler3.inline && handler3.inline(el, directive2, utilities);\r\n    handler3 = handler3.bind(handler3, el, directive2, utilities);\r\n    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();\r\n  };\r\n  fullHandler.runCleanups = cleanup2;\r\n  return fullHandler;\r\n}\r\nvar startingWith = (subject, replacement) => ({ name, value }) => {\r\n  if (name.startsWith(subject))\r\n    name = name.replace(subject, replacement);\r\n  return { name, value };\r\n};\r\nvar into = (i) => i;\r\nfunction toTransformedAttributes(callback = () => {\r\n}) {\r\n  return ({ name, value }) => {\r\n    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {\r\n      return transform(carry);\r\n    }, { name, value });\r\n    if (newName !== name)\r\n      callback(newName, name);\r\n    return { name: newName, value: newValue };\r\n  };\r\n}\r\nvar attributeTransformers = [];\r\nfunction mapAttributes(callback) {\r\n  attributeTransformers.push(callback);\r\n}\r\nfunction outNonAlpineAttributes({ name }) {\r\n  return alpineAttributeRegex().test(name);\r\n}\r\nvar alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`);\r\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\r\n  return ({ name, value }) => {\r\n    let typeMatch = name.match(alpineAttributeRegex());\r\n    let valueMatch = name.match(/:([a-zA-Z0-9\\-:]+)/);\r\n    let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\r\n    let original = originalAttributeOverride || transformedAttributeMap[name] || name;\r\n    return {\r\n      type: typeMatch ? typeMatch[1] : null,\r\n      value: valueMatch ? valueMatch[1] : null,\r\n      modifiers: modifiers.map((i) => i.replace(\".\", \"\")),\r\n      expression: value,\r\n      original\r\n    };\r\n  };\r\n}\r\nvar DEFAULT = \"DEFAULT\";\r\nvar directiveOrder = [\r\n  \"ignore\",\r\n  \"ref\",\r\n  \"data\",\r\n  \"id\",\r\n  \"bind\",\r\n  \"init\",\r\n  \"for\",\r\n  \"model\",\r\n  \"modelable\",\r\n  \"transition\",\r\n  \"show\",\r\n  \"if\",\r\n  DEFAULT,\r\n  \"teleport\"\r\n];\r\nfunction byPriority(a, b) {\r\n  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;\r\n  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;\r\n  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\r\n}\r\n\r\n// packages/alpinejs/src/utils/dispatch.js\r\nfunction dispatch(el, name, detail = {}) {\r\n  el.dispatchEvent(\r\n    new CustomEvent(name, {\r\n      detail,\r\n      bubbles: true,\r\n      // Allows events to pass the shadow DOM barrier.\r\n      composed: true,\r\n      cancelable: true\r\n    })\r\n  );\r\n}\r\n\r\n// packages/alpinejs/src/utils/walk.js\r\nfunction walk(el, callback) {\r\n  if (typeof ShadowRoot === \"function\" && el instanceof ShadowRoot) {\r\n    Array.from(el.children).forEach((el2) => walk(el2, callback));\r\n    return;\r\n  }\r\n  let skip = false;\r\n  callback(el, () => skip = true);\r\n  if (skip)\r\n    return;\r\n  let node = el.firstElementChild;\r\n  while (node) {\r\n    walk(node, callback, false);\r\n    node = node.nextElementSibling;\r\n  }\r\n}\r\n\r\n// packages/alpinejs/src/utils/warn.js\r\nfunction warn(message, ...args) {\r\n  console.warn(`Alpine Warning: ${message}`, ...args);\r\n}\r\n\r\n// packages/alpinejs/src/lifecycle.js\r\nfunction start() {\r\n  if (!document.body)\r\n    warn(\"Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?\");\r\n  dispatch(document, \"alpine:init\");\r\n  dispatch(document, \"alpine:initializing\");\r\n  startObservingMutations();\r\n  onElAdded((el) => initTree(el, walk));\r\n  onElRemoved((el) => destroyTree(el));\r\n  onAttributesAdded((el, attrs) => {\r\n    directives(el, attrs).forEach((handle) => handle());\r\n  });\r\n  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);\r\n  Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {\r\n    initTree(el);\r\n  });\r\n  dispatch(document, \"alpine:initialized\");\r\n}\r\nvar rootSelectorCallbacks = [];\r\nvar initSelectorCallbacks = [];\r\nfunction rootSelectors() {\r\n  return rootSelectorCallbacks.map((fn) => fn());\r\n}\r\nfunction allSelectors() {\r\n  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());\r\n}\r\nfunction addRootSelector(selectorCallback) {\r\n  rootSelectorCallbacks.push(selectorCallback);\r\n}\r\nfunction addInitSelector(selectorCallback) {\r\n  initSelectorCallbacks.push(selectorCallback);\r\n}\r\nfunction closestRoot(el, includeInitSelectors = false) {\r\n  return findClosest(el, (element) => {\r\n    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();\r\n    if (selectors.some((selector) => element.matches(selector)))\r\n      return true;\r\n  });\r\n}\r\nfunction findClosest(el, callback) {\r\n  if (!el)\r\n    return;\r\n  if (callback(el))\r\n    return el;\r\n  if (el._x_teleportBack)\r\n    el = el._x_teleportBack;\r\n  if (!el.parentElement)\r\n    return;\r\n  return findClosest(el.parentElement, callback);\r\n}\r\nfunction isRoot(el) {\r\n  return rootSelectors().some((selector) => el.matches(selector));\r\n}\r\nvar initInterceptors2 = [];\r\nfunction interceptInit(callback) {\r\n  initInterceptors2.push(callback);\r\n}\r\nfunction initTree(el, walker = walk, intercept = () => {\r\n}) {\r\n  deferHandlingDirectives(() => {\r\n    walker(el, (el2, skip) => {\r\n      intercept(el2, skip);\r\n      initInterceptors2.forEach((i) => i(el2, skip));\r\n      directives(el2, el2.attributes).forEach((handle) => handle());\r\n      el2._x_ignore && skip();\r\n    });\r\n  });\r\n}\r\nfunction destroyTree(root) {\r\n  walk(root, (el) => cleanupAttributes(el));\r\n}\r\n\r\n// packages/alpinejs/src/nextTick.js\r\nvar tickStack = [];\r\nvar isHolding = false;\r\nfunction nextTick(callback = () => {\r\n}) {\r\n  queueMicrotask(() => {\r\n    isHolding || setTimeout(() => {\r\n      releaseNextTicks();\r\n    });\r\n  });\r\n  return new Promise((res) => {\r\n    tickStack.push(() => {\r\n      callback();\r\n      res();\r\n    });\r\n  });\r\n}\r\nfunction releaseNextTicks() {\r\n  isHolding = false;\r\n  while (tickStack.length)\r\n    tickStack.shift()();\r\n}\r\nfunction holdNextTicks() {\r\n  isHolding = true;\r\n}\r\n\r\n// packages/alpinejs/src/utils/classes.js\r\nfunction setClasses(el, value) {\r\n  if (Array.isArray(value)) {\r\n    return setClassesFromString(el, value.join(\" \"));\r\n  } else if (typeof value === \"object\" && value !== null) {\r\n    return setClassesFromObject(el, value);\r\n  } else if (typeof value === \"function\") {\r\n    return setClasses(el, value());\r\n  }\r\n  return setClassesFromString(el, value);\r\n}\r\nfunction setClassesFromString(el, classString) {\r\n  let split = (classString2) => classString2.split(\" \").filter(Boolean);\r\n  let missingClasses = (classString2) => classString2.split(\" \").filter((i) => !el.classList.contains(i)).filter(Boolean);\r\n  let addClassesAndReturnUndo = (classes) => {\r\n    el.classList.add(...classes);\r\n    return () => {\r\n      el.classList.remove(...classes);\r\n    };\r\n  };\r\n  classString = classString === true ? classString = \"\" : classString || \"\";\r\n  return addClassesAndReturnUndo(missingClasses(classString));\r\n}\r\nfunction setClassesFromObject(el, classObject) {\r\n  let split = (classString) => classString.split(\" \").filter(Boolean);\r\n  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);\r\n  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);\r\n  let added = [];\r\n  let removed = [];\r\n  forRemove.forEach((i) => {\r\n    if (el.classList.contains(i)) {\r\n      el.classList.remove(i);\r\n      removed.push(i);\r\n    }\r\n  });\r\n  forAdd.forEach((i) => {\r\n    if (!el.classList.contains(i)) {\r\n      el.classList.add(i);\r\n      added.push(i);\r\n    }\r\n  });\r\n  return () => {\r\n    removed.forEach((i) => el.classList.add(i));\r\n    added.forEach((i) => el.classList.remove(i));\r\n  };\r\n}\r\n\r\n// packages/alpinejs/src/utils/styles.js\r\nfunction setStyles(el, value) {\r\n  if (typeof value === \"object\" && value !== null) {\r\n    return setStylesFromObject(el, value);\r\n  }\r\n  return setStylesFromString(el, value);\r\n}\r\nfunction setStylesFromObject(el, value) {\r\n  let previousStyles = {};\r\n  Object.entries(value).forEach(([key, value2]) => {\r\n    previousStyles[key] = el.style[key];\r\n    if (!key.startsWith(\"--\")) {\r\n      key = kebabCase(key);\r\n    }\r\n    el.style.setProperty(key, value2);\r\n  });\r\n  setTimeout(() => {\r\n    if (el.style.length === 0) {\r\n      el.removeAttribute(\"style\");\r\n    }\r\n  });\r\n  return () => {\r\n    setStyles(el, previousStyles);\r\n  };\r\n}\r\nfunction setStylesFromString(el, value) {\r\n  let cache = el.getAttribute(\"style\", value);\r\n  el.setAttribute(\"style\", value);\r\n  return () => {\r\n    el.setAttribute(\"style\", cache || \"\");\r\n  };\r\n}\r\nfunction kebabCase(subject) {\r\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\r\n}\r\n\r\n// packages/alpinejs/src/utils/once.js\r\nfunction once(callback, fallback = () => {\r\n}) {\r\n  let called = false;\r\n  return function() {\r\n    if (!called) {\r\n      called = true;\r\n      callback.apply(this, arguments);\r\n    } else {\r\n      fallback.apply(this, arguments);\r\n    }\r\n  };\r\n}\r\n\r\n// packages/alpinejs/src/directives/x-transition.js\r\ndirective(\"transition\", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {\r\n  if (typeof expression === \"function\")\r\n    expression = evaluate2(expression);\r\n  if (!expression) {\r\n    registerTransitionsFromHelper(el, modifiers, value);\r\n  } else {\r\n    registerTransitionsFromClassString(el, expression, value);\r\n  }\r\n});\r\nfunction registerTransitionsFromClassString(el, classString, stage) {\r\n  registerTransitionObject(el, setClasses, \"\");\r\n  let directiveStorageMap = {\r\n    \"enter\": (classes) => {\r\n      el._x_transition.enter.during = classes;\r\n    },\r\n    \"enter-start\": (classes) => {\r\n      el._x_transition.enter.start = classes;\r\n    },\r\n    \"enter-end\": (classes) => {\r\n      el._x_transition.enter.end = classes;\r\n    },\r\n    \"leave\": (classes) => {\r\n      el._x_transition.leave.during = classes;\r\n    },\r\n    \"leave-start\": (classes) => {\r\n      el._x_transition.leave.start = classes;\r\n    },\r\n    \"leave-end\": (classes) => {\r\n      el._x_transition.leave.end = classes;\r\n    }\r\n  };\r\n  directiveStorageMap[stage](classString);\r\n}\r\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\r\n  registerTransitionObject(el, setStyles);\r\n  let doesntSpecify = !modifiers.includes(\"in\") && !modifiers.includes(\"out\") && !stage;\r\n  let transitioningIn = doesntSpecify || modifiers.includes(\"in\") || [\"enter\"].includes(stage);\r\n  let transitioningOut = doesntSpecify || modifiers.includes(\"out\") || [\"leave\"].includes(stage);\r\n  if (modifiers.includes(\"in\") && !doesntSpecify) {\r\n    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf(\"out\"));\r\n  }\r\n  if (modifiers.includes(\"out\") && !doesntSpecify) {\r\n    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf(\"out\"));\r\n  }\r\n  let wantsAll = !modifiers.includes(\"opacity\") && !modifiers.includes(\"scale\");\r\n  let wantsOpacity = wantsAll || modifiers.includes(\"opacity\");\r\n  let wantsScale = wantsAll || modifiers.includes(\"scale\");\r\n  let opacityValue = wantsOpacity ? 0 : 1;\r\n  let scaleValue = wantsScale ? modifierValue(modifiers, \"scale\", 95) / 100 : 1;\r\n  let delay = modifierValue(modifiers, \"delay\", 0);\r\n  let origin = modifierValue(modifiers, \"origin\", \"center\");\r\n  let property = \"opacity, transform\";\r\n  let durationIn = modifierValue(modifiers, \"duration\", 150) / 1e3;\r\n  let durationOut = modifierValue(modifiers, \"duration\", 75) / 1e3;\r\n  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\r\n  if (transitioningIn) {\r\n    el._x_transition.enter.during = {\r\n      transformOrigin: origin,\r\n      transitionDelay: delay,\r\n      transitionProperty: property,\r\n      transitionDuration: `${durationIn}s`,\r\n      transitionTimingFunction: easing\r\n    };\r\n    el._x_transition.enter.start = {\r\n      opacity: opacityValue,\r\n      transform: `scale(${scaleValue})`\r\n    };\r\n    el._x_transition.enter.end = {\r\n      opacity: 1,\r\n      transform: `scale(1)`\r\n    };\r\n  }\r\n  if (transitioningOut) {\r\n    el._x_transition.leave.during = {\r\n      transformOrigin: origin,\r\n      transitionDelay: delay,\r\n      transitionProperty: property,\r\n      transitionDuration: `${durationOut}s`,\r\n      transitionTimingFunction: easing\r\n    };\r\n    el._x_transition.leave.start = {\r\n      opacity: 1,\r\n      transform: `scale(1)`\r\n    };\r\n    el._x_transition.leave.end = {\r\n      opacity: opacityValue,\r\n      transform: `scale(${scaleValue})`\r\n    };\r\n  }\r\n}\r\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\r\n  if (!el._x_transition)\r\n    el._x_transition = {\r\n      enter: { during: defaultValue, start: defaultValue, end: defaultValue },\r\n      leave: { during: defaultValue, start: defaultValue, end: defaultValue },\r\n      in(before = () => {\r\n      }, after = () => {\r\n      }) {\r\n        transition(el, setFunction, {\r\n          during: this.enter.during,\r\n          start: this.enter.start,\r\n          end: this.enter.end\r\n        }, before, after);\r\n      },\r\n      out(before = () => {\r\n      }, after = () => {\r\n      }) {\r\n        transition(el, setFunction, {\r\n          during: this.leave.during,\r\n          start: this.leave.start,\r\n          end: this.leave.end\r\n        }, before, after);\r\n      }\r\n    };\r\n}\r\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {\r\n  const nextTick2 = document.visibilityState === \"visible\" ? requestAnimationFrame : setTimeout;\r\n  let clickAwayCompatibleShow = () => nextTick2(show);\r\n  if (value) {\r\n    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\r\n      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();\r\n    } else {\r\n      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();\r\n    }\r\n    return;\r\n  }\r\n  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {\r\n    el._x_transition.out(() => {\r\n    }, () => resolve(hide));\r\n    el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));\r\n  }) : Promise.resolve(hide);\r\n  queueMicrotask(() => {\r\n    let closest = closestHide(el);\r\n    if (closest) {\r\n      if (!closest._x_hideChildren)\r\n        closest._x_hideChildren = [];\r\n      closest._x_hideChildren.push(el);\r\n    } else {\r\n      nextTick2(() => {\r\n        let hideAfterChildren = (el2) => {\r\n          let carry = Promise.all([\r\n            el2._x_hidePromise,\r\n            ...(el2._x_hideChildren || []).map(hideAfterChildren)\r\n          ]).then(([i]) => i());\r\n          delete el2._x_hidePromise;\r\n          delete el2._x_hideChildren;\r\n          return carry;\r\n        };\r\n        hideAfterChildren(el).catch((e) => {\r\n          if (!e.isFromCancelledTransition)\r\n            throw e;\r\n        });\r\n      });\r\n    }\r\n  });\r\n};\r\nfunction closestHide(el) {\r\n  let parent = el.parentNode;\r\n  if (!parent)\r\n    return;\r\n  return parent._x_hidePromise ? parent : closestHide(parent);\r\n}\r\nfunction transition(el, setFunction, { during, start: start2, end } = {}, before = () => {\r\n}, after = () => {\r\n}) {\r\n  if (el._x_transitioning)\r\n    el._x_transitioning.cancel();\r\n  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {\r\n    before();\r\n    after();\r\n    return;\r\n  }\r\n  let undoStart, undoDuring, undoEnd;\r\n  performTransition(el, {\r\n    start() {\r\n      undoStart = setFunction(el, start2);\r\n    },\r\n    during() {\r\n      undoDuring = setFunction(el, during);\r\n    },\r\n    before,\r\n    end() {\r\n      undoStart();\r\n      undoEnd = setFunction(el, end);\r\n    },\r\n    after,\r\n    cleanup() {\r\n      undoDuring();\r\n      undoEnd();\r\n    }\r\n  });\r\n}\r\nfunction performTransition(el, stages) {\r\n  let interrupted, reachedBefore, reachedEnd;\r\n  let finish = once(() => {\r\n    mutateDom(() => {\r\n      interrupted = true;\r\n      if (!reachedBefore)\r\n        stages.before();\r\n      if (!reachedEnd) {\r\n        stages.end();\r\n        releaseNextTicks();\r\n      }\r\n      stages.after();\r\n      if (el.isConnected)\r\n        stages.cleanup();\r\n      delete el._x_transitioning;\r\n    });\r\n  });\r\n  el._x_transitioning = {\r\n    beforeCancels: [],\r\n    beforeCancel(callback) {\r\n      this.beforeCancels.push(callback);\r\n    },\r\n    cancel: once(function() {\r\n      while (this.beforeCancels.length) {\r\n        this.beforeCancels.shift()();\r\n      }\r\n      ;\r\n      finish();\r\n    }),\r\n    finish\r\n  };\r\n  mutateDom(() => {\r\n    stages.start();\r\n    stages.during();\r\n  });\r\n  holdNextTicks();\r\n  requestAnimationFrame(() => {\r\n    if (interrupted)\r\n      return;\r\n    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\r\n    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\r\n    if (duration === 0)\r\n      duration = Number(getComputedStyle(el).animationDuration.replace(\"s\", \"\")) * 1e3;\r\n    mutateDom(() => {\r\n      stages.before();\r\n    });\r\n    reachedBefore = true;\r\n    requestAnimationFrame(() => {\r\n      if (interrupted)\r\n        return;\r\n      mutateDom(() => {\r\n        stages.end();\r\n      });\r\n      releaseNextTicks();\r\n      setTimeout(el._x_transitioning.finish, duration + delay);\r\n      reachedEnd = true;\r\n    });\r\n  });\r\n}\r\nfunction modifierValue(modifiers, key, fallback) {\r\n  if (modifiers.indexOf(key) === -1)\r\n    return fallback;\r\n  const rawValue = modifiers[modifiers.indexOf(key) + 1];\r\n  if (!rawValue)\r\n    return fallback;\r\n  if (key === \"scale\") {\r\n    if (isNaN(rawValue))\r\n      return fallback;\r\n  }\r\n  if (key === \"duration\") {\r\n    let match = rawValue.match(/([0-9]+)ms/);\r\n    if (match)\r\n      return match[1];\r\n  }\r\n  if (key === \"origin\") {\r\n    if ([\"top\", \"right\", \"left\", \"center\", \"bottom\"].includes(modifiers[modifiers.indexOf(key) + 2])) {\r\n      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(\" \");\r\n    }\r\n  }\r\n  return rawValue;\r\n}\r\n\r\n// packages/alpinejs/src/clone.js\r\nvar isCloning = false;\r\nfunction skipDuringClone(callback, fallback = () => {\r\n}) {\r\n  return (...args) => isCloning ? fallback(...args) : callback(...args);\r\n}\r\nfunction onlyDuringClone(callback) {\r\n  return (...args) => isCloning && callback(...args);\r\n}\r\nfunction clone(oldEl, newEl) {\r\n  if (!newEl._x_dataStack)\r\n    newEl._x_dataStack = oldEl._x_dataStack;\r\n  isCloning = true;\r\n  dontRegisterReactiveSideEffects(() => {\r\n    cloneTree(newEl);\r\n  });\r\n  isCloning = false;\r\n}\r\nfunction cloneTree(el) {\r\n  let hasRunThroughFirstEl = false;\r\n  let shallowWalker = (el2, callback) => {\r\n    walk(el2, (el3, skip) => {\r\n      if (hasRunThroughFirstEl && isRoot(el3))\r\n        return skip();\r\n      hasRunThroughFirstEl = true;\r\n      callback(el3, skip);\r\n    });\r\n  };\r\n  initTree(el, shallowWalker);\r\n}\r\nfunction dontRegisterReactiveSideEffects(callback) {\r\n  let cache = effect;\r\n  overrideEffect((callback2, el) => {\r\n    let storedEffect = cache(callback2);\r\n    release(storedEffect);\r\n    return () => {\r\n    };\r\n  });\r\n  callback();\r\n  overrideEffect(cache);\r\n}\r\n\r\n// packages/alpinejs/src/utils/bind.js\r\nfunction bind(el, name, value, modifiers = []) {\r\n  if (!el._x_bindings)\r\n    el._x_bindings = reactive({});\r\n  el._x_bindings[name] = value;\r\n  name = modifiers.includes(\"camel\") ? camelCase(name) : name;\r\n  switch (name) {\r\n    case \"value\":\r\n      bindInputValue(el, value);\r\n      break;\r\n    case \"style\":\r\n      bindStyles(el, value);\r\n      break;\r\n    case \"class\":\r\n      bindClasses(el, value);\r\n      break;\r\n    default:\r\n      bindAttribute(el, name, value);\r\n      break;\r\n  }\r\n}\r\nfunction bindInputValue(el, value) {\r\n  if (el.type === \"radio\") {\r\n    if (el.attributes.value === void 0) {\r\n      el.value = value;\r\n    }\r\n    if (window.fromModel) {\r\n      el.checked = checkedAttrLooseCompare(el.value, value);\r\n    }\r\n  } else if (el.type === \"checkbox\") {\r\n    if (Number.isInteger(value)) {\r\n      el.value = value;\r\n    } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== \"boolean\" && ![null, void 0].includes(value)) {\r\n      el.value = String(value);\r\n    } else {\r\n      if (Array.isArray(value)) {\r\n        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));\r\n      } else {\r\n        el.checked = !!value;\r\n      }\r\n    }\r\n  } else if (el.tagName === \"SELECT\") {\r\n    updateSelect(el, value);\r\n  } else {\r\n    if (el.value === value)\r\n      return;\r\n    el.value = value;\r\n  }\r\n}\r\nfunction bindClasses(el, value) {\r\n  if (el._x_undoAddedClasses)\r\n    el._x_undoAddedClasses();\r\n  el._x_undoAddedClasses = setClasses(el, value);\r\n}\r\nfunction bindStyles(el, value) {\r\n  if (el._x_undoAddedStyles)\r\n    el._x_undoAddedStyles();\r\n  el._x_undoAddedStyles = setStyles(el, value);\r\n}\r\nfunction bindAttribute(el, name, value) {\r\n  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\r\n    el.removeAttribute(name);\r\n  } else {\r\n    if (isBooleanAttr(name))\r\n      value = name;\r\n    setIfChanged(el, name, value);\r\n  }\r\n}\r\nfunction setIfChanged(el, attrName, value) {\r\n  if (el.getAttribute(attrName) != value) {\r\n    el.setAttribute(attrName, value);\r\n  }\r\n}\r\nfunction updateSelect(el, value) {\r\n  const arrayWrappedValue = [].concat(value).map((value2) => {\r\n    return value2 + \"\";\r\n  });\r\n  Array.from(el.options).forEach((option) => {\r\n    option.selected = arrayWrappedValue.includes(option.value);\r\n  });\r\n}\r\nfunction camelCase(subject) {\r\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\r\n}\r\nfunction checkedAttrLooseCompare(valueA, valueB) {\r\n  return valueA == valueB;\r\n}\r\nfunction isBooleanAttr(attrName) {\r\n  const booleanAttributes = [\r\n    \"disabled\",\r\n    \"checked\",\r\n    \"required\",\r\n    \"readonly\",\r\n    \"hidden\",\r\n    \"open\",\r\n    \"selected\",\r\n    \"autofocus\",\r\n    \"itemscope\",\r\n    \"multiple\",\r\n    \"novalidate\",\r\n    \"allowfullscreen\",\r\n    \"allowpaymentrequest\",\r\n    \"formnovalidate\",\r\n    \"autoplay\",\r\n    \"controls\",\r\n    \"loop\",\r\n    \"muted\",\r\n    \"playsinline\",\r\n    \"default\",\r\n    \"ismap\",\r\n    \"reversed\",\r\n    \"async\",\r\n    \"defer\",\r\n    \"nomodule\"\r\n  ];\r\n  return booleanAttributes.includes(attrName);\r\n}\r\nfunction attributeShouldntBePreservedIfFalsy(name) {\r\n  return ![\"aria-pressed\", \"aria-checked\", \"aria-expanded\", \"aria-selected\"].includes(name);\r\n}\r\nfunction getBinding(el, name, fallback) {\r\n  if (el._x_bindings && el._x_bindings[name] !== void 0)\r\n    return el._x_bindings[name];\r\n  let attr = el.getAttribute(name);\r\n  if (attr === null)\r\n    return typeof fallback === \"function\" ? fallback() : fallback;\r\n  if (attr === \"\")\r\n    return true;\r\n  if (isBooleanAttr(name)) {\r\n    return !![name, \"true\"].includes(attr);\r\n  }\r\n  return attr;\r\n}\r\n\r\n// packages/alpinejs/src/utils/debounce.js\r\nfunction debounce(func, wait) {\r\n  var timeout;\r\n  return function() {\r\n    var context = this, args = arguments;\r\n    var later = function() {\r\n      timeout = null;\r\n      func.apply(context, args);\r\n    };\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(later, wait);\r\n  };\r\n}\r\n\r\n// packages/alpinejs/src/utils/throttle.js\r\nfunction throttle(func, limit) {\r\n  let inThrottle;\r\n  return function() {\r\n    let context = this, args = arguments;\r\n    if (!inThrottle) {\r\n      func.apply(context, args);\r\n      inThrottle = true;\r\n      setTimeout(() => inThrottle = false, limit);\r\n    }\r\n  };\r\n}\r\n\r\n// packages/alpinejs/src/plugin.js\r\nfunction plugin(callback) {\r\n  callback(alpine_default);\r\n}\r\n\r\n// packages/alpinejs/src/store.js\r\nvar stores = {};\r\nvar isReactive = false;\r\nfunction store(name, value) {\r\n  if (!isReactive) {\r\n    stores = reactive(stores);\r\n    isReactive = true;\r\n  }\r\n  if (value === void 0) {\r\n    return stores[name];\r\n  }\r\n  stores[name] = value;\r\n  if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"init\") && typeof value.init === \"function\") {\r\n    stores[name].init();\r\n  }\r\n  initInterceptors(stores[name]);\r\n}\r\nfunction getStores() {\r\n  return stores;\r\n}\r\n\r\n// packages/alpinejs/src/binds.js\r\nvar binds = {};\r\nfunction bind2(name, bindings) {\r\n  let getBindings = typeof bindings !== \"function\" ? () => bindings : bindings;\r\n  if (name instanceof Element) {\r\n    applyBindingsObject(name, getBindings());\r\n  } else {\r\n    binds[name] = getBindings;\r\n  }\r\n}\r\nfunction injectBindingProviders(obj) {\r\n  Object.entries(binds).forEach(([name, callback]) => {\r\n    Object.defineProperty(obj, name, {\r\n      get() {\r\n        return (...args) => {\r\n          return callback(...args);\r\n        };\r\n      }\r\n    });\r\n  });\r\n  return obj;\r\n}\r\nfunction applyBindingsObject(el, obj, original) {\r\n  let cleanupRunners = [];\r\n  while (cleanupRunners.length)\r\n    cleanupRunners.pop()();\r\n  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));\r\n  let staticAttributes = attributesOnly(attributes);\r\n  attributes = attributes.map((attribute) => {\r\n    if (staticAttributes.find((attr) => attr.name === attribute.name)) {\r\n      return {\r\n        name: `x-bind:${attribute.name}`,\r\n        value: `\"${attribute.value}\"`\r\n      };\r\n    }\r\n    return attribute;\r\n  });\r\n  directives(el, attributes, original).map((handle) => {\r\n    cleanupRunners.push(handle.runCleanups);\r\n    handle();\r\n  });\r\n}\r\n\r\n// packages/alpinejs/src/datas.js\r\nvar datas = {};\r\nfunction data(name, callback) {\r\n  datas[name] = callback;\r\n}\r\nfunction injectDataProviders(obj, context) {\r\n  Object.entries(datas).forEach(([name, callback]) => {\r\n    Object.defineProperty(obj, name, {\r\n      get() {\r\n        return (...args) => {\r\n          return callback.bind(context)(...args);\r\n        };\r\n      },\r\n      enumerable: false\r\n    });\r\n  });\r\n  return obj;\r\n}\r\n\r\n// packages/alpinejs/src/alpine.js\r\nvar Alpine = {\r\n  get reactive() {\r\n    return reactive;\r\n  },\r\n  get release() {\r\n    return release;\r\n  },\r\n  get effect() {\r\n    return effect;\r\n  },\r\n  get raw() {\r\n    return raw;\r\n  },\r\n  version: \"3.12.0\",\r\n  flushAndStopDeferringMutations,\r\n  dontAutoEvaluateFunctions,\r\n  disableEffectScheduling,\r\n  startObservingMutations,\r\n  stopObservingMutations,\r\n  setReactivityEngine,\r\n  closestDataStack,\r\n  skipDuringClone,\r\n  onlyDuringClone,\r\n  addRootSelector,\r\n  addInitSelector,\r\n  addScopeToNode,\r\n  deferMutations,\r\n  mapAttributes,\r\n  evaluateLater,\r\n  interceptInit,\r\n  setEvaluator,\r\n  mergeProxies,\r\n  findClosest,\r\n  closestRoot,\r\n  destroyTree,\r\n  interceptor,\r\n  // INTERNAL: not public API and is subject to change without major release.\r\n  transition,\r\n  // INTERNAL\r\n  setStyles,\r\n  // INTERNAL\r\n  mutateDom,\r\n  directive,\r\n  throttle,\r\n  debounce,\r\n  evaluate,\r\n  initTree,\r\n  nextTick,\r\n  prefixed: prefix,\r\n  prefix: setPrefix,\r\n  plugin,\r\n  magic,\r\n  store,\r\n  start,\r\n  clone,\r\n  bound: getBinding,\r\n  $data: scope,\r\n  walk,\r\n  data,\r\n  bind: bind2\r\n};\r\nvar alpine_default = Alpine;\r\n\r\n// node_modules/@vue/shared/dist/shared.esm-bundler.js\r\nfunction makeMap(str, expectsLowerCase) {\r\n  const map = /* @__PURE__ */ Object.create(null);\r\n  const list = str.split(\",\");\r\n  for (let i = 0; i < list.length; i++) {\r\n    map[list[i]] = true;\r\n  }\r\n  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];\r\n}\r\nvar specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nvar isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);\r\nvar EMPTY_OBJ =  true ? Object.freeze({}) : 0;\r\nvar EMPTY_ARR =  true ? Object.freeze([]) : 0;\r\nvar extend = Object.assign;\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\nvar hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nvar isArray = Array.isArray;\r\nvar isMap = (val) => toTypeString(val) === \"[object Map]\";\r\nvar isString = (val) => typeof val === \"string\";\r\nvar isSymbol = (val) => typeof val === \"symbol\";\r\nvar isObject = (val) => val !== null && typeof val === \"object\";\r\nvar objectToString = Object.prototype.toString;\r\nvar toTypeString = (value) => objectToString.call(value);\r\nvar toRawType = (value) => {\r\n  return toTypeString(value).slice(8, -1);\r\n};\r\nvar isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\r\nvar cacheStringFunction = (fn) => {\r\n  const cache = /* @__PURE__ */ Object.create(null);\r\n  return (str) => {\r\n    const hit = cache[str];\r\n    return hit || (cache[str] = fn(str));\r\n  };\r\n};\r\nvar camelizeRE = /-(\\w)/g;\r\nvar camelize = cacheStringFunction((str) => {\r\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\r\n});\r\nvar hyphenateRE = /\\B([A-Z])/g;\r\nvar hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\r\nvar capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\nvar toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\r\nvar hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\n\r\n// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\r\nvar targetMap = /* @__PURE__ */ new WeakMap();\r\nvar effectStack = [];\r\nvar activeEffect;\r\nvar ITERATE_KEY = Symbol( true ? \"iterate\" : 0);\r\nvar MAP_KEY_ITERATE_KEY = Symbol( true ? \"Map key iterate\" : 0);\r\nfunction isEffect(fn) {\r\n  return fn && fn._isEffect === true;\r\n}\r\nfunction effect2(fn, options = EMPTY_OBJ) {\r\n  if (isEffect(fn)) {\r\n    fn = fn.raw;\r\n  }\r\n  const effect3 = createReactiveEffect(fn, options);\r\n  if (!options.lazy) {\r\n    effect3();\r\n  }\r\n  return effect3;\r\n}\r\nfunction stop(effect3) {\r\n  if (effect3.active) {\r\n    cleanup(effect3);\r\n    if (effect3.options.onStop) {\r\n      effect3.options.onStop();\r\n    }\r\n    effect3.active = false;\r\n  }\r\n}\r\nvar uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n  const effect3 = function reactiveEffect() {\r\n    if (!effect3.active) {\r\n      return fn();\r\n    }\r\n    if (!effectStack.includes(effect3)) {\r\n      cleanup(effect3);\r\n      try {\r\n        enableTracking();\r\n        effectStack.push(effect3);\r\n        activeEffect = effect3;\r\n        return fn();\r\n      } finally {\r\n        effectStack.pop();\r\n        resetTracking();\r\n        activeEffect = effectStack[effectStack.length - 1];\r\n      }\r\n    }\r\n  };\r\n  effect3.id = uid++;\r\n  effect3.allowRecurse = !!options.allowRecurse;\r\n  effect3._isEffect = true;\r\n  effect3.active = true;\r\n  effect3.raw = fn;\r\n  effect3.deps = [];\r\n  effect3.options = options;\r\n  return effect3;\r\n}\r\nfunction cleanup(effect3) {\r\n  const { deps } = effect3;\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].delete(effect3);\r\n    }\r\n    deps.length = 0;\r\n  }\r\n}\r\nvar shouldTrack = true;\r\nvar trackStack = [];\r\nfunction pauseTracking() {\r\n  trackStack.push(shouldTrack);\r\n  shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n  trackStack.push(shouldTrack);\r\n  shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n  const last = trackStack.pop();\r\n  shouldTrack = last === void 0 ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n  if (!shouldTrack || activeEffect === void 0) {\r\n    return;\r\n  }\r\n  let depsMap = targetMap.get(target);\r\n  if (!depsMap) {\r\n    targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\r\n  }\r\n  let dep = depsMap.get(key);\r\n  if (!dep) {\r\n    depsMap.set(key, dep = /* @__PURE__ */ new Set());\r\n  }\r\n  if (!dep.has(activeEffect)) {\r\n    dep.add(activeEffect);\r\n    activeEffect.deps.push(dep);\r\n    if (activeEffect.options.onTrack) {\r\n      activeEffect.options.onTrack({\r\n        effect: activeEffect,\r\n        target,\r\n        type,\r\n        key\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n  const depsMap = targetMap.get(target);\r\n  if (!depsMap) {\r\n    return;\r\n  }\r\n  const effects = /* @__PURE__ */ new Set();\r\n  const add2 = (effectsToAdd) => {\r\n    if (effectsToAdd) {\r\n      effectsToAdd.forEach((effect3) => {\r\n        if (effect3 !== activeEffect || effect3.allowRecurse) {\r\n          effects.add(effect3);\r\n        }\r\n      });\r\n    }\r\n  };\r\n  if (type === \"clear\") {\r\n    depsMap.forEach(add2);\r\n  } else if (key === \"length\" && isArray(target)) {\r\n    depsMap.forEach((dep, key2) => {\r\n      if (key2 === \"length\" || key2 >= newValue) {\r\n        add2(dep);\r\n      }\r\n    });\r\n  } else {\r\n    if (key !== void 0) {\r\n      add2(depsMap.get(key));\r\n    }\r\n    switch (type) {\r\n      case \"add\":\r\n        if (!isArray(target)) {\r\n          add2(depsMap.get(ITERATE_KEY));\r\n          if (isMap(target)) {\r\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n          }\r\n        } else if (isIntegerKey(key)) {\r\n          add2(depsMap.get(\"length\"));\r\n        }\r\n        break;\r\n      case \"delete\":\r\n        if (!isArray(target)) {\r\n          add2(depsMap.get(ITERATE_KEY));\r\n          if (isMap(target)) {\r\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n          }\r\n        }\r\n        break;\r\n      case \"set\":\r\n        if (isMap(target)) {\r\n          add2(depsMap.get(ITERATE_KEY));\r\n        }\r\n        break;\r\n    }\r\n  }\r\n  const run = (effect3) => {\r\n    if (effect3.options.onTrigger) {\r\n      effect3.options.onTrigger({\r\n        effect: effect3,\r\n        target,\r\n        key,\r\n        type,\r\n        newValue,\r\n        oldValue,\r\n        oldTarget\r\n      });\r\n    }\r\n    if (effect3.options.scheduler) {\r\n      effect3.options.scheduler(effect3);\r\n    } else {\r\n      effect3();\r\n    }\r\n  };\r\n  effects.forEach(run);\r\n}\r\nvar isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\r\nvar builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));\r\nvar get2 = /* @__PURE__ */ createGetter();\r\nvar shallowGet = /* @__PURE__ */ createGetter(false, true);\r\nvar readonlyGet = /* @__PURE__ */ createGetter(true);\r\nvar shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);\r\nvar arrayInstrumentations = {};\r\n[\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\r\n  const method = Array.prototype[key];\r\n  arrayInstrumentations[key] = function(...args) {\r\n    const arr = toRaw(this);\r\n    for (let i = 0, l = this.length; i < l; i++) {\r\n      track(arr, \"get\", i + \"\");\r\n    }\r\n    const res = method.apply(arr, args);\r\n    if (res === -1 || res === false) {\r\n      return method.apply(arr, args.map(toRaw));\r\n    } else {\r\n      return res;\r\n    }\r\n  };\r\n});\r\n[\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\r\n  const method = Array.prototype[key];\r\n  arrayInstrumentations[key] = function(...args) {\r\n    pauseTracking();\r\n    const res = method.apply(this, args);\r\n    resetTracking();\r\n    return res;\r\n  };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get3(target, key, receiver) {\r\n    if (key === \"__v_isReactive\") {\r\n      return !isReadonly;\r\n    } else if (key === \"__v_isReadonly\") {\r\n      return isReadonly;\r\n    } else if (key === \"__v_raw\" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\r\n      return target;\r\n    }\r\n    const targetIsArray = isArray(target);\r\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n      return Reflect.get(arrayInstrumentations, key, receiver);\r\n    }\r\n    const res = Reflect.get(target, key, receiver);\r\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n      return res;\r\n    }\r\n    if (!isReadonly) {\r\n      track(target, \"get\", key);\r\n    }\r\n    if (shallow) {\r\n      return res;\r\n    }\r\n    if (isRef(res)) {\r\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n      return shouldUnwrap ? res.value : res;\r\n    }\r\n    if (isObject(res)) {\r\n      return isReadonly ? readonly(res) : reactive2(res);\r\n    }\r\n    return res;\r\n  };\r\n}\r\nvar set2 = /* @__PURE__ */ createSetter();\r\nvar shallowSet = /* @__PURE__ */ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n  return function set3(target, key, value, receiver) {\r\n    let oldValue = target[key];\r\n    if (!shallow) {\r\n      value = toRaw(value);\r\n      oldValue = toRaw(oldValue);\r\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n        oldValue.value = value;\r\n        return true;\r\n      }\r\n    }\r\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\r\n    const result = Reflect.set(target, key, value, receiver);\r\n    if (target === toRaw(receiver)) {\r\n      if (!hadKey) {\r\n        trigger(target, \"add\", key, value);\r\n      } else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\", key, value, oldValue);\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n}\r\nfunction deleteProperty(target, key) {\r\n  const hadKey = hasOwn(target, key);\r\n  const oldValue = target[key];\r\n  const result = Reflect.deleteProperty(target, key);\r\n  if (result && hadKey) {\r\n    trigger(target, \"delete\", key, void 0, oldValue);\r\n  }\r\n  return result;\r\n}\r\nfunction has(target, key) {\r\n  const result = Reflect.has(target, key);\r\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n    track(target, \"has\", key);\r\n  }\r\n  return result;\r\n}\r\nfunction ownKeys(target) {\r\n  track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\r\n  return Reflect.ownKeys(target);\r\n}\r\nvar mutableHandlers = {\r\n  get: get2,\r\n  set: set2,\r\n  deleteProperty,\r\n  has,\r\n  ownKeys\r\n};\r\nvar readonlyHandlers = {\r\n  get: readonlyGet,\r\n  set(target, key) {\r\n    if (true) {\r\n      console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n    }\r\n    return true;\r\n  },\r\n  deleteProperty(target, key) {\r\n    if (true) {\r\n      console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n    }\r\n    return true;\r\n  }\r\n};\r\nvar shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n  get: shallowGet,\r\n  set: shallowSet\r\n});\r\nvar shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n  get: shallowReadonlyGet\r\n});\r\nvar toReactive = (value) => isObject(value) ? reactive2(value) : value;\r\nvar toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nvar toShallow = (value) => value;\r\nvar getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n  target = target[\r\n    \"__v_raw\"\r\n    /* RAW */\r\n  ];\r\n  const rawTarget = toRaw(target);\r\n  const rawKey = toRaw(key);\r\n  if (key !== rawKey) {\r\n    !isReadonly && track(rawTarget, \"get\", key);\r\n  }\r\n  !isReadonly && track(rawTarget, \"get\", rawKey);\r\n  const { has: has2 } = getProto(rawTarget);\r\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n  if (has2.call(rawTarget, key)) {\r\n    return wrap(target.get(key));\r\n  } else if (has2.call(rawTarget, rawKey)) {\r\n    return wrap(target.get(rawKey));\r\n  } else if (target !== rawTarget) {\r\n    target.get(key);\r\n  }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n  const target = this[\r\n    \"__v_raw\"\r\n    /* RAW */\r\n  ];\r\n  const rawTarget = toRaw(target);\r\n  const rawKey = toRaw(key);\r\n  if (key !== rawKey) {\r\n    !isReadonly && track(rawTarget, \"has\", key);\r\n  }\r\n  !isReadonly && track(rawTarget, \"has\", rawKey);\r\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n  target = target[\r\n    \"__v_raw\"\r\n    /* RAW */\r\n  ];\r\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\r\n  return Reflect.get(target, \"size\", target);\r\n}\r\nfunction add(value) {\r\n  value = toRaw(value);\r\n  const target = toRaw(this);\r\n  const proto = getProto(target);\r\n  const hadKey = proto.has.call(target, value);\r\n  if (!hadKey) {\r\n    target.add(value);\r\n    trigger(target, \"add\", value, value);\r\n  }\r\n  return this;\r\n}\r\nfunction set$1(key, value) {\r\n  value = toRaw(value);\r\n  const target = toRaw(this);\r\n  const { has: has2, get: get3 } = getProto(target);\r\n  let hadKey = has2.call(target, key);\r\n  if (!hadKey) {\r\n    key = toRaw(key);\r\n    hadKey = has2.call(target, key);\r\n  } else if (true) {\r\n    checkIdentityKeys(target, has2, key);\r\n  }\r\n  const oldValue = get3.call(target, key);\r\n  target.set(key, value);\r\n  if (!hadKey) {\r\n    trigger(target, \"add\", key, value);\r\n  } else if (hasChanged(value, oldValue)) {\r\n    trigger(target, \"set\", key, value, oldValue);\r\n  }\r\n  return this;\r\n}\r\nfunction deleteEntry(key) {\r\n  const target = toRaw(this);\r\n  const { has: has2, get: get3 } = getProto(target);\r\n  let hadKey = has2.call(target, key);\r\n  if (!hadKey) {\r\n    key = toRaw(key);\r\n    hadKey = has2.call(target, key);\r\n  } else if (true) {\r\n    checkIdentityKeys(target, has2, key);\r\n  }\r\n  const oldValue = get3 ? get3.call(target, key) : void 0;\r\n  const result = target.delete(key);\r\n  if (hadKey) {\r\n    trigger(target, \"delete\", key, void 0, oldValue);\r\n  }\r\n  return result;\r\n}\r\nfunction clear() {\r\n  const target = toRaw(this);\r\n  const hadItems = target.size !== 0;\r\n  const oldTarget =  true ? isMap(target) ? new Map(target) : new Set(target) : 0;\r\n  const result = target.clear();\r\n  if (hadItems) {\r\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\r\n  }\r\n  return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n  return function forEach(callback, thisArg) {\r\n    const observed = this;\r\n    const target = observed[\r\n      \"__v_raw\"\r\n      /* RAW */\r\n    ];\r\n    const rawTarget = toRaw(target);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\r\n    return target.forEach((value, key) => {\r\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n    });\r\n  };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n  return function(...args) {\r\n    const target = this[\r\n      \"__v_raw\"\r\n      /* RAW */\r\n    ];\r\n    const rawTarget = toRaw(target);\r\n    const targetIsMap = isMap(rawTarget);\r\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\r\n    const isKeyOnly = method === \"keys\" && targetIsMap;\r\n    const innerIterator = target[method](...args);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    !isReadonly && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n    return {\r\n      // iterator protocol\r\n      next() {\r\n        const { value, done } = innerIterator.next();\r\n        return done ? { value, done } : {\r\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n          done\r\n        };\r\n      },\r\n      // iterable protocol\r\n      [Symbol.iterator]() {\r\n        return this;\r\n      }\r\n    };\r\n  };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n  return function(...args) {\r\n    if (true) {\r\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n    }\r\n    return type === \"delete\" ? false : this;\r\n  };\r\n}\r\nvar mutableInstrumentations = {\r\n  get(key) {\r\n    return get$1(this, key);\r\n  },\r\n  get size() {\r\n    return size(this);\r\n  },\r\n  has: has$1,\r\n  add,\r\n  set: set$1,\r\n  delete: deleteEntry,\r\n  clear,\r\n  forEach: createForEach(false, false)\r\n};\r\nvar shallowInstrumentations = {\r\n  get(key) {\r\n    return get$1(this, key, false, true);\r\n  },\r\n  get size() {\r\n    return size(this);\r\n  },\r\n  has: has$1,\r\n  add,\r\n  set: set$1,\r\n  delete: deleteEntry,\r\n  clear,\r\n  forEach: createForEach(false, true)\r\n};\r\nvar readonlyInstrumentations = {\r\n  get(key) {\r\n    return get$1(this, key, true);\r\n  },\r\n  get size() {\r\n    return size(this, true);\r\n  },\r\n  has(key) {\r\n    return has$1.call(this, key, true);\r\n  },\r\n  add: createReadonlyMethod(\r\n    \"add\"\r\n    /* ADD */\r\n  ),\r\n  set: createReadonlyMethod(\r\n    \"set\"\r\n    /* SET */\r\n  ),\r\n  delete: createReadonlyMethod(\r\n    \"delete\"\r\n    /* DELETE */\r\n  ),\r\n  clear: createReadonlyMethod(\r\n    \"clear\"\r\n    /* CLEAR */\r\n  ),\r\n  forEach: createForEach(true, false)\r\n};\r\nvar shallowReadonlyInstrumentations = {\r\n  get(key) {\r\n    return get$1(this, key, true, true);\r\n  },\r\n  get size() {\r\n    return size(this, true);\r\n  },\r\n  has(key) {\r\n    return has$1.call(this, key, true);\r\n  },\r\n  add: createReadonlyMethod(\r\n    \"add\"\r\n    /* ADD */\r\n  ),\r\n  set: createReadonlyMethod(\r\n    \"set\"\r\n    /* SET */\r\n  ),\r\n  delete: createReadonlyMethod(\r\n    \"delete\"\r\n    /* DELETE */\r\n  ),\r\n  clear: createReadonlyMethod(\r\n    \"clear\"\r\n    /* CLEAR */\r\n  ),\r\n  forEach: createForEach(true, true)\r\n};\r\nvar iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\r\niteratorMethods.forEach((method) => {\r\n  mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n  readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n  shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n  shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\r\n  return (target, key, receiver) => {\r\n    if (key === \"__v_isReactive\") {\r\n      return !isReadonly;\r\n    } else if (key === \"__v_isReadonly\") {\r\n      return isReadonly;\r\n    } else if (key === \"__v_raw\") {\r\n      return target;\r\n    }\r\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\r\n  };\r\n}\r\nvar mutableCollectionHandlers = {\r\n  get: createInstrumentationGetter(false, false)\r\n};\r\nvar shallowCollectionHandlers = {\r\n  get: createInstrumentationGetter(false, true)\r\n};\r\nvar readonlyCollectionHandlers = {\r\n  get: createInstrumentationGetter(true, false)\r\n};\r\nvar shallowReadonlyCollectionHandlers = {\r\n  get: createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has2, key) {\r\n  const rawKey = toRaw(key);\r\n  if (rawKey !== key && has2.call(target, rawKey)) {\r\n    const type = toRawType(target);\r\n    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\r\n  }\r\n}\r\nvar reactiveMap = /* @__PURE__ */ new WeakMap();\r\nvar shallowReactiveMap = /* @__PURE__ */ new WeakMap();\r\nvar readonlyMap = /* @__PURE__ */ new WeakMap();\r\nvar shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n  switch (rawType) {\r\n    case \"Object\":\r\n    case \"Array\":\r\n      return 1;\r\n    case \"Map\":\r\n    case \"Set\":\r\n    case \"WeakMap\":\r\n    case \"WeakSet\":\r\n      return 2;\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\nfunction getTargetType(value) {\r\n  return value[\r\n    \"__v_skip\"\r\n    /* SKIP */\r\n  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive2(target) {\r\n  if (target && target[\r\n    \"__v_isReadonly\"\r\n    /* IS_READONLY */\r\n  ]) {\r\n    return target;\r\n  }\r\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\nfunction readonly(target) {\r\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n  if (!isObject(target)) {\r\n    if (true) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`);\r\n    }\r\n    return target;\r\n  }\r\n  if (target[\r\n    \"__v_raw\"\r\n    /* RAW */\r\n  ] && !(isReadonly && target[\r\n    \"__v_isReactive\"\r\n    /* IS_REACTIVE */\r\n  ])) {\r\n    return target;\r\n  }\r\n  const existingProxy = proxyMap.get(target);\r\n  if (existingProxy) {\r\n    return existingProxy;\r\n  }\r\n  const targetType = getTargetType(target);\r\n  if (targetType === 0) {\r\n    return target;\r\n  }\r\n  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);\r\n  proxyMap.set(target, proxy);\r\n  return proxy;\r\n}\r\nfunction toRaw(observed) {\r\n  return observed && toRaw(observed[\r\n    \"__v_raw\"\r\n    /* RAW */\r\n  ]) || observed;\r\n}\r\nfunction isRef(r) {\r\n  return Boolean(r && r.__v_isRef === true);\r\n}\r\n\r\n// packages/alpinejs/src/magics/$nextTick.js\r\nmagic(\"nextTick\", () => nextTick);\r\n\r\n// packages/alpinejs/src/magics/$dispatch.js\r\nmagic(\"dispatch\", (el) => dispatch.bind(dispatch, el));\r\n\r\n// packages/alpinejs/src/magics/$watch.js\r\nmagic(\"watch\", (el, { evaluateLater: evaluateLater2, effect: effect3 }) => (key, callback) => {\r\n  let evaluate2 = evaluateLater2(key);\r\n  let firstTime = true;\r\n  let oldValue;\r\n  let effectReference = effect3(() => evaluate2((value) => {\r\n    JSON.stringify(value);\r\n    if (!firstTime) {\r\n      queueMicrotask(() => {\r\n        callback(value, oldValue);\r\n        oldValue = value;\r\n      });\r\n    } else {\r\n      oldValue = value;\r\n    }\r\n    firstTime = false;\r\n  }));\r\n  el._x_effects.delete(effectReference);\r\n});\r\n\r\n// packages/alpinejs/src/magics/$store.js\r\nmagic(\"store\", getStores);\r\n\r\n// packages/alpinejs/src/magics/$data.js\r\nmagic(\"data\", (el) => scope(el));\r\n\r\n// packages/alpinejs/src/magics/$root.js\r\nmagic(\"root\", (el) => closestRoot(el));\r\n\r\n// packages/alpinejs/src/magics/$refs.js\r\nmagic(\"refs\", (el) => {\r\n  if (el._x_refs_proxy)\r\n    return el._x_refs_proxy;\r\n  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));\r\n  return el._x_refs_proxy;\r\n});\r\nfunction getArrayOfRefObject(el) {\r\n  let refObjects = [];\r\n  let currentEl = el;\r\n  while (currentEl) {\r\n    if (currentEl._x_refs)\r\n      refObjects.push(currentEl._x_refs);\r\n    currentEl = currentEl.parentNode;\r\n  }\r\n  return refObjects;\r\n}\r\n\r\n// packages/alpinejs/src/ids.js\r\nvar globalIdMemo = {};\r\nfunction findAndIncrementId(name) {\r\n  if (!globalIdMemo[name])\r\n    globalIdMemo[name] = 0;\r\n  return ++globalIdMemo[name];\r\n}\r\nfunction closestIdRoot(el, name) {\r\n  return findClosest(el, (element) => {\r\n    if (element._x_ids && element._x_ids[name])\r\n      return true;\r\n  });\r\n}\r\nfunction setIdRoot(el, name) {\r\n  if (!el._x_ids)\r\n    el._x_ids = {};\r\n  if (!el._x_ids[name])\r\n    el._x_ids[name] = findAndIncrementId(name);\r\n}\r\n\r\n// packages/alpinejs/src/magics/$id.js\r\nmagic(\"id\", (el) => (name, key = null) => {\r\n  let root = closestIdRoot(el, name);\r\n  let id = root ? root._x_ids[name] : findAndIncrementId(name);\r\n  return key ? `${name}-${id}-${key}` : `${name}-${id}`;\r\n});\r\n\r\n// packages/alpinejs/src/magics/$el.js\r\nmagic(\"el\", (el) => el);\r\n\r\n// packages/alpinejs/src/magics/index.js\r\nwarnMissingPluginMagic(\"Focus\", \"focus\", \"focus\");\r\nwarnMissingPluginMagic(\"Persist\", \"persist\", \"persist\");\r\nfunction warnMissingPluginMagic(name, magicName, slug) {\r\n  magic(magicName, (el) => warn(`You can't use [$${directiveName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\r\n}\r\n\r\n// packages/alpinejs/src/entangle.js\r\nfunction entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {\r\n  let firstRun = true;\r\n  let outerHash, innerHash, outerHashLatest, innerHashLatest;\r\n  let reference = effect(() => {\r\n    let outer, inner;\r\n    if (firstRun) {\r\n      outer = outerGet();\r\n      innerSet(outer);\r\n      inner = innerGet();\r\n      firstRun = false;\r\n    } else {\r\n      outer = outerGet();\r\n      inner = innerGet();\r\n      outerHashLatest = JSON.stringify(outer);\r\n      innerHashLatest = JSON.stringify(inner);\r\n      if (outerHashLatest !== outerHash) {\r\n        inner = innerGet();\r\n        innerSet(outer);\r\n        inner = outer;\r\n      } else {\r\n        outerSet(inner);\r\n        outer = inner;\r\n      }\r\n    }\r\n    outerHash = JSON.stringify(outer);\r\n    innerHash = JSON.stringify(inner);\r\n  });\r\n  return () => {\r\n    release(reference);\r\n  };\r\n}\r\n\r\n// packages/alpinejs/src/directives/x-modelable.js\r\ndirective(\"modelable\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {\r\n  let func = evaluateLater2(expression);\r\n  let innerGet = () => {\r\n    let result;\r\n    func((i) => result = i);\r\n    return result;\r\n  };\r\n  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);\r\n  let innerSet = (val) => evaluateInnerSet(() => {\r\n  }, { scope: { \"__placeholder\": val } });\r\n  let initialValue = innerGet();\r\n  innerSet(initialValue);\r\n  queueMicrotask(() => {\r\n    if (!el._x_model)\r\n      return;\r\n    el._x_removeModelListeners[\"default\"]();\r\n    let outerGet = el._x_model.get;\r\n    let outerSet = el._x_model.set;\r\n    let releaseEntanglement = entangle(\r\n      {\r\n        get() {\r\n          return outerGet();\r\n        },\r\n        set(value) {\r\n          outerSet(value);\r\n        }\r\n      },\r\n      {\r\n        get() {\r\n          return innerGet();\r\n        },\r\n        set(value) {\r\n          innerSet(value);\r\n        }\r\n      }\r\n    );\r\n    cleanup2(releaseEntanglement);\r\n  });\r\n});\r\n\r\n// packages/alpinejs/src/directives/x-teleport.js\r\nvar teleportContainerDuringClone = document.createElement(\"div\");\r\ndirective(\"teleport\", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {\r\n  if (el.tagName.toLowerCase() !== \"template\")\r\n    warn(\"x-teleport can only be used on a <template> tag\", el);\r\n  let target = skipDuringClone(() => {\r\n    return document.querySelector(expression);\r\n  }, () => {\r\n    return teleportContainerDuringClone;\r\n  })();\r\n  if (!target)\r\n    warn(`Cannot find x-teleport element for selector: \"${expression}\"`);\r\n  let clone2 = el.content.cloneNode(true).firstElementChild;\r\n  el._x_teleport = clone2;\r\n  clone2._x_teleportBack = el;\r\n  if (el._x_forwardEvents) {\r\n    el._x_forwardEvents.forEach((eventName) => {\r\n      clone2.addEventListener(eventName, (e) => {\r\n        e.stopPropagation();\r\n        el.dispatchEvent(new e.constructor(e.type, e));\r\n      });\r\n    });\r\n  }\r\n  addScopeToNode(clone2, {}, el);\r\n  mutateDom(() => {\r\n    if (modifiers.includes(\"prepend\")) {\r\n      target.parentNode.insertBefore(clone2, target);\r\n    } else if (modifiers.includes(\"append\")) {\r\n      target.parentNode.insertBefore(clone2, target.nextSibling);\r\n    } else {\r\n      target.appendChild(clone2);\r\n    }\r\n    initTree(clone2);\r\n    clone2._x_ignore = true;\r\n  });\r\n  cleanup2(() => clone2.remove());\r\n});\r\n\r\n// packages/alpinejs/src/directives/x-ignore.js\r\nvar handler = () => {\r\n};\r\nhandler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {\r\n  modifiers.includes(\"self\") ? el._x_ignoreSelf = true : el._x_ignore = true;\r\n  cleanup2(() => {\r\n    modifiers.includes(\"self\") ? delete el._x_ignoreSelf : delete el._x_ignore;\r\n  });\r\n};\r\ndirective(\"ignore\", handler);\r\n\r\n// packages/alpinejs/src/directives/x-effect.js\r\ndirective(\"effect\", (el, { expression }, { effect: effect3 }) => effect3(evaluateLater(el, expression)));\r\n\r\n// packages/alpinejs/src/utils/on.js\r\nfunction on(el, event, modifiers, callback) {\r\n  let listenerTarget = el;\r\n  let handler3 = (e) => callback(e);\r\n  let options = {};\r\n  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);\r\n  if (modifiers.includes(\"dot\"))\r\n    event = dotSyntax(event);\r\n  if (modifiers.includes(\"camel\"))\r\n    event = camelCase2(event);\r\n  if (modifiers.includes(\"passive\"))\r\n    options.passive = true;\r\n  if (modifiers.includes(\"capture\"))\r\n    options.capture = true;\r\n  if (modifiers.includes(\"window\"))\r\n    listenerTarget = window;\r\n  if (modifiers.includes(\"document\"))\r\n    listenerTarget = document;\r\n  if (modifiers.includes(\"prevent\"))\r\n    handler3 = wrapHandler(handler3, (next, e) => {\r\n      e.preventDefault();\r\n      next(e);\r\n    });\r\n  if (modifiers.includes(\"stop\"))\r\n    handler3 = wrapHandler(handler3, (next, e) => {\r\n      e.stopPropagation();\r\n      next(e);\r\n    });\r\n  if (modifiers.includes(\"self\"))\r\n    handler3 = wrapHandler(handler3, (next, e) => {\r\n      e.target === el && next(e);\r\n    });\r\n  if (modifiers.includes(\"away\") || modifiers.includes(\"outside\")) {\r\n    listenerTarget = document;\r\n    handler3 = wrapHandler(handler3, (next, e) => {\r\n      if (el.contains(e.target))\r\n        return;\r\n      if (e.target.isConnected === false)\r\n        return;\r\n      if (el.offsetWidth < 1 && el.offsetHeight < 1)\r\n        return;\r\n      if (el._x_isShown === false)\r\n        return;\r\n      next(e);\r\n    });\r\n  }\r\n  if (modifiers.includes(\"once\")) {\r\n    handler3 = wrapHandler(handler3, (next, e) => {\r\n      next(e);\r\n      listenerTarget.removeEventListener(event, handler3, options);\r\n    });\r\n  }\r\n  handler3 = wrapHandler(handler3, (next, e) => {\r\n    if (isKeyEvent(event)) {\r\n      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\r\n        return;\r\n      }\r\n    }\r\n    next(e);\r\n  });\r\n  if (modifiers.includes(\"debounce\")) {\r\n    let nextModifier = modifiers[modifiers.indexOf(\"debounce\") + 1] || \"invalid-wait\";\r\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\r\n    handler3 = debounce(handler3, wait);\r\n  }\r\n  if (modifiers.includes(\"throttle\")) {\r\n    let nextModifier = modifiers[modifiers.indexOf(\"throttle\") + 1] || \"invalid-wait\";\r\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\r\n    handler3 = throttle(handler3, wait);\r\n  }\r\n  listenerTarget.addEventListener(event, handler3, options);\r\n  return () => {\r\n    listenerTarget.removeEventListener(event, handler3, options);\r\n  };\r\n}\r\nfunction dotSyntax(subject) {\r\n  return subject.replace(/-/g, \".\");\r\n}\r\nfunction camelCase2(subject) {\r\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\r\n}\r\nfunction isNumeric(subject) {\r\n  return !Array.isArray(subject) && !isNaN(subject);\r\n}\r\nfunction kebabCase2(subject) {\r\n  if ([\" \", \"_\"].includes(\r\n    subject\r\n  ))\r\n    return subject;\r\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[_\\s]/, \"-\").toLowerCase();\r\n}\r\nfunction isKeyEvent(event) {\r\n  return [\"keydown\", \"keyup\"].includes(event);\r\n}\r\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\r\n  let keyModifiers = modifiers.filter((i) => {\r\n    return ![\"window\", \"document\", \"prevent\", \"stop\", \"once\", \"capture\"].includes(i);\r\n  });\r\n  if (keyModifiers.includes(\"debounce\")) {\r\n    let debounceIndex = keyModifiers.indexOf(\"debounce\");\r\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\r\n  }\r\n  if (keyModifiers.includes(\"throttle\")) {\r\n    let debounceIndex = keyModifiers.indexOf(\"throttle\");\r\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\r\n  }\r\n  if (keyModifiers.length === 0)\r\n    return false;\r\n  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))\r\n    return false;\r\n  const systemKeyModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\", \"cmd\", \"super\"];\r\n  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));\r\n  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));\r\n  if (selectedSystemKeyModifiers.length > 0) {\r\n    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {\r\n      if (modifier === \"cmd\" || modifier === \"super\")\r\n        modifier = \"meta\";\r\n      return e[`${modifier}Key`];\r\n    });\r\n    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\r\n      if (keyToModifiers(e.key).includes(keyModifiers[0]))\r\n        return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\nfunction keyToModifiers(key) {\r\n  if (!key)\r\n    return [];\r\n  key = kebabCase2(key);\r\n  let modifierToKeyMap = {\r\n    \"ctrl\": \"control\",\r\n    \"slash\": \"/\",\r\n    \"space\": \" \",\r\n    \"spacebar\": \" \",\r\n    \"cmd\": \"meta\",\r\n    \"esc\": \"escape\",\r\n    \"up\": \"arrow-up\",\r\n    \"down\": \"arrow-down\",\r\n    \"left\": \"arrow-left\",\r\n    \"right\": \"arrow-right\",\r\n    \"period\": \".\",\r\n    \"equal\": \"=\",\r\n    \"minus\": \"-\",\r\n    \"underscore\": \"_\"\r\n  };\r\n  modifierToKeyMap[key] = key;\r\n  return Object.keys(modifierToKeyMap).map((modifier) => {\r\n    if (modifierToKeyMap[modifier] === key)\r\n      return modifier;\r\n  }).filter((modifier) => modifier);\r\n}\r\n\r\n// packages/alpinejs/src/directives/x-model.js\r\ndirective(\"model\", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {\r\n  let scopeTarget = el;\r\n  if (modifiers.includes(\"parent\")) {\r\n    scopeTarget = el.parentNode;\r\n  }\r\n  let evaluateGet = evaluateLater(scopeTarget, expression);\r\n  let evaluateSet;\r\n  if (typeof expression === \"string\") {\r\n    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);\r\n  } else if (typeof expression === \"function\" && typeof expression() === \"string\") {\r\n    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);\r\n  } else {\r\n    evaluateSet = () => {\r\n    };\r\n  }\r\n  let getValue = () => {\r\n    let result;\r\n    evaluateGet((value) => result = value);\r\n    return isGetterSetter(result) ? result.get() : result;\r\n  };\r\n  let setValue = (value) => {\r\n    let result;\r\n    evaluateGet((value2) => result = value2);\r\n    if (isGetterSetter(result)) {\r\n      result.set(value);\r\n    } else {\r\n      evaluateSet(() => {\r\n      }, {\r\n        scope: { \"__placeholder\": value }\r\n      });\r\n    }\r\n  };\r\n  if (modifiers.includes(\"fill\") && el.hasAttribute(\"value\") && (getValue() === null || getValue() === \"\")) {\r\n    setValue(el.value);\r\n  }\r\n  if (typeof expression === \"string\" && el.type === \"radio\") {\r\n    mutateDom(() => {\r\n      if (!el.hasAttribute(\"name\"))\r\n        el.setAttribute(\"name\", expression);\r\n    });\r\n  }\r\n  var event = el.tagName.toLowerCase() === \"select\" || [\"checkbox\", \"radio\"].includes(el.type) || modifiers.includes(\"lazy\") ? \"change\" : \"input\";\r\n  let removeListener = isCloning ? () => {\r\n  } : on(el, event, modifiers, (e) => {\r\n    setValue(getInputValue(el, modifiers, e, getValue()));\r\n  });\r\n  if (!el._x_removeModelListeners)\r\n    el._x_removeModelListeners = {};\r\n  el._x_removeModelListeners[\"default\"] = removeListener;\r\n  cleanup2(() => el._x_removeModelListeners[\"default\"]());\r\n  if (el.form) {\r\n    let removeResetListener = on(el.form, \"reset\", [], (e) => {\r\n      nextTick(() => el._x_model && el._x_model.set(el.value));\r\n    });\r\n    cleanup2(() => removeResetListener());\r\n  }\r\n  el._x_model = {\r\n    get() {\r\n      return getValue();\r\n    },\r\n    set(value) {\r\n      setValue(value);\r\n    }\r\n  };\r\n  el._x_forceModelUpdate = (value) => {\r\n    value = value === void 0 ? getValue() : value;\r\n    if (value === void 0 && typeof expression === \"string\" && expression.match(/\\./))\r\n      value = \"\";\r\n    window.fromModel = true;\r\n    mutateDom(() => bind(el, \"value\", value));\r\n    delete window.fromModel;\r\n  };\r\n  effect3(() => {\r\n    let value = getValue();\r\n    if (modifiers.includes(\"unintrusive\") && document.activeElement.isSameNode(el))\r\n      return;\r\n    el._x_forceModelUpdate(value);\r\n  });\r\n});\r\nfunction getInputValue(el, modifiers, event, currentValue) {\r\n  return mutateDom(() => {\r\n    if (event instanceof CustomEvent && event.detail !== void 0) {\r\n      return typeof event.detail != \"undefined\" ? event.detail : event.target.value;\r\n    } else if (el.type === \"checkbox\") {\r\n      if (Array.isArray(currentValue)) {\r\n        let newValue = modifiers.includes(\"number\") ? safeParseNumber(event.target.value) : event.target.value;\r\n        return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));\r\n      } else {\r\n        return event.target.checked;\r\n      }\r\n    } else if (el.tagName.toLowerCase() === \"select\" && el.multiple) {\r\n      return modifiers.includes(\"number\") ? Array.from(event.target.selectedOptions).map((option) => {\r\n        let rawValue = option.value || option.text;\r\n        return safeParseNumber(rawValue);\r\n      }) : Array.from(event.target.selectedOptions).map((option) => {\r\n        return option.value || option.text;\r\n      });\r\n    } else {\r\n      let rawValue = event.target.value;\r\n      return modifiers.includes(\"number\") ? safeParseNumber(rawValue) : modifiers.includes(\"trim\") ? rawValue.trim() : rawValue;\r\n    }\r\n  });\r\n}\r\nfunction safeParseNumber(rawValue) {\r\n  let number = rawValue ? parseFloat(rawValue) : null;\r\n  return isNumeric2(number) ? number : rawValue;\r\n}\r\nfunction checkedAttrLooseCompare2(valueA, valueB) {\r\n  return valueA == valueB;\r\n}\r\nfunction isNumeric2(subject) {\r\n  return !Array.isArray(subject) && !isNaN(subject);\r\n}\r\nfunction isGetterSetter(value) {\r\n  return value !== null && typeof value === \"object\" && typeof value.get === \"function\" && typeof value.set === \"function\";\r\n}\r\n\r\n// packages/alpinejs/src/directives/x-cloak.js\r\ndirective(\"cloak\", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix(\"cloak\")))));\r\n\r\n// packages/alpinejs/src/directives/x-init.js\r\naddInitSelector(() => `[${prefix(\"init\")}]`);\r\ndirective(\"init\", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {\r\n  if (typeof expression === \"string\") {\r\n    return !!expression.trim() && evaluate2(expression, {}, false);\r\n  }\r\n  return evaluate2(expression, {}, false);\r\n}));\r\n\r\n// packages/alpinejs/src/directives/x-text.js\r\ndirective(\"text\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\r\n  let evaluate2 = evaluateLater2(expression);\r\n  effect3(() => {\r\n    evaluate2((value) => {\r\n      mutateDom(() => {\r\n        el.textContent = value;\r\n      });\r\n    });\r\n  });\r\n});\r\n\r\n// packages/alpinejs/src/directives/x-html.js\r\ndirective(\"html\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\r\n  let evaluate2 = evaluateLater2(expression);\r\n  effect3(() => {\r\n    evaluate2((value) => {\r\n      mutateDom(() => {\r\n        el.innerHTML = value;\r\n        el._x_ignoreSelf = true;\r\n        initTree(el);\r\n        delete el._x_ignoreSelf;\r\n      });\r\n    });\r\n  });\r\n});\r\n\r\n// packages/alpinejs/src/directives/x-bind.js\r\nmapAttributes(startingWith(\":\", into(prefix(\"bind:\"))));\r\ndirective(\"bind\", (el, { value, modifiers, expression, original }, { effect: effect3 }) => {\r\n  if (!value) {\r\n    let bindingProviders = {};\r\n    injectBindingProviders(bindingProviders);\r\n    let getBindings = evaluateLater(el, expression);\r\n    getBindings((bindings) => {\r\n      applyBindingsObject(el, bindings, original);\r\n    }, { scope: bindingProviders });\r\n    return;\r\n  }\r\n  if (value === \"key\")\r\n    return storeKeyForXFor(el, expression);\r\n  let evaluate2 = evaluateLater(el, expression);\r\n  effect3(() => evaluate2((result) => {\r\n    if (result === void 0 && typeof expression === \"string\" && expression.match(/\\./)) {\r\n      result = \"\";\r\n    }\r\n    mutateDom(() => bind(el, value, result, modifiers));\r\n  }));\r\n});\r\nfunction storeKeyForXFor(el, expression) {\r\n  el._x_keyExpression = expression;\r\n}\r\n\r\n// packages/alpinejs/src/directives/x-data.js\r\naddRootSelector(() => `[${prefix(\"data\")}]`);\r\ndirective(\"data\", skipDuringClone((el, { expression }, { cleanup: cleanup2 }) => {\r\n  expression = expression === \"\" ? \"{}\" : expression;\r\n  let magicContext = {};\r\n  injectMagics(magicContext, el);\r\n  let dataProviderContext = {};\r\n  injectDataProviders(dataProviderContext, magicContext);\r\n  let data2 = evaluate(el, expression, { scope: dataProviderContext });\r\n  if (data2 === void 0 || data2 === true)\r\n    data2 = {};\r\n  injectMagics(data2, el);\r\n  let reactiveData = reactive(data2);\r\n  initInterceptors(reactiveData);\r\n  let undo = addScopeToNode(el, reactiveData);\r\n  reactiveData[\"init\"] && evaluate(el, reactiveData[\"init\"]);\r\n  cleanup2(() => {\r\n    reactiveData[\"destroy\"] && evaluate(el, reactiveData[\"destroy\"]);\r\n    undo();\r\n  });\r\n}));\r\n\r\n// packages/alpinejs/src/directives/x-show.js\r\ndirective(\"show\", (el, { modifiers, expression }, { effect: effect3 }) => {\r\n  let evaluate2 = evaluateLater(el, expression);\r\n  if (!el._x_doHide)\r\n    el._x_doHide = () => {\r\n      mutateDom(() => {\r\n        el.style.setProperty(\"display\", \"none\", modifiers.includes(\"important\") ? \"important\" : void 0);\r\n      });\r\n    };\r\n  if (!el._x_doShow)\r\n    el._x_doShow = () => {\r\n      mutateDom(() => {\r\n        if (el.style.length === 1 && el.style.display === \"none\") {\r\n          el.removeAttribute(\"style\");\r\n        } else {\r\n          el.style.removeProperty(\"display\");\r\n        }\r\n      });\r\n    };\r\n  let hide = () => {\r\n    el._x_doHide();\r\n    el._x_isShown = false;\r\n  };\r\n  let show = () => {\r\n    el._x_doShow();\r\n    el._x_isShown = true;\r\n  };\r\n  let clickAwayCompatibleShow = () => setTimeout(show);\r\n  let toggle = once(\r\n    (value) => value ? show() : hide(),\r\n    (value) => {\r\n      if (typeof el._x_toggleAndCascadeWithTransitions === \"function\") {\r\n        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);\r\n      } else {\r\n        value ? clickAwayCompatibleShow() : hide();\r\n      }\r\n    }\r\n  );\r\n  let oldValue;\r\n  let firstTime = true;\r\n  effect3(() => evaluate2((value) => {\r\n    if (!firstTime && value === oldValue)\r\n      return;\r\n    if (modifiers.includes(\"immediate\"))\r\n      value ? clickAwayCompatibleShow() : hide();\r\n    toggle(value);\r\n    oldValue = value;\r\n    firstTime = false;\r\n  }));\r\n});\r\n\r\n// packages/alpinejs/src/directives/x-for.js\r\ndirective(\"for\", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {\r\n  let iteratorNames = parseForExpression(expression);\r\n  let evaluateItems = evaluateLater(el, iteratorNames.items);\r\n  let evaluateKey = evaluateLater(\r\n    el,\r\n    // the x-bind:key expression is stored for our use instead of evaluated.\r\n    el._x_keyExpression || \"index\"\r\n  );\r\n  el._x_prevKeys = [];\r\n  el._x_lookup = {};\r\n  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));\r\n  cleanup2(() => {\r\n    Object.values(el._x_lookup).forEach((el2) => el2.remove());\r\n    delete el._x_prevKeys;\r\n    delete el._x_lookup;\r\n  });\r\n});\r\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\r\n  let isObject2 = (i) => typeof i === \"object\" && !Array.isArray(i);\r\n  let templateEl = el;\r\n  evaluateItems((items) => {\r\n    if (isNumeric3(items) && items >= 0) {\r\n      items = Array.from(Array(items).keys(), (i) => i + 1);\r\n    }\r\n    if (items === void 0)\r\n      items = [];\r\n    let lookup = el._x_lookup;\r\n    let prevKeys = el._x_prevKeys;\r\n    let scopes = [];\r\n    let keys = [];\r\n    if (isObject2(items)) {\r\n      items = Object.entries(items).map(([key, value]) => {\r\n        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);\r\n        evaluateKey((value2) => keys.push(value2), { scope: { index: key, ...scope2 } });\r\n        scopes.push(scope2);\r\n      });\r\n    } else {\r\n      for (let i = 0; i < items.length; i++) {\r\n        let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);\r\n        evaluateKey((value) => keys.push(value), { scope: { index: i, ...scope2 } });\r\n        scopes.push(scope2);\r\n      }\r\n    }\r\n    let adds = [];\r\n    let moves = [];\r\n    let removes = [];\r\n    let sames = [];\r\n    for (let i = 0; i < prevKeys.length; i++) {\r\n      let key = prevKeys[i];\r\n      if (keys.indexOf(key) === -1)\r\n        removes.push(key);\r\n    }\r\n    prevKeys = prevKeys.filter((key) => !removes.includes(key));\r\n    let lastKey = \"template\";\r\n    for (let i = 0; i < keys.length; i++) {\r\n      let key = keys[i];\r\n      let prevIndex = prevKeys.indexOf(key);\r\n      if (prevIndex === -1) {\r\n        prevKeys.splice(i, 0, key);\r\n        adds.push([lastKey, i]);\r\n      } else if (prevIndex !== i) {\r\n        let keyInSpot = prevKeys.splice(i, 1)[0];\r\n        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];\r\n        prevKeys.splice(i, 0, keyForSpot);\r\n        prevKeys.splice(prevIndex, 0, keyInSpot);\r\n        moves.push([keyInSpot, keyForSpot]);\r\n      } else {\r\n        sames.push(key);\r\n      }\r\n      lastKey = key;\r\n    }\r\n    for (let i = 0; i < removes.length; i++) {\r\n      let key = removes[i];\r\n      if (!!lookup[key]._x_effects) {\r\n        lookup[key]._x_effects.forEach(dequeueJob);\r\n      }\r\n      lookup[key].remove();\r\n      lookup[key] = null;\r\n      delete lookup[key];\r\n    }\r\n    for (let i = 0; i < moves.length; i++) {\r\n      let [keyInSpot, keyForSpot] = moves[i];\r\n      let elInSpot = lookup[keyInSpot];\r\n      let elForSpot = lookup[keyForSpot];\r\n      let marker = document.createElement(\"div\");\r\n      mutateDom(() => {\r\n        elForSpot.after(marker);\r\n        elInSpot.after(elForSpot);\r\n        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);\r\n        marker.before(elInSpot);\r\n        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);\r\n        marker.remove();\r\n      });\r\n      refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);\r\n    }\r\n    for (let i = 0; i < adds.length; i++) {\r\n      let [lastKey2, index] = adds[i];\r\n      let lastEl = lastKey2 === \"template\" ? templateEl : lookup[lastKey2];\r\n      if (lastEl._x_currentIfEl)\r\n        lastEl = lastEl._x_currentIfEl;\r\n      let scope2 = scopes[index];\r\n      let key = keys[index];\r\n      let clone2 = document.importNode(templateEl.content, true).firstElementChild;\r\n      addScopeToNode(clone2, reactive(scope2), templateEl);\r\n      mutateDom(() => {\r\n        lastEl.after(clone2);\r\n        initTree(clone2);\r\n      });\r\n      if (typeof key === \"object\") {\r\n        warn(\"x-for key cannot be an object, it must be a string or an integer\", templateEl);\r\n      }\r\n      lookup[key] = clone2;\r\n    }\r\n    for (let i = 0; i < sames.length; i++) {\r\n      refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])]);\r\n    }\r\n    templateEl._x_prevKeys = keys;\r\n  });\r\n}\r\nfunction parseForExpression(expression) {\r\n  let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\r\n  let stripParensRE = /^\\s*\\(|\\)\\s*$/g;\r\n  let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\r\n  let inMatch = expression.match(forAliasRE);\r\n  if (!inMatch)\r\n    return;\r\n  let res = {};\r\n  res.items = inMatch[2].trim();\r\n  let item = inMatch[1].replace(stripParensRE, \"\").trim();\r\n  let iteratorMatch = item.match(forIteratorRE);\r\n  if (iteratorMatch) {\r\n    res.item = item.replace(forIteratorRE, \"\").trim();\r\n    res.index = iteratorMatch[1].trim();\r\n    if (iteratorMatch[2]) {\r\n      res.collection = iteratorMatch[2].trim();\r\n    }\r\n  } else {\r\n    res.item = item;\r\n  }\r\n  return res;\r\n}\r\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\r\n  let scopeVariables = {};\r\n  if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\r\n    let names = iteratorNames.item.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\").map((i) => i.trim());\r\n    names.forEach((name, i) => {\r\n      scopeVariables[name] = item[i];\r\n    });\r\n  } else if (/^\\{.*\\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === \"object\") {\r\n    let names = iteratorNames.item.replace(\"{\", \"\").replace(\"}\", \"\").split(\",\").map((i) => i.trim());\r\n    names.forEach((name) => {\r\n      scopeVariables[name] = item[name];\r\n    });\r\n  } else {\r\n    scopeVariables[iteratorNames.item] = item;\r\n  }\r\n  if (iteratorNames.index)\r\n    scopeVariables[iteratorNames.index] = index;\r\n  if (iteratorNames.collection)\r\n    scopeVariables[iteratorNames.collection] = items;\r\n  return scopeVariables;\r\n}\r\nfunction isNumeric3(subject) {\r\n  return !Array.isArray(subject) && !isNaN(subject);\r\n}\r\n\r\n// packages/alpinejs/src/directives/x-ref.js\r\nfunction handler2() {\r\n}\r\nhandler2.inline = (el, { expression }, { cleanup: cleanup2 }) => {\r\n  let root = closestRoot(el);\r\n  if (!root._x_refs)\r\n    root._x_refs = {};\r\n  root._x_refs[expression] = el;\r\n  cleanup2(() => delete root._x_refs[expression]);\r\n};\r\ndirective(\"ref\", handler2);\r\n\r\n// packages/alpinejs/src/directives/x-if.js\r\ndirective(\"if\", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {\r\n  let evaluate2 = evaluateLater(el, expression);\r\n  let show = () => {\r\n    if (el._x_currentIfEl)\r\n      return el._x_currentIfEl;\r\n    let clone2 = el.content.cloneNode(true).firstElementChild;\r\n    addScopeToNode(clone2, {}, el);\r\n    mutateDom(() => {\r\n      el.after(clone2);\r\n      initTree(clone2);\r\n    });\r\n    el._x_currentIfEl = clone2;\r\n    el._x_undoIf = () => {\r\n      walk(clone2, (node) => {\r\n        if (!!node._x_effects) {\r\n          node._x_effects.forEach(dequeueJob);\r\n        }\r\n      });\r\n      clone2.remove();\r\n      delete el._x_currentIfEl;\r\n    };\r\n    return clone2;\r\n  };\r\n  let hide = () => {\r\n    if (!el._x_undoIf)\r\n      return;\r\n    el._x_undoIf();\r\n    delete el._x_undoIf;\r\n  };\r\n  effect3(() => evaluate2((value) => {\r\n    value ? show() : hide();\r\n  }));\r\n  cleanup2(() => el._x_undoIf && el._x_undoIf());\r\n});\r\n\r\n// packages/alpinejs/src/directives/x-id.js\r\ndirective(\"id\", (el, { expression }, { evaluate: evaluate2 }) => {\r\n  let names = evaluate2(expression);\r\n  names.forEach((name) => setIdRoot(el, name));\r\n});\r\n\r\n// packages/alpinejs/src/directives/x-on.js\r\nmapAttributes(startingWith(\"@\", into(prefix(\"on:\"))));\r\ndirective(\"on\", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {\r\n  let evaluate2 = expression ? evaluateLater(el, expression) : () => {\r\n  };\r\n  if (el.tagName.toLowerCase() === \"template\") {\r\n    if (!el._x_forwardEvents)\r\n      el._x_forwardEvents = [];\r\n    if (!el._x_forwardEvents.includes(value))\r\n      el._x_forwardEvents.push(value);\r\n  }\r\n  let removeListener = on(el, value, modifiers, (e) => {\r\n    evaluate2(() => {\r\n    }, { scope: { \"$event\": e }, params: [e] });\r\n  });\r\n  cleanup2(() => removeListener());\r\n}));\r\n\r\n// packages/alpinejs/src/directives/index.js\r\nwarnMissingPluginDirective(\"Collapse\", \"collapse\", \"collapse\");\r\nwarnMissingPluginDirective(\"Intersect\", \"intersect\", \"intersect\");\r\nwarnMissingPluginDirective(\"Focus\", \"trap\", \"focus\");\r\nwarnMissingPluginDirective(\"Mask\", \"mask\", \"mask\");\r\nfunction warnMissingPluginDirective(name, directiveName2, slug) {\r\n  directive(directiveName2, (el) => warn(`You can't use [x-${directiveName2}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\r\n}\r\n\r\n// packages/alpinejs/src/index.js\r\nalpine_default.setEvaluator(normalEvaluator);\r\nalpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });\r\nvar src_default = alpine_default;\r\n\r\n// packages/alpinejs/builds/module.js\r\nvar module_default = src_default;\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9tb2R1bGUuZXNtLmpzP2RkNTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHLEVBQUU7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRFQUE0RTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFDQUFxQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwrQkFBK0IsR0FBRyxzQkFBc0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EsY0FBYywrREFBK0Q7QUFDN0UsY0FBYywrREFBK0Q7QUFDN0U7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtREFBbUQsa0NBQWtDO0FBQ3JGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZCQUE2QixLQUFLO0FBQ3hFLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUssaUVBQWlFLGlDQUFpQztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBSTtBQUNaLHFEQUFxRCxlQUFlO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaURBQWlEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLLEdBQUcsR0FBRyxHQUFHLElBQUksT0FBTyxLQUFLLEdBQUcsR0FBRztBQUN0RCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYyxrQ0FBa0MsS0FBSyw4Q0FBOEMsS0FBSztBQUMzSjs7QUFFQTtBQUNBLG1CQUFtQiwrQkFBK0IsR0FBRywrQkFBK0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGFBQWEsR0FBRyxvRUFBb0U7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxHQUFHLEdBQUcsU0FBUyx1QkFBdUIsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QixHQUFHLG9CQUFvQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksR0FBRyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsYUFBYSxHQUFHLGtCQUFrQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSx5QkFBeUIsd0JBQXdCLEdBQUcscUNBQXFDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0QsR0FBRztBQUNILGdEQUFnRCxhQUFhO0FBQzdELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZUFBZTtBQUN6Qyx3Q0FBd0MsYUFBYSxHQUFHLHNCQUFzQjtBQUM5RTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLGlDQUFpQztBQUNqQyxDQUFDOztBQUVEO0FBQ0Esd0JBQXdCLGFBQWEsR0FBRyxpREFBaUQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQSx3QkFBd0IsYUFBYSxHQUFHLGlEQUFpRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0Esd0JBQXdCLHlDQUF5QyxHQUFHLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZUFBZTtBQUN6Qyx3Q0FBd0MsYUFBYSxHQUFHLG9CQUFvQjtBQUM1RSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQSx3QkFBd0Isd0JBQXdCLEdBQUcsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBLHVCQUF1QixhQUFhLEdBQUcscUNBQXFDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVMsd0JBQXdCLEVBQUU7QUFDdkY7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQSxrREFBa0QsU0FBUyxzQkFBc0IsRUFBRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLGNBQWMsSUFBSTtBQUNyQiw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWEsR0FBRyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsYUFBYSxHQUFHLHFDQUFxQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0Esc0JBQXNCLGFBQWEsR0FBRyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHNDQUFzQywrQkFBK0IsR0FBRyxvQkFBb0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsU0FBUyxjQUFjLGVBQWU7QUFDOUMsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZSxrQ0FBa0MsS0FBSyw4Q0FBOEMsS0FBSztBQUN0Szs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLGtFQUFrRTtBQUN0Rzs7QUFFQTtBQUNBO0FBR0UiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9tb2R1bGUuZXNtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3NjaGVkdWxlci5qc1xyXG52YXIgZmx1c2hQZW5kaW5nID0gZmFsc2U7XHJcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xyXG52YXIgcXVldWUgPSBbXTtcclxudmFyIGxhc3RGbHVzaGVkSW5kZXggPSAtMTtcclxuZnVuY3Rpb24gc2NoZWR1bGVyKGNhbGxiYWNrKSB7XHJcbiAgcXVldWVKb2IoY2FsbGJhY2spO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xyXG4gIGlmICghcXVldWUuaW5jbHVkZXMoam9iKSlcclxuICAgIHF1ZXVlLnB1c2goam9iKTtcclxuICBxdWV1ZUZsdXNoKCk7XHJcbn1cclxuZnVuY3Rpb24gZGVxdWV1ZUpvYihqb2IpIHtcclxuICBsZXQgaW5kZXggPSBxdWV1ZS5pbmRleE9mKGpvYik7XHJcbiAgaWYgKGluZGV4ICE9PSAtMSAmJiBpbmRleCA+IGxhc3RGbHVzaGVkSW5kZXgpXHJcbiAgICBxdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XHJcbiAgaWYgKCFmbHVzaGluZyAmJiAhZmx1c2hQZW5kaW5nKSB7XHJcbiAgICBmbHVzaFBlbmRpbmcgPSB0cnVlO1xyXG4gICAgcXVldWVNaWNyb3Rhc2soZmx1c2hKb2JzKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hKb2JzKCkge1xyXG4gIGZsdXNoUGVuZGluZyA9IGZhbHNlO1xyXG4gIGZsdXNoaW5nID0gdHJ1ZTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBxdWV1ZVtpXSgpO1xyXG4gICAgbGFzdEZsdXNoZWRJbmRleCA9IGk7XHJcbiAgfVxyXG4gIHF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgbGFzdEZsdXNoZWRJbmRleCA9IC0xO1xyXG4gIGZsdXNoaW5nID0gZmFsc2U7XHJcbn1cclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9yZWFjdGl2aXR5LmpzXHJcbnZhciByZWFjdGl2ZTtcclxudmFyIGVmZmVjdDtcclxudmFyIHJlbGVhc2U7XHJcbnZhciByYXc7XHJcbnZhciBzaG91bGRTY2hlZHVsZSA9IHRydWU7XHJcbmZ1bmN0aW9uIGRpc2FibGVFZmZlY3RTY2hlZHVsaW5nKGNhbGxiYWNrKSB7XHJcbiAgc2hvdWxkU2NoZWR1bGUgPSBmYWxzZTtcclxuICBjYWxsYmFjaygpO1xyXG4gIHNob3VsZFNjaGVkdWxlID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBzZXRSZWFjdGl2aXR5RW5naW5lKGVuZ2luZSkge1xyXG4gIHJlYWN0aXZlID0gZW5naW5lLnJlYWN0aXZlO1xyXG4gIHJlbGVhc2UgPSBlbmdpbmUucmVsZWFzZTtcclxuICBlZmZlY3QgPSAoY2FsbGJhY2spID0+IGVuZ2luZS5lZmZlY3QoY2FsbGJhY2ssIHsgc2NoZWR1bGVyOiAodGFzaykgPT4ge1xyXG4gICAgaWYgKHNob3VsZFNjaGVkdWxlKSB7XHJcbiAgICAgIHNjaGVkdWxlcih0YXNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRhc2soKTtcclxuICAgIH1cclxuICB9IH0pO1xyXG4gIHJhdyA9IGVuZ2luZS5yYXc7XHJcbn1cclxuZnVuY3Rpb24gb3ZlcnJpZGVFZmZlY3Qob3ZlcnJpZGUpIHtcclxuICBlZmZlY3QgPSBvdmVycmlkZTtcclxufVxyXG5mdW5jdGlvbiBlbGVtZW50Qm91bmRFZmZlY3QoZWwpIHtcclxuICBsZXQgY2xlYW51cDIgPSAoKSA9PiB7XHJcbiAgfTtcclxuICBsZXQgd3JhcHBlZEVmZmVjdCA9IChjYWxsYmFjaykgPT4ge1xyXG4gICAgbGV0IGVmZmVjdFJlZmVyZW5jZSA9IGVmZmVjdChjYWxsYmFjayk7XHJcbiAgICBpZiAoIWVsLl94X2VmZmVjdHMpIHtcclxuICAgICAgZWwuX3hfZWZmZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XHJcbiAgICAgIGVsLl94X3J1bkVmZmVjdHMgPSAoKSA9PiB7XHJcbiAgICAgICAgZWwuX3hfZWZmZWN0cy5mb3JFYWNoKChpKSA9PiBpKCkpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWwuX3hfZWZmZWN0cy5hZGQoZWZmZWN0UmVmZXJlbmNlKTtcclxuICAgIGNsZWFudXAyID0gKCkgPT4ge1xyXG4gICAgICBpZiAoZWZmZWN0UmVmZXJlbmNlID09PSB2b2lkIDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBlbC5feF9lZmZlY3RzLmRlbGV0ZShlZmZlY3RSZWZlcmVuY2UpO1xyXG4gICAgICByZWxlYXNlKGVmZmVjdFJlZmVyZW5jZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGVmZmVjdFJlZmVyZW5jZTtcclxuICB9O1xyXG4gIHJldHVybiBbd3JhcHBlZEVmZmVjdCwgKCkgPT4ge1xyXG4gICAgY2xlYW51cDIoKTtcclxuICB9XTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL211dGF0aW9uLmpzXHJcbnZhciBvbkF0dHJpYnV0ZUFkZGVkcyA9IFtdO1xyXG52YXIgb25FbFJlbW92ZWRzID0gW107XHJcbnZhciBvbkVsQWRkZWRzID0gW107XHJcbmZ1bmN0aW9uIG9uRWxBZGRlZChjYWxsYmFjaykge1xyXG4gIG9uRWxBZGRlZHMucHVzaChjYWxsYmFjayk7XHJcbn1cclxuZnVuY3Rpb24gb25FbFJlbW92ZWQoZWwsIGNhbGxiYWNrKSB7XHJcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICBpZiAoIWVsLl94X2NsZWFudXBzKVxyXG4gICAgICBlbC5feF9jbGVhbnVwcyA9IFtdO1xyXG4gICAgZWwuX3hfY2xlYW51cHMucHVzaChjYWxsYmFjayk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNhbGxiYWNrID0gZWw7XHJcbiAgICBvbkVsUmVtb3ZlZHMucHVzaChjYWxsYmFjayk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIG9uQXR0cmlidXRlc0FkZGVkKGNhbGxiYWNrKSB7XHJcbiAgb25BdHRyaWJ1dGVBZGRlZHMucHVzaChjYWxsYmFjayk7XHJcbn1cclxuZnVuY3Rpb24gb25BdHRyaWJ1dGVSZW1vdmVkKGVsLCBuYW1lLCBjYWxsYmFjaykge1xyXG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpXHJcbiAgICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwcyA9IHt9O1xyXG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHNbbmFtZV0pXHJcbiAgICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXSA9IFtdO1xyXG4gIGVsLl94X2F0dHJpYnV0ZUNsZWFudXBzW25hbWVdLnB1c2goY2FsbGJhY2spO1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFudXBBdHRyaWJ1dGVzKGVsLCBuYW1lcykge1xyXG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpXHJcbiAgICByZXR1cm47XHJcbiAgT2JqZWN0LmVudHJpZXMoZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcclxuICAgIGlmIChuYW1lcyA9PT0gdm9pZCAwIHx8IG5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgIHZhbHVlLmZvckVhY2goKGkpID0+IGkoKSk7XHJcbiAgICAgIGRlbGV0ZSBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG52YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvbk11dGF0ZSk7XHJcbnZhciBjdXJyZW50bHlPYnNlcnZpbmcgPSBmYWxzZTtcclxuZnVuY3Rpb24gc3RhcnRPYnNlcnZpbmdNdXRhdGlvbnMoKSB7XHJcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwgeyBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlIH0pO1xyXG4gIGN1cnJlbnRseU9ic2VydmluZyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gc3RvcE9ic2VydmluZ011dGF0aW9ucygpIHtcclxuICBmbHVzaE9ic2VydmVyKCk7XHJcbiAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gIGN1cnJlbnRseU9ic2VydmluZyA9IGZhbHNlO1xyXG59XHJcbnZhciByZWNvcmRRdWV1ZSA9IFtdO1xyXG52YXIgd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSA9IGZhbHNlO1xyXG5mdW5jdGlvbiBmbHVzaE9ic2VydmVyKCkge1xyXG4gIHJlY29yZFF1ZXVlID0gcmVjb3JkUXVldWUuY29uY2F0KG9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xyXG4gIGlmIChyZWNvcmRRdWV1ZS5sZW5ndGggJiYgIXdpbGxQcm9jZXNzUmVjb3JkUXVldWUpIHtcclxuICAgIHdpbGxQcm9jZXNzUmVjb3JkUXVldWUgPSB0cnVlO1xyXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgICBwcm9jZXNzUmVjb3JkUXVldWUoKTtcclxuICAgICAgd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSA9IGZhbHNlO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRRdWV1ZSgpIHtcclxuICBvbk11dGF0ZShyZWNvcmRRdWV1ZSk7XHJcbiAgcmVjb3JkUXVldWUubGVuZ3RoID0gMDtcclxufVxyXG5mdW5jdGlvbiBtdXRhdGVEb20oY2FsbGJhY2spIHtcclxuICBpZiAoIWN1cnJlbnRseU9ic2VydmluZylcclxuICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gIHN0b3BPYnNlcnZpbmdNdXRhdGlvbnMoKTtcclxuICBsZXQgcmVzdWx0ID0gY2FsbGJhY2soKTtcclxuICBzdGFydE9ic2VydmluZ011dGF0aW9ucygpO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxudmFyIGlzQ29sbGVjdGluZyA9IGZhbHNlO1xyXG52YXIgZGVmZXJyZWRNdXRhdGlvbnMgPSBbXTtcclxuZnVuY3Rpb24gZGVmZXJNdXRhdGlvbnMoKSB7XHJcbiAgaXNDb2xsZWN0aW5nID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBmbHVzaEFuZFN0b3BEZWZlcnJpbmdNdXRhdGlvbnMoKSB7XHJcbiAgaXNDb2xsZWN0aW5nID0gZmFsc2U7XHJcbiAgb25NdXRhdGUoZGVmZXJyZWRNdXRhdGlvbnMpO1xyXG4gIGRlZmVycmVkTXV0YXRpb25zID0gW107XHJcbn1cclxuZnVuY3Rpb24gb25NdXRhdGUobXV0YXRpb25zKSB7XHJcbiAgaWYgKGlzQ29sbGVjdGluZykge1xyXG4gICAgZGVmZXJyZWRNdXRhdGlvbnMgPSBkZWZlcnJlZE11dGF0aW9ucy5jb25jYXQobXV0YXRpb25zKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgbGV0IGFkZGVkTm9kZXMgPSBbXTtcclxuICBsZXQgcmVtb3ZlZE5vZGVzID0gW107XHJcbiAgbGV0IGFkZGVkQXR0cmlidXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbiAgbGV0IHJlbW92ZWRBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKG11dGF0aW9uc1tpXS50YXJnZXQuX3hfaWdub3JlTXV0YXRpb25PYnNlcnZlcilcclxuICAgICAgY29udGludWU7XHJcbiAgICBpZiAobXV0YXRpb25zW2ldLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcclxuICAgICAgbXV0YXRpb25zW2ldLmFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBhZGRlZE5vZGVzLnB1c2gobm9kZSkpO1xyXG4gICAgICBtdXRhdGlvbnNbaV0ucmVtb3ZlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDEgJiYgcmVtb3ZlZE5vZGVzLnB1c2gobm9kZSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKG11dGF0aW9uc1tpXS50eXBlID09PSBcImF0dHJpYnV0ZXNcIikge1xyXG4gICAgICBsZXQgZWwgPSBtdXRhdGlvbnNbaV0udGFyZ2V0O1xyXG4gICAgICBsZXQgbmFtZSA9IG11dGF0aW9uc1tpXS5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICBsZXQgb2xkVmFsdWUgPSBtdXRhdGlvbnNbaV0ub2xkVmFsdWU7XHJcbiAgICAgIGxldCBhZGQyID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghYWRkZWRBdHRyaWJ1dGVzLmhhcyhlbCkpXHJcbiAgICAgICAgICBhZGRlZEF0dHJpYnV0ZXMuc2V0KGVsLCBbXSk7XHJcbiAgICAgICAgYWRkZWRBdHRyaWJ1dGVzLmdldChlbCkucHVzaCh7IG5hbWUsIHZhbHVlOiBlbC5nZXRBdHRyaWJ1dGUobmFtZSkgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGxldCByZW1vdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFyZW1vdmVkQXR0cmlidXRlcy5oYXMoZWwpKVxyXG4gICAgICAgICAgcmVtb3ZlZEF0dHJpYnV0ZXMuc2V0KGVsLCBbXSk7XHJcbiAgICAgICAgcmVtb3ZlZEF0dHJpYnV0ZXMuZ2V0KGVsKS5wdXNoKG5hbWUpO1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKG5hbWUpICYmIG9sZFZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgYWRkMigpO1xyXG4gICAgICB9IGVsc2UgaWYgKGVsLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xyXG4gICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgIGFkZDIoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZW1vdmVkQXR0cmlidXRlcy5mb3JFYWNoKChhdHRycywgZWwpID0+IHtcclxuICAgIGNsZWFudXBBdHRyaWJ1dGVzKGVsLCBhdHRycyk7XHJcbiAgfSk7XHJcbiAgYWRkZWRBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJzLCBlbCkgPT4ge1xyXG4gICAgb25BdHRyaWJ1dGVBZGRlZHMuZm9yRWFjaCgoaSkgPT4gaShlbCwgYXR0cnMpKTtcclxuICB9KTtcclxuICBmb3IgKGxldCBub2RlIG9mIHJlbW92ZWROb2Rlcykge1xyXG4gICAgaWYgKGFkZGVkTm9kZXMuaW5jbHVkZXMobm9kZSkpXHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgb25FbFJlbW92ZWRzLmZvckVhY2goKGkpID0+IGkobm9kZSkpO1xyXG4gICAgaWYgKG5vZGUuX3hfY2xlYW51cHMpIHtcclxuICAgICAgd2hpbGUgKG5vZGUuX3hfY2xlYW51cHMubGVuZ3RoKVxyXG4gICAgICAgIG5vZGUuX3hfY2xlYW51cHMucG9wKCkoKTtcclxuICAgIH1cclxuICB9XHJcbiAgYWRkZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICBub2RlLl94X2lnbm9yZVNlbGYgPSB0cnVlO1xyXG4gICAgbm9kZS5feF9pZ25vcmUgPSB0cnVlO1xyXG4gIH0pO1xyXG4gIGZvciAobGV0IG5vZGUgb2YgYWRkZWROb2Rlcykge1xyXG4gICAgaWYgKHJlbW92ZWROb2Rlcy5pbmNsdWRlcyhub2RlKSlcclxuICAgICAgY29udGludWU7XHJcbiAgICBpZiAoIW5vZGUuaXNDb25uZWN0ZWQpXHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgZGVsZXRlIG5vZGUuX3hfaWdub3JlU2VsZjtcclxuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZTtcclxuICAgIG9uRWxBZGRlZHMuZm9yRWFjaCgoaSkgPT4gaShub2RlKSk7XHJcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XHJcbiAgICBub2RlLl94X2lnbm9yZVNlbGYgPSB0cnVlO1xyXG4gIH1cclxuICBhZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZVNlbGY7XHJcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmU7XHJcbiAgfSk7XHJcbiAgYWRkZWROb2RlcyA9IG51bGw7XHJcbiAgcmVtb3ZlZE5vZGVzID0gbnVsbDtcclxuICBhZGRlZEF0dHJpYnV0ZXMgPSBudWxsO1xyXG4gIHJlbW92ZWRBdHRyaWJ1dGVzID0gbnVsbDtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3Njb3BlLmpzXHJcbmZ1bmN0aW9uIHNjb3BlKG5vZGUpIHtcclxuICByZXR1cm4gbWVyZ2VQcm94aWVzKGNsb3Nlc3REYXRhU3RhY2sobm9kZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFNjb3BlVG9Ob2RlKG5vZGUsIGRhdGEyLCByZWZlcmVuY2VOb2RlKSB7XHJcbiAgbm9kZS5feF9kYXRhU3RhY2sgPSBbZGF0YTIsIC4uLmNsb3Nlc3REYXRhU3RhY2socmVmZXJlbmNlTm9kZSB8fCBub2RlKV07XHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIG5vZGUuX3hfZGF0YVN0YWNrID0gbm9kZS5feF9kYXRhU3RhY2suZmlsdGVyKChpKSA9PiBpICE9PSBkYXRhMik7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiByZWZyZXNoU2NvcGUoZWxlbWVudCwgc2NvcGUyKSB7XHJcbiAgbGV0IGV4aXN0aW5nU2NvcGUgPSBlbGVtZW50Ll94X2RhdGFTdGFja1swXTtcclxuICBPYmplY3QuZW50cmllcyhzY29wZTIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgZXhpc3RpbmdTY29wZVtrZXldID0gdmFsdWU7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VzdERhdGFTdGFjayhub2RlKSB7XHJcbiAgaWYgKG5vZGUuX3hfZGF0YVN0YWNrKVxyXG4gICAgcmV0dXJuIG5vZGUuX3hfZGF0YVN0YWNrO1xyXG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gXCJmdW5jdGlvblwiICYmIG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XHJcbiAgICByZXR1cm4gY2xvc2VzdERhdGFTdGFjayhub2RlLmhvc3QpO1xyXG4gIH1cclxuICBpZiAoIW5vZGUucGFyZW50Tm9kZSkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICByZXR1cm4gY2xvc2VzdERhdGFTdGFjayhub2RlLnBhcmVudE5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlUHJveGllcyhvYmplY3RzKSB7XHJcbiAgbGV0IHRoaXNQcm94eSA9IG5ldyBQcm94eSh7fSwge1xyXG4gICAgb3duS2V5czogKCkgPT4ge1xyXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KG9iamVjdHMuZmxhdE1hcCgoaSkgPT4gT2JqZWN0LmtleXMoaSkpKSk7XHJcbiAgICB9LFxyXG4gICAgaGFzOiAodGFyZ2V0LCBuYW1lKSA9PiB7XHJcbiAgICAgIHJldHVybiBvYmplY3RzLnNvbWUoKG9iaikgPT4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpKTtcclxuICAgIH0sXHJcbiAgICBnZXQ6ICh0YXJnZXQsIG5hbWUpID0+IHtcclxuICAgICAgcmV0dXJuIChvYmplY3RzLmZpbmQoKG9iaikgPT4ge1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgIGxldCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG5hbWUpO1xyXG4gICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICYmIGRlc2NyaXB0b3IuZ2V0Ll94X2FscmVhZHlCb3VuZCB8fCBkZXNjcmlwdG9yLnNldCAmJiBkZXNjcmlwdG9yLnNldC5feF9hbHJlYWR5Qm91bmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoKGRlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3Iuc2V0KSAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcclxuICAgICAgICAgICAgbGV0IGdldHRlciA9IGRlc2NyaXB0b3IuZ2V0O1xyXG4gICAgICAgICAgICBsZXQgc2V0dGVyID0gZGVzY3JpcHRvci5zZXQ7XHJcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGRlc2NyaXB0b3I7XHJcbiAgICAgICAgICAgIGdldHRlciA9IGdldHRlciAmJiBnZXR0ZXIuYmluZCh0aGlzUHJveHkpO1xyXG4gICAgICAgICAgICBzZXR0ZXIgPSBzZXR0ZXIgJiYgc2V0dGVyLmJpbmQodGhpc1Byb3h5KTtcclxuICAgICAgICAgICAgaWYgKGdldHRlcilcclxuICAgICAgICAgICAgICBnZXR0ZXIuX3hfYWxyZWFkeUJvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHNldHRlcilcclxuICAgICAgICAgICAgICBzZXR0ZXIuX3hfYWxyZWFkeUJvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xyXG4gICAgICAgICAgICAgIC4uLnByb3BlcnR5LFxyXG4gICAgICAgICAgICAgIGdldDogZ2V0dGVyLFxyXG4gICAgICAgICAgICAgIHNldDogc2V0dGVyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSkgfHwge30pW25hbWVdO1xyXG4gICAgfSxcclxuICAgIHNldDogKHRhcmdldCwgbmFtZSwgdmFsdWUpID0+IHtcclxuICAgICAgbGV0IGNsb3Nlc3RPYmplY3RXaXRoS2V5ID0gb2JqZWN0cy5maW5kKChvYmopID0+IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSk7XHJcbiAgICAgIGlmIChjbG9zZXN0T2JqZWN0V2l0aEtleSkge1xyXG4gICAgICAgIGNsb3Nlc3RPYmplY3RXaXRoS2V5W25hbWVdID0gdmFsdWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb2JqZWN0c1tvYmplY3RzLmxlbmd0aCAtIDFdW25hbWVdID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHRoaXNQcm94eTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2ludGVyY2VwdG9yLmpzXHJcbmZ1bmN0aW9uIGluaXRJbnRlcmNlcHRvcnMoZGF0YTIpIHtcclxuICBsZXQgaXNPYmplY3QyID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbCAhPT0gbnVsbDtcclxuICBsZXQgcmVjdXJzZSA9IChvYmosIGJhc2VQYXRoID0gXCJcIikgPT4ge1xyXG4gICAgT2JqZWN0LmVudHJpZXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSkuZm9yRWFjaCgoW2tleSwgeyB2YWx1ZSwgZW51bWVyYWJsZSB9XSkgPT4ge1xyXG4gICAgICBpZiAoZW51bWVyYWJsZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IHZvaWQgMClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBwYXRoID0gYmFzZVBhdGggPT09IFwiXCIgPyBrZXkgOiBgJHtiYXNlUGF0aH0uJHtrZXl9YDtcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5feF9pbnRlcmNlcHRvcikge1xyXG4gICAgICAgIG9ialtrZXldID0gdmFsdWUuaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaXNPYmplY3QyKHZhbHVlKSAmJiB2YWx1ZSAhPT0gb2JqICYmICEodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xyXG4gICAgICAgICAgcmVjdXJzZSh2YWx1ZSwgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIHJldHVybiByZWN1cnNlKGRhdGEyKTtcclxufVxyXG5mdW5jdGlvbiBpbnRlcmNlcHRvcihjYWxsYmFjaywgbXV0YXRlT2JqID0gKCkgPT4ge1xyXG59KSB7XHJcbiAgbGV0IG9iaiA9IHtcclxuICAgIGluaXRpYWxWYWx1ZTogdm9pZCAwLFxyXG4gICAgX3hfaW50ZXJjZXB0b3I6IHRydWUsXHJcbiAgICBpbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuaW5pdGlhbFZhbHVlLCAoKSA9PiBnZXQoZGF0YTIsIHBhdGgpLCAodmFsdWUpID0+IHNldChkYXRhMiwgcGF0aCwgdmFsdWUpLCBwYXRoLCBrZXkpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgbXV0YXRlT2JqKG9iaik7XHJcbiAgcmV0dXJuIChpbml0aWFsVmFsdWUpID0+IHtcclxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFZhbHVlID09PSBcIm9iamVjdFwiICYmIGluaXRpYWxWYWx1ZSAhPT0gbnVsbCAmJiBpbml0aWFsVmFsdWUuX3hfaW50ZXJjZXB0b3IpIHtcclxuICAgICAgbGV0IGluaXRpYWxpemUgPSBvYmouaW5pdGlhbGl6ZS5iaW5kKG9iaik7XHJcbiAgICAgIG9iai5pbml0aWFsaXplID0gKGRhdGEyLCBwYXRoLCBrZXkpID0+IHtcclxuICAgICAgICBsZXQgaW5uZXJWYWx1ZSA9IGluaXRpYWxWYWx1ZS5pbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xyXG4gICAgICAgIG9iai5pbml0aWFsVmFsdWUgPSBpbm5lclZhbHVlO1xyXG4gICAgICAgIHJldHVybiBpbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb2JqLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXQob2JqLCBwYXRoKSB7XHJcbiAgcmV0dXJuIHBhdGguc3BsaXQoXCIuXCIpLnJlZHVjZSgoY2FycnksIHNlZ21lbnQpID0+IGNhcnJ5W3NlZ21lbnRdLCBvYmopO1xyXG59XHJcbmZ1bmN0aW9uIHNldChvYmosIHBhdGgsIHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiKVxyXG4gICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xyXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMSlcclxuICAgIG9ialtwYXRoWzBdXSA9IHZhbHVlO1xyXG4gIGVsc2UgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgZWxzZSB7XHJcbiAgICBpZiAob2JqW3BhdGhbMF1dKVxyXG4gICAgICByZXR1cm4gc2V0KG9ialtwYXRoWzBdXSwgcGF0aC5zbGljZSgxKSwgdmFsdWUpO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIG9ialtwYXRoWzBdXSA9IHt9O1xyXG4gICAgICByZXR1cm4gc2V0KG9ialtwYXRoWzBdXSwgcGF0aC5zbGljZSgxKSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy5qc1xyXG52YXIgbWFnaWNzID0ge307XHJcbmZ1bmN0aW9uIG1hZ2ljKG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgbWFnaWNzW25hbWVdID0gY2FsbGJhY2s7XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0TWFnaWNzKG9iaiwgZWwpIHtcclxuICBPYmplY3QuZW50cmllcyhtYWdpY3MpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGAkJHtuYW1lfWAsIHtcclxuICAgICAgZ2V0KCkge1xyXG4gICAgICAgIGxldCBbdXRpbGl0aWVzLCBjbGVhbnVwMl0gPSBnZXRFbGVtZW50Qm91bmRVdGlsaXRpZXMoZWwpO1xyXG4gICAgICAgIHV0aWxpdGllcyA9IHsgaW50ZXJjZXB0b3IsIC4uLnV0aWxpdGllcyB9O1xyXG4gICAgICAgIG9uRWxSZW1vdmVkKGVsLCBjbGVhbnVwMik7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVsLCB1dGlsaXRpZXMpO1xyXG4gICAgICB9LFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2Vycm9yLmpzXHJcbmZ1bmN0aW9uIHRyeUNhdGNoKGVsLCBleHByZXNzaW9uLCBjYWxsYmFjaywgLi4uYXJncykge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gY2FsbGJhY2soLi4uYXJncyk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaGFuZGxlRXJyb3IoZSwgZWwsIGV4cHJlc3Npb24pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uID0gdm9pZCAwKSB7XHJcbiAgT2JqZWN0LmFzc2lnbihlcnJvcjIsIHsgZWwsIGV4cHJlc3Npb24gfSk7XHJcbiAgY29uc29sZS53YXJuKGBBbHBpbmUgRXhwcmVzc2lvbiBFcnJvcjogJHtlcnJvcjIubWVzc2FnZX1cclxuXHJcbiR7ZXhwcmVzc2lvbiA/ICdFeHByZXNzaW9uOiBcIicgKyBleHByZXNzaW9uICsgJ1wiXFxuXFxuJyA6IFwiXCJ9YCwgZWwpO1xyXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgdGhyb3cgZXJyb3IyO1xyXG4gIH0sIDApO1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZXZhbHVhdG9yLmpzXHJcbnZhciBzaG91bGRBdXRvRXZhbHVhdGVGdW5jdGlvbnMgPSB0cnVlO1xyXG5mdW5jdGlvbiBkb250QXV0b0V2YWx1YXRlRnVuY3Rpb25zKGNhbGxiYWNrKSB7XHJcbiAgbGV0IGNhY2hlID0gc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zO1xyXG4gIHNob3VsZEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucyA9IGZhbHNlO1xyXG4gIGNhbGxiYWNrKCk7XHJcbiAgc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zID0gY2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gZXZhbHVhdGUoZWwsIGV4cHJlc3Npb24sIGV4dHJhcyA9IHt9KSB7XHJcbiAgbGV0IHJlc3VsdDtcclxuICBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKSgodmFsdWUpID0+IHJlc3VsdCA9IHZhbHVlLCBleHRyYXMpO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZXZhbHVhdGVMYXRlciguLi5hcmdzKSB7XHJcbiAgcmV0dXJuIHRoZUV2YWx1YXRvckZ1bmN0aW9uKC4uLmFyZ3MpO1xyXG59XHJcbnZhciB0aGVFdmFsdWF0b3JGdW5jdGlvbiA9IG5vcm1hbEV2YWx1YXRvcjtcclxuZnVuY3Rpb24gc2V0RXZhbHVhdG9yKG5ld0V2YWx1YXRvcikge1xyXG4gIHRoZUV2YWx1YXRvckZ1bmN0aW9uID0gbmV3RXZhbHVhdG9yO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbEV2YWx1YXRvcihlbCwgZXhwcmVzc2lvbikge1xyXG4gIGxldCBvdmVycmlkZGVuTWFnaWNzID0ge307XHJcbiAgaW5qZWN0TWFnaWNzKG92ZXJyaWRkZW5NYWdpY3MsIGVsKTtcclxuICBsZXQgZGF0YVN0YWNrID0gW292ZXJyaWRkZW5NYWdpY3MsIC4uLmNsb3Nlc3REYXRhU3RhY2soZWwpXTtcclxuICBsZXQgZXZhbHVhdG9yID0gdHlwZW9mIGV4cHJlc3Npb24gPT09IFwiZnVuY3Rpb25cIiA/IGdlbmVyYXRlRXZhbHVhdG9yRnJvbUZ1bmN0aW9uKGRhdGFTdGFjaywgZXhwcmVzc2lvbikgOiBnZW5lcmF0ZUV2YWx1YXRvckZyb21TdHJpbmcoZGF0YVN0YWNrLCBleHByZXNzaW9uLCBlbCk7XHJcbiAgcmV0dXJuIHRyeUNhdGNoLmJpbmQobnVsbCwgZWwsIGV4cHJlc3Npb24sIGV2YWx1YXRvcik7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tRnVuY3Rpb24oZGF0YVN0YWNrLCBmdW5jKSB7XHJcbiAgcmV0dXJuIChyZWNlaXZlciA9ICgpID0+IHtcclxuICB9LCB7IHNjb3BlOiBzY29wZTIgPSB7fSwgcGFyYW1zID0gW10gfSA9IHt9KSA9PiB7XHJcbiAgICBsZXQgcmVzdWx0ID0gZnVuYy5hcHBseShtZXJnZVByb3hpZXMoW3Njb3BlMiwgLi4uZGF0YVN0YWNrXSksIHBhcmFtcyk7XHJcbiAgICBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCByZXN1bHQpO1xyXG4gIH07XHJcbn1cclxudmFyIGV2YWx1YXRvck1lbW8gPSB7fTtcclxuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbkZyb21TdHJpbmcoZXhwcmVzc2lvbiwgZWwpIHtcclxuICBpZiAoZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXSkge1xyXG4gICAgcmV0dXJuIGV2YWx1YXRvck1lbW9bZXhwcmVzc2lvbl07XHJcbiAgfVxyXG4gIGxldCBBc3luY0Z1bmN0aW9uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uKCkge1xyXG4gIH0pLmNvbnN0cnVjdG9yO1xyXG4gIGxldCByaWdodFNpZGVTYWZlRXhwcmVzc2lvbiA9IC9eW1xcblxcc10qaWYuKlxcKC4qXFwpLy50ZXN0KGV4cHJlc3Npb24pIHx8IC9eKGxldHxjb25zdClcXHMvLnRlc3QoZXhwcmVzc2lvbikgPyBgKGFzeW5jKCk9PnsgJHtleHByZXNzaW9ufSB9KSgpYCA6IGV4cHJlc3Npb247XHJcbiAgY29uc3Qgc2FmZUFzeW5jRnVuY3Rpb24gPSAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gbmV3IEFzeW5jRnVuY3Rpb24oW1wiX19zZWxmXCIsIFwic2NvcGVcIl0sIGB3aXRoIChzY29wZSkgeyBfX3NlbGYucmVzdWx0ID0gJHtyaWdodFNpZGVTYWZlRXhwcmVzc2lvbn0gfTsgX19zZWxmLmZpbmlzaGVkID0gdHJ1ZTsgcmV0dXJuIF9fc2VsZi5yZXN1bHQ7YCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcclxuICAgICAgaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbik7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGxldCBmdW5jID0gc2FmZUFzeW5jRnVuY3Rpb24oKTtcclxuICBldmFsdWF0b3JNZW1vW2V4cHJlc3Npb25dID0gZnVuYztcclxuICByZXR1cm4gZnVuYztcclxufVxyXG5mdW5jdGlvbiBnZW5lcmF0ZUV2YWx1YXRvckZyb21TdHJpbmcoZGF0YVN0YWNrLCBleHByZXNzaW9uLCBlbCkge1xyXG4gIGxldCBmdW5jID0gZ2VuZXJhdGVGdW5jdGlvbkZyb21TdHJpbmcoZXhwcmVzc2lvbiwgZWwpO1xyXG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XHJcbiAgfSwgeyBzY29wZTogc2NvcGUyID0ge30sIHBhcmFtcyA9IFtdIH0gPSB7fSkgPT4ge1xyXG4gICAgZnVuYy5yZXN1bHQgPSB2b2lkIDA7XHJcbiAgICBmdW5jLmZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICBsZXQgY29tcGxldGVTY29wZSA9IG1lcmdlUHJveGllcyhbc2NvcGUyLCAuLi5kYXRhU3RhY2tdKTtcclxuICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgIGxldCBwcm9taXNlID0gZnVuYyhmdW5jLCBjb21wbGV0ZVNjb3BlKS5jYXRjaCgoZXJyb3IyKSA9PiBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uKSk7XHJcbiAgICAgIGlmIChmdW5jLmZpbmlzaGVkKSB7XHJcbiAgICAgICAgcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgZnVuYy5yZXN1bHQsIGNvbXBsZXRlU2NvcGUsIHBhcmFtcywgZWwpO1xyXG4gICAgICAgIGZ1bmMucmVzdWx0ID0gdm9pZCAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCByZXN1bHQsIGNvbXBsZXRlU2NvcGUsIHBhcmFtcywgZWwpO1xyXG4gICAgICAgIH0pLmNhdGNoKChlcnJvcjIpID0+IGhhbmRsZUVycm9yKGVycm9yMiwgZWwsIGV4cHJlc3Npb24pKS5maW5hbGx5KCgpID0+IGZ1bmMucmVzdWx0ID0gdm9pZCAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgdmFsdWUsIHNjb3BlMiwgcGFyYW1zLCBlbCkge1xyXG4gIGlmIChzaG91bGRBdXRvRXZhbHVhdGVGdW5jdGlvbnMgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIGxldCByZXN1bHQgPSB2YWx1ZS5hcHBseShzY29wZTIsIHBhcmFtcyk7XHJcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICByZXN1bHQudGhlbigoaSkgPT4gcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgaSwgc2NvcGUyLCBwYXJhbXMpKS5jYXRjaCgoZXJyb3IyKSA9PiBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCB2YWx1ZSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVjZWl2ZXIocmVzdWx0KTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgIHZhbHVlLnRoZW4oKGkpID0+IHJlY2VpdmVyKGkpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVjZWl2ZXIodmFsdWUpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMuanNcclxudmFyIHByZWZpeEFzU3RyaW5nID0gXCJ4LVwiO1xyXG5mdW5jdGlvbiBwcmVmaXgoc3ViamVjdCA9IFwiXCIpIHtcclxuICByZXR1cm4gcHJlZml4QXNTdHJpbmcgKyBzdWJqZWN0O1xyXG59XHJcbmZ1bmN0aW9uIHNldFByZWZpeChuZXdQcmVmaXgpIHtcclxuICBwcmVmaXhBc1N0cmluZyA9IG5ld1ByZWZpeDtcclxufVxyXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7fTtcclxuZnVuY3Rpb24gZGlyZWN0aXZlKG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgZGlyZWN0aXZlSGFuZGxlcnNbbmFtZV0gPSBjYWxsYmFjaztcclxuICByZXR1cm4ge1xyXG4gICAgYmVmb3JlKGRpcmVjdGl2ZTIpIHtcclxuICAgICAgaWYgKCFkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmUyXSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgIFwiQ2Fubm90IGZpbmQgZGlyZWN0aXZlIGAke2RpcmVjdGl2ZX1gLiBgJHtuYW1lfWAgd2lsbCB1c2UgdGhlIGRlZmF1bHQgb3JkZXIgb2YgZXhlY3V0aW9uXCJcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBwb3MgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGRpcmVjdGl2ZTIpO1xyXG4gICAgICBkaXJlY3RpdmVPcmRlci5zcGxpY2UocG9zID49IDAgPyBwb3MgOiBkaXJlY3RpdmVPcmRlci5pbmRleE9mKFwiREVGQVVMVFwiKSwgMCwgbmFtZSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBkaXJlY3RpdmVzKGVsLCBhdHRyaWJ1dGVzLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XHJcbiAgYXR0cmlidXRlcyA9IEFycmF5LmZyb20oYXR0cmlidXRlcyk7XHJcbiAgaWYgKGVsLl94X3ZpcnR1YWxEaXJlY3RpdmVzKSB7XHJcbiAgICBsZXQgdkF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhlbC5feF92aXJ0dWFsRGlyZWN0aXZlcykubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSk7XHJcbiAgICBsZXQgc3RhdGljQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNPbmx5KHZBdHRyaWJ1dGVzKTtcclxuICAgIHZBdHRyaWJ1dGVzID0gdkF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcclxuICAgICAgaWYgKHN0YXRpY0F0dHJpYnV0ZXMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSBhdHRyaWJ1dGUubmFtZSkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbmFtZTogYHgtYmluZDoke2F0dHJpYnV0ZS5uYW1lfWAsXHJcbiAgICAgICAgICB2YWx1ZTogYFwiJHthdHRyaWJ1dGUudmFsdWV9XCJgXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xyXG4gICAgfSk7XHJcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQodkF0dHJpYnV0ZXMpO1xyXG4gIH1cclxuICBsZXQgdHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXAgPSB7fTtcclxuICBsZXQgZGlyZWN0aXZlczIgPSBhdHRyaWJ1dGVzLm1hcCh0b1RyYW5zZm9ybWVkQXR0cmlidXRlcygobmV3TmFtZSwgb2xkTmFtZSkgPT4gdHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXBbbmV3TmFtZV0gPSBvbGROYW1lKSkuZmlsdGVyKG91dE5vbkFscGluZUF0dHJpYnV0ZXMpLm1hcCh0b1BhcnNlZERpcmVjdGl2ZXModHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXAsIG9yaWdpbmFsQXR0cmlidXRlT3ZlcnJpZGUpKS5zb3J0KGJ5UHJpb3JpdHkpO1xyXG4gIHJldHVybiBkaXJlY3RpdmVzMi5tYXAoKGRpcmVjdGl2ZTIpID0+IHtcclxuICAgIHJldHVybiBnZXREaXJlY3RpdmVIYW5kbGVyKGVsLCBkaXJlY3RpdmUyKTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBhdHRyaWJ1dGVzT25seShhdHRyaWJ1dGVzKSB7XHJcbiAgcmV0dXJuIEFycmF5LmZyb20oYXR0cmlidXRlcykubWFwKHRvVHJhbnNmb3JtZWRBdHRyaWJ1dGVzKCkpLmZpbHRlcigoYXR0cikgPT4gIW91dE5vbkFscGluZUF0dHJpYnV0ZXMoYXR0cikpO1xyXG59XHJcbnZhciBpc0RlZmVycmluZ0hhbmRsZXJzID0gZmFsc2U7XHJcbnZhciBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxudmFyIGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkgPSBTeW1ib2woKTtcclxuZnVuY3Rpb24gZGVmZXJIYW5kbGluZ0RpcmVjdGl2ZXMoY2FsbGJhY2spIHtcclxuICBpc0RlZmVycmluZ0hhbmRsZXJzID0gdHJ1ZTtcclxuICBsZXQga2V5ID0gU3ltYm9sKCk7XHJcbiAgY3VycmVudEhhbmRsZXJTdGFja0tleSA9IGtleTtcclxuICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLnNldChrZXksIFtdKTtcclxuICBsZXQgZmx1c2hIYW5kbGVycyA9ICgpID0+IHtcclxuICAgIHdoaWxlIChkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLmdldChrZXkpLmxlbmd0aClcclxuICAgICAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5nZXQoa2V5KS5zaGlmdCgpKCk7XHJcbiAgICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLmRlbGV0ZShrZXkpO1xyXG4gIH07XHJcbiAgbGV0IHN0b3BEZWZlcnJpbmcgPSAoKSA9PiB7XHJcbiAgICBpc0RlZmVycmluZ0hhbmRsZXJzID0gZmFsc2U7XHJcbiAgICBmbHVzaEhhbmRsZXJzKCk7XHJcbiAgfTtcclxuICBjYWxsYmFjayhmbHVzaEhhbmRsZXJzKTtcclxuICBzdG9wRGVmZXJyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RWxlbWVudEJvdW5kVXRpbGl0aWVzKGVsKSB7XHJcbiAgbGV0IGNsZWFudXBzID0gW107XHJcbiAgbGV0IGNsZWFudXAyID0gKGNhbGxiYWNrKSA9PiBjbGVhbnVwcy5wdXNoKGNhbGxiYWNrKTtcclxuICBsZXQgW2VmZmVjdDMsIGNsZWFudXBFZmZlY3RdID0gZWxlbWVudEJvdW5kRWZmZWN0KGVsKTtcclxuICBjbGVhbnVwcy5wdXNoKGNsZWFudXBFZmZlY3QpO1xyXG4gIGxldCB1dGlsaXRpZXMgPSB7XHJcbiAgICBBbHBpbmU6IGFscGluZV9kZWZhdWx0LFxyXG4gICAgZWZmZWN0OiBlZmZlY3QzLFxyXG4gICAgY2xlYW51cDogY2xlYW51cDIsXHJcbiAgICBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyLmJpbmQoZXZhbHVhdGVMYXRlciwgZWwpLFxyXG4gICAgZXZhbHVhdGU6IGV2YWx1YXRlLmJpbmQoZXZhbHVhdGUsIGVsKVxyXG4gIH07XHJcbiAgbGV0IGRvQ2xlYW51cCA9ICgpID0+IGNsZWFudXBzLmZvckVhY2goKGkpID0+IGkoKSk7XHJcbiAgcmV0dXJuIFt1dGlsaXRpZXMsIGRvQ2xlYW51cF07XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGlyZWN0aXZlSGFuZGxlcihlbCwgZGlyZWN0aXZlMikge1xyXG4gIGxldCBub29wID0gKCkgPT4ge1xyXG4gIH07XHJcbiAgbGV0IGhhbmRsZXIzID0gZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlMi50eXBlXSB8fCBub29wO1xyXG4gIGxldCBbdXRpbGl0aWVzLCBjbGVhbnVwMl0gPSBnZXRFbGVtZW50Qm91bmRVdGlsaXRpZXMoZWwpO1xyXG4gIG9uQXR0cmlidXRlUmVtb3ZlZChlbCwgZGlyZWN0aXZlMi5vcmlnaW5hbCwgY2xlYW51cDIpO1xyXG4gIGxldCBmdWxsSGFuZGxlciA9ICgpID0+IHtcclxuICAgIGlmIChlbC5feF9pZ25vcmUgfHwgZWwuX3hfaWdub3JlU2VsZilcclxuICAgICAgcmV0dXJuO1xyXG4gICAgaGFuZGxlcjMuaW5saW5lICYmIGhhbmRsZXIzLmlubGluZShlbCwgZGlyZWN0aXZlMiwgdXRpbGl0aWVzKTtcclxuICAgIGhhbmRsZXIzID0gaGFuZGxlcjMuYmluZChoYW5kbGVyMywgZWwsIGRpcmVjdGl2ZTIsIHV0aWxpdGllcyk7XHJcbiAgICBpc0RlZmVycmluZ0hhbmRsZXJzID8gZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5nZXQoY3VycmVudEhhbmRsZXJTdGFja0tleSkucHVzaChoYW5kbGVyMykgOiBoYW5kbGVyMygpO1xyXG4gIH07XHJcbiAgZnVsbEhhbmRsZXIucnVuQ2xlYW51cHMgPSBjbGVhbnVwMjtcclxuICByZXR1cm4gZnVsbEhhbmRsZXI7XHJcbn1cclxudmFyIHN0YXJ0aW5nV2l0aCA9IChzdWJqZWN0LCByZXBsYWNlbWVudCkgPT4gKHsgbmFtZSwgdmFsdWUgfSkgPT4ge1xyXG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoc3ViamVjdCkpXHJcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKHN1YmplY3QsIHJlcGxhY2VtZW50KTtcclxuICByZXR1cm4geyBuYW1lLCB2YWx1ZSB9O1xyXG59O1xyXG52YXIgaW50byA9IChpKSA9PiBpO1xyXG5mdW5jdGlvbiB0b1RyYW5zZm9ybWVkQXR0cmlidXRlcyhjYWxsYmFjayA9ICgpID0+IHtcclxufSkge1xyXG4gIHJldHVybiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XHJcbiAgICBsZXQgeyBuYW1lOiBuZXdOYW1lLCB2YWx1ZTogbmV3VmFsdWUgfSA9IGF0dHJpYnV0ZVRyYW5zZm9ybWVycy5yZWR1Y2UoKGNhcnJ5LCB0cmFuc2Zvcm0pID0+IHtcclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybShjYXJyeSk7XHJcbiAgICB9LCB7IG5hbWUsIHZhbHVlIH0pO1xyXG4gICAgaWYgKG5ld05hbWUgIT09IG5hbWUpXHJcbiAgICAgIGNhbGxiYWNrKG5ld05hbWUsIG5hbWUpO1xyXG4gICAgcmV0dXJuIHsgbmFtZTogbmV3TmFtZSwgdmFsdWU6IG5ld1ZhbHVlIH07XHJcbiAgfTtcclxufVxyXG52YXIgYXR0cmlidXRlVHJhbnNmb3JtZXJzID0gW107XHJcbmZ1bmN0aW9uIG1hcEF0dHJpYnV0ZXMoY2FsbGJhY2spIHtcclxuICBhdHRyaWJ1dGVUcmFuc2Zvcm1lcnMucHVzaChjYWxsYmFjayk7XHJcbn1cclxuZnVuY3Rpb24gb3V0Tm9uQWxwaW5lQXR0cmlidXRlcyh7IG5hbWUgfSkge1xyXG4gIHJldHVybiBhbHBpbmVBdHRyaWJ1dGVSZWdleCgpLnRlc3QobmFtZSk7XHJcbn1cclxudmFyIGFscGluZUF0dHJpYnV0ZVJlZ2V4ID0gKCkgPT4gbmV3IFJlZ0V4cChgXiR7cHJlZml4QXNTdHJpbmd9KFteOl4uXSspXFxcXGJgKTtcclxuZnVuY3Rpb24gdG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XHJcbiAgcmV0dXJuICh7IG5hbWUsIHZhbHVlIH0pID0+IHtcclxuICAgIGxldCB0eXBlTWF0Y2ggPSBuYW1lLm1hdGNoKGFscGluZUF0dHJpYnV0ZVJlZ2V4KCkpO1xyXG4gICAgbGV0IHZhbHVlTWF0Y2ggPSBuYW1lLm1hdGNoKC86KFthLXpBLVowLTlcXC06XSspLyk7XHJcbiAgICBsZXQgbW9kaWZpZXJzID0gbmFtZS5tYXRjaCgvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZykgfHwgW107XHJcbiAgICBsZXQgb3JpZ2luYWwgPSBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlIHx8IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwW25hbWVdIHx8IG5hbWU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiB0eXBlTWF0Y2ggPyB0eXBlTWF0Y2hbMV0gOiBudWxsLFxyXG4gICAgICB2YWx1ZTogdmFsdWVNYXRjaCA/IHZhbHVlTWF0Y2hbMV0gOiBudWxsLFxyXG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVycy5tYXAoKGkpID0+IGkucmVwbGFjZShcIi5cIiwgXCJcIikpLFxyXG4gICAgICBleHByZXNzaW9uOiB2YWx1ZSxcclxuICAgICAgb3JpZ2luYWxcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG52YXIgREVGQVVMVCA9IFwiREVGQVVMVFwiO1xyXG52YXIgZGlyZWN0aXZlT3JkZXIgPSBbXHJcbiAgXCJpZ25vcmVcIixcclxuICBcInJlZlwiLFxyXG4gIFwiZGF0YVwiLFxyXG4gIFwiaWRcIixcclxuICBcImJpbmRcIixcclxuICBcImluaXRcIixcclxuICBcImZvclwiLFxyXG4gIFwibW9kZWxcIixcclxuICBcIm1vZGVsYWJsZVwiLFxyXG4gIFwidHJhbnNpdGlvblwiLFxyXG4gIFwic2hvd1wiLFxyXG4gIFwiaWZcIixcclxuICBERUZBVUxULFxyXG4gIFwidGVsZXBvcnRcIlxyXG5dO1xyXG5mdW5jdGlvbiBieVByaW9yaXR5KGEsIGIpIHtcclxuICBsZXQgdHlwZUEgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGEudHlwZSkgPT09IC0xID8gREVGQVVMVCA6IGEudHlwZTtcclxuICBsZXQgdHlwZUIgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGIudHlwZSkgPT09IC0xID8gREVGQVVMVCA6IGIudHlwZTtcclxuICByZXR1cm4gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQSkgLSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKHR5cGVCKTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2Rpc3BhdGNoLmpzXHJcbmZ1bmN0aW9uIGRpc3BhdGNoKGVsLCBuYW1lLCBkZXRhaWwgPSB7fSkge1xyXG4gIGVsLmRpc3BhdGNoRXZlbnQoXHJcbiAgICBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xyXG4gICAgICBkZXRhaWwsXHJcbiAgICAgIGJ1YmJsZXM6IHRydWUsXHJcbiAgICAgIC8vIEFsbG93cyBldmVudHMgdG8gcGFzcyB0aGUgc2hhZG93IERPTSBiYXJyaWVyLlxyXG4gICAgICBjb21wb3NlZDogdHJ1ZSxcclxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxyXG4gICAgfSlcclxuICApO1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvd2Fsay5qc1xyXG5mdW5jdGlvbiB3YWxrKGVsLCBjYWxsYmFjaykge1xyXG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gXCJmdW5jdGlvblwiICYmIGVsIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xyXG4gICAgQXJyYXkuZnJvbShlbC5jaGlsZHJlbikuZm9yRWFjaCgoZWwyKSA9PiB3YWxrKGVsMiwgY2FsbGJhY2spKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgbGV0IHNraXAgPSBmYWxzZTtcclxuICBjYWxsYmFjayhlbCwgKCkgPT4gc2tpcCA9IHRydWUpO1xyXG4gIGlmIChza2lwKVxyXG4gICAgcmV0dXJuO1xyXG4gIGxldCBub2RlID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgd2hpbGUgKG5vZGUpIHtcclxuICAgIHdhbGsobm9kZSwgY2FsbGJhY2ssIGZhbHNlKTtcclxuICAgIG5vZGUgPSBub2RlLm5leHRFbGVtZW50U2libGluZztcclxuICB9XHJcbn1cclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy93YXJuLmpzXHJcbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSwgLi4uYXJncykge1xyXG4gIGNvbnNvbGUud2FybihgQWxwaW5lIFdhcm5pbmc6ICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2xpZmVjeWNsZS5qc1xyXG5mdW5jdGlvbiBzdGFydCgpIHtcclxuICBpZiAoIWRvY3VtZW50LmJvZHkpXHJcbiAgICB3YXJuKFwiVW5hYmxlIHRvIGluaXRpYWxpemUuIFRyeWluZyB0byBsb2FkIEFscGluZSBiZWZvcmUgYDxib2R5PmAgaXMgYXZhaWxhYmxlLiBEaWQgeW91IGZvcmdldCB0byBhZGQgYGRlZmVyYCBpbiBBbHBpbmUncyBgPHNjcmlwdD5gIHRhZz9cIik7XHJcbiAgZGlzcGF0Y2goZG9jdW1lbnQsIFwiYWxwaW5lOmluaXRcIik7XHJcbiAgZGlzcGF0Y2goZG9jdW1lbnQsIFwiYWxwaW5lOmluaXRpYWxpemluZ1wiKTtcclxuICBzdGFydE9ic2VydmluZ011dGF0aW9ucygpO1xyXG4gIG9uRWxBZGRlZCgoZWwpID0+IGluaXRUcmVlKGVsLCB3YWxrKSk7XHJcbiAgb25FbFJlbW92ZWQoKGVsKSA9PiBkZXN0cm95VHJlZShlbCkpO1xyXG4gIG9uQXR0cmlidXRlc0FkZGVkKChlbCwgYXR0cnMpID0+IHtcclxuICAgIGRpcmVjdGl2ZXMoZWwsIGF0dHJzKS5mb3JFYWNoKChoYW5kbGUpID0+IGhhbmRsZSgpKTtcclxuICB9KTtcclxuICBsZXQgb3V0TmVzdGVkQ29tcG9uZW50cyA9IChlbCkgPT4gIWNsb3Nlc3RSb290KGVsLnBhcmVudEVsZW1lbnQsIHRydWUpO1xyXG4gIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChhbGxTZWxlY3RvcnMoKSkpLmZpbHRlcihvdXROZXN0ZWRDb21wb25lbnRzKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgaW5pdFRyZWUoZWwpO1xyXG4gIH0pO1xyXG4gIGRpc3BhdGNoKGRvY3VtZW50LCBcImFscGluZTppbml0aWFsaXplZFwiKTtcclxufVxyXG52YXIgcm9vdFNlbGVjdG9yQ2FsbGJhY2tzID0gW107XHJcbnZhciBpbml0U2VsZWN0b3JDYWxsYmFja3MgPSBbXTtcclxuZnVuY3Rpb24gcm9vdFNlbGVjdG9ycygpIHtcclxuICByZXR1cm4gcm9vdFNlbGVjdG9yQ2FsbGJhY2tzLm1hcCgoZm4pID0+IGZuKCkpO1xyXG59XHJcbmZ1bmN0aW9uIGFsbFNlbGVjdG9ycygpIHtcclxuICByZXR1cm4gcm9vdFNlbGVjdG9yQ2FsbGJhY2tzLmNvbmNhdChpbml0U2VsZWN0b3JDYWxsYmFja3MpLm1hcCgoZm4pID0+IGZuKCkpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFJvb3RTZWxlY3RvcihzZWxlY3RvckNhbGxiYWNrKSB7XHJcbiAgcm9vdFNlbGVjdG9yQ2FsbGJhY2tzLnB1c2goc2VsZWN0b3JDYWxsYmFjayk7XHJcbn1cclxuZnVuY3Rpb24gYWRkSW5pdFNlbGVjdG9yKHNlbGVjdG9yQ2FsbGJhY2spIHtcclxuICBpbml0U2VsZWN0b3JDYWxsYmFja3MucHVzaChzZWxlY3RvckNhbGxiYWNrKTtcclxufVxyXG5mdW5jdGlvbiBjbG9zZXN0Um9vdChlbCwgaW5jbHVkZUluaXRTZWxlY3RvcnMgPSBmYWxzZSkge1xyXG4gIHJldHVybiBmaW5kQ2xvc2VzdChlbCwgKGVsZW1lbnQpID0+IHtcclxuICAgIGNvbnN0IHNlbGVjdG9ycyA9IGluY2x1ZGVJbml0U2VsZWN0b3JzID8gYWxsU2VsZWN0b3JzKCkgOiByb290U2VsZWN0b3JzKCk7XHJcbiAgICBpZiAoc2VsZWN0b3JzLnNvbWUoKHNlbGVjdG9yKSA9PiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSlcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZmluZENsb3Nlc3QoZWwsIGNhbGxiYWNrKSB7XHJcbiAgaWYgKCFlbClcclxuICAgIHJldHVybjtcclxuICBpZiAoY2FsbGJhY2soZWwpKVxyXG4gICAgcmV0dXJuIGVsO1xyXG4gIGlmIChlbC5feF90ZWxlcG9ydEJhY2spXHJcbiAgICBlbCA9IGVsLl94X3RlbGVwb3J0QmFjaztcclxuICBpZiAoIWVsLnBhcmVudEVsZW1lbnQpXHJcbiAgICByZXR1cm47XHJcbiAgcmV0dXJuIGZpbmRDbG9zZXN0KGVsLnBhcmVudEVsZW1lbnQsIGNhbGxiYWNrKTtcclxufVxyXG5mdW5jdGlvbiBpc1Jvb3QoZWwpIHtcclxuICByZXR1cm4gcm9vdFNlbGVjdG9ycygpLnNvbWUoKHNlbGVjdG9yKSA9PiBlbC5tYXRjaGVzKHNlbGVjdG9yKSk7XHJcbn1cclxudmFyIGluaXRJbnRlcmNlcHRvcnMyID0gW107XHJcbmZ1bmN0aW9uIGludGVyY2VwdEluaXQoY2FsbGJhY2spIHtcclxuICBpbml0SW50ZXJjZXB0b3JzMi5wdXNoKGNhbGxiYWNrKTtcclxufVxyXG5mdW5jdGlvbiBpbml0VHJlZShlbCwgd2Fsa2VyID0gd2FsaywgaW50ZXJjZXB0ID0gKCkgPT4ge1xyXG59KSB7XHJcbiAgZGVmZXJIYW5kbGluZ0RpcmVjdGl2ZXMoKCkgPT4ge1xyXG4gICAgd2Fsa2VyKGVsLCAoZWwyLCBza2lwKSA9PiB7XHJcbiAgICAgIGludGVyY2VwdChlbDIsIHNraXApO1xyXG4gICAgICBpbml0SW50ZXJjZXB0b3JzMi5mb3JFYWNoKChpKSA9PiBpKGVsMiwgc2tpcCkpO1xyXG4gICAgICBkaXJlY3RpdmVzKGVsMiwgZWwyLmF0dHJpYnV0ZXMpLmZvckVhY2goKGhhbmRsZSkgPT4gaGFuZGxlKCkpO1xyXG4gICAgICBlbDIuX3hfaWdub3JlICYmIHNraXAoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGRlc3Ryb3lUcmVlKHJvb3QpIHtcclxuICB3YWxrKHJvb3QsIChlbCkgPT4gY2xlYW51cEF0dHJpYnV0ZXMoZWwpKTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL25leHRUaWNrLmpzXHJcbnZhciB0aWNrU3RhY2sgPSBbXTtcclxudmFyIGlzSG9sZGluZyA9IGZhbHNlO1xyXG5mdW5jdGlvbiBuZXh0VGljayhjYWxsYmFjayA9ICgpID0+IHtcclxufSkge1xyXG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgIGlzSG9sZGluZyB8fCBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgcmVsZWFzZU5leHRUaWNrcygpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcclxuICAgIHRpY2tTdGFjay5wdXNoKCgpID0+IHtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgcmVzKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiByZWxlYXNlTmV4dFRpY2tzKCkge1xyXG4gIGlzSG9sZGluZyA9IGZhbHNlO1xyXG4gIHdoaWxlICh0aWNrU3RhY2subGVuZ3RoKVxyXG4gICAgdGlja1N0YWNrLnNoaWZ0KCkoKTtcclxufVxyXG5mdW5jdGlvbiBob2xkTmV4dFRpY2tzKCkge1xyXG4gIGlzSG9sZGluZyA9IHRydWU7XHJcbn1cclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9jbGFzc2VzLmpzXHJcbmZ1bmN0aW9uIHNldENsYXNzZXMoZWwsIHZhbHVlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gc2V0Q2xhc3Nlc0Zyb21TdHJpbmcoZWwsIHZhbHVlLmpvaW4oXCIgXCIpKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHNldENsYXNzZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgcmV0dXJuIHNldENsYXNzZXMoZWwsIHZhbHVlKCkpO1xyXG4gIH1cclxuICByZXR1cm4gc2V0Q2xhc3Nlc0Zyb21TdHJpbmcoZWwsIHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgY2xhc3NTdHJpbmcpIHtcclxuICBsZXQgc3BsaXQgPSAoY2xhc3NTdHJpbmcyKSA9PiBjbGFzc1N0cmluZzIuc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKTtcclxuICBsZXQgbWlzc2luZ0NsYXNzZXMgPSAoY2xhc3NTdHJpbmcyKSA9PiBjbGFzc1N0cmluZzIuc3BsaXQoXCIgXCIpLmZpbHRlcigoaSkgPT4gIWVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkuZmlsdGVyKEJvb2xlYW4pO1xyXG4gIGxldCBhZGRDbGFzc2VzQW5kUmV0dXJuVW5kbyA9IChjbGFzc2VzKSA9PiB7XHJcbiAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzKTtcclxuICAgIH07XHJcbiAgfTtcclxuICBjbGFzc1N0cmluZyA9IGNsYXNzU3RyaW5nID09PSB0cnVlID8gY2xhc3NTdHJpbmcgPSBcIlwiIDogY2xhc3NTdHJpbmcgfHwgXCJcIjtcclxuICByZXR1cm4gYWRkQ2xhc3Nlc0FuZFJldHVyblVuZG8obWlzc2luZ0NsYXNzZXMoY2xhc3NTdHJpbmcpKTtcclxufVxyXG5mdW5jdGlvbiBzZXRDbGFzc2VzRnJvbU9iamVjdChlbCwgY2xhc3NPYmplY3QpIHtcclxuICBsZXQgc3BsaXQgPSAoY2xhc3NTdHJpbmcpID0+IGNsYXNzU3RyaW5nLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgbGV0IGZvckFkZCA9IE9iamVjdC5lbnRyaWVzKGNsYXNzT2JqZWN0KS5mbGF0TWFwKChbY2xhc3NTdHJpbmcsIGJvb2xdKSA9PiBib29sID8gc3BsaXQoY2xhc3NTdHJpbmcpIDogZmFsc2UpLmZpbHRlcihCb29sZWFuKTtcclxuICBsZXQgZm9yUmVtb3ZlID0gT2JqZWN0LmVudHJpZXMoY2xhc3NPYmplY3QpLmZsYXRNYXAoKFtjbGFzc1N0cmluZywgYm9vbF0pID0+ICFib29sID8gc3BsaXQoY2xhc3NTdHJpbmcpIDogZmFsc2UpLmZpbHRlcihCb29sZWFuKTtcclxuICBsZXQgYWRkZWQgPSBbXTtcclxuICBsZXQgcmVtb3ZlZCA9IFtdO1xyXG4gIGZvclJlbW92ZS5mb3JFYWNoKChpKSA9PiB7XHJcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGkpKSB7XHJcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoaSk7XHJcbiAgICAgIHJlbW92ZWQucHVzaChpKTtcclxuICAgIH1cclxuICB9KTtcclxuICBmb3JBZGQuZm9yRWFjaCgoaSkgPT4ge1xyXG4gICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoaSkpIHtcclxuICAgICAgZWwuY2xhc3NMaXN0LmFkZChpKTtcclxuICAgICAgYWRkZWQucHVzaChpKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gKCkgPT4ge1xyXG4gICAgcmVtb3ZlZC5mb3JFYWNoKChpKSA9PiBlbC5jbGFzc0xpc3QuYWRkKGkpKTtcclxuICAgIGFkZGVkLmZvckVhY2goKGkpID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoaSkpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9zdHlsZXMuanNcclxuZnVuY3Rpb24gc2V0U3R5bGVzKGVsLCB2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgIHJldHVybiBzZXRTdHlsZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSk7XHJcbiAgfVxyXG4gIHJldHVybiBzZXRTdHlsZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0U3R5bGVzRnJvbU9iamVjdChlbCwgdmFsdWUpIHtcclxuICBsZXQgcHJldmlvdXNTdHlsZXMgPSB7fTtcclxuICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgdmFsdWUyXSkgPT4ge1xyXG4gICAgcHJldmlvdXNTdHlsZXNba2V5XSA9IGVsLnN0eWxlW2tleV07XHJcbiAgICBpZiAoIWtleS5zdGFydHNXaXRoKFwiLS1cIikpIHtcclxuICAgICAga2V5ID0ga2ViYWJDYXNlKGtleSk7XHJcbiAgICB9XHJcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlMik7XHJcbiAgfSk7XHJcbiAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBpZiAoZWwuc3R5bGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiAoKSA9PiB7XHJcbiAgICBzZXRTdHlsZXMoZWwsIHByZXZpb3VzU3R5bGVzKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNldFN0eWxlc0Zyb21TdHJpbmcoZWwsIHZhbHVlKSB7XHJcbiAgbGV0IGNhY2hlID0gZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIiwgdmFsdWUpO1xyXG4gIGVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHZhbHVlKTtcclxuICByZXR1cm4gKCkgPT4ge1xyXG4gICAgZWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgY2FjaGUgfHwgXCJcIik7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBrZWJhYkNhc2Uoc3ViamVjdCkge1xyXG4gIHJldHVybiBzdWJqZWN0LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL29uY2UuanNcclxuZnVuY3Rpb24gb25jZShjYWxsYmFjaywgZmFsbGJhY2sgPSAoKSA9PiB7XHJcbn0pIHtcclxuICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCFjYWxsZWQpIHtcclxuICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC10cmFuc2l0aW9uLmpzXHJcbmRpcmVjdGl2ZShcInRyYW5zaXRpb25cIiwgKGVsLCB7IHZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb24gfSwgeyBldmFsdWF0ZTogZXZhbHVhdGUyIH0pID0+IHtcclxuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwiZnVuY3Rpb25cIilcclxuICAgIGV4cHJlc3Npb24gPSBldmFsdWF0ZTIoZXhwcmVzc2lvbik7XHJcbiAgaWYgKCFleHByZXNzaW9uKSB7XHJcbiAgICByZWdpc3RlclRyYW5zaXRpb25zRnJvbUhlbHBlcihlbCwgbW9kaWZpZXJzLCB2YWx1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tQ2xhc3NTdHJpbmcoZWwsIGV4cHJlc3Npb24sIHZhbHVlKTtcclxuICB9XHJcbn0pO1xyXG5mdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25zRnJvbUNsYXNzU3RyaW5nKGVsLCBjbGFzc1N0cmluZywgc3RhZ2UpIHtcclxuICByZWdpc3RlclRyYW5zaXRpb25PYmplY3QoZWwsIHNldENsYXNzZXMsIFwiXCIpO1xyXG4gIGxldCBkaXJlY3RpdmVTdG9yYWdlTWFwID0ge1xyXG4gICAgXCJlbnRlclwiOiAoY2xhc3NlcykgPT4ge1xyXG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IGNsYXNzZXM7XHJcbiAgICB9LFxyXG4gICAgXCJlbnRlci1zdGFydFwiOiAoY2xhc3NlcykgPT4ge1xyXG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0ID0gY2xhc3NlcztcclxuICAgIH0sXHJcbiAgICBcImVudGVyLWVuZFwiOiAoY2xhc3NlcykgPT4ge1xyXG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmVuZCA9IGNsYXNzZXM7XHJcbiAgICB9LFxyXG4gICAgXCJsZWF2ZVwiOiAoY2xhc3NlcykgPT4ge1xyXG4gICAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLmR1cmluZyA9IGNsYXNzZXM7XHJcbiAgICB9LFxyXG4gICAgXCJsZWF2ZS1zdGFydFwiOiAoY2xhc3NlcykgPT4ge1xyXG4gICAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLnN0YXJ0ID0gY2xhc3NlcztcclxuICAgIH0sXHJcbiAgICBcImxlYXZlLWVuZFwiOiAoY2xhc3NlcykgPT4ge1xyXG4gICAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLmVuZCA9IGNsYXNzZXM7XHJcbiAgICB9XHJcbiAgfTtcclxuICBkaXJlY3RpdmVTdG9yYWdlTWFwW3N0YWdlXShjbGFzc1N0cmluZyk7XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uc0Zyb21IZWxwZXIoZWwsIG1vZGlmaWVycywgc3RhZ2UpIHtcclxuICByZWdpc3RlclRyYW5zaXRpb25PYmplY3QoZWwsIHNldFN0eWxlcyk7XHJcbiAgbGV0IGRvZXNudFNwZWNpZnkgPSAhbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5cIikgJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSAmJiAhc3RhZ2U7XHJcbiAgbGV0IHRyYW5zaXRpb25pbmdJbiA9IGRvZXNudFNwZWNpZnkgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5cIikgfHwgW1wiZW50ZXJcIl0uaW5jbHVkZXMoc3RhZ2UpO1xyXG4gIGxldCB0cmFuc2l0aW9uaW5nT3V0ID0gZG9lc250U3BlY2lmeSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJvdXRcIikgfHwgW1wibGVhdmVcIl0uaW5jbHVkZXMoc3RhZ2UpO1xyXG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpblwiKSAmJiAhZG9lc250U3BlY2lmeSkge1xyXG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigoaSwgaW5kZXgpID0+IGluZGV4IDwgbW9kaWZpZXJzLmluZGV4T2YoXCJvdXRcIikpO1xyXG4gIH1cclxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0XCIpICYmICFkb2VzbnRTcGVjaWZ5KSB7XHJcbiAgICBtb2RpZmllcnMgPSBtb2RpZmllcnMuZmlsdGVyKChpLCBpbmRleCkgPT4gaW5kZXggPiBtb2RpZmllcnMuaW5kZXhPZihcIm91dFwiKSk7XHJcbiAgfVxyXG4gIGxldCB3YW50c0FsbCA9ICFtb2RpZmllcnMuaW5jbHVkZXMoXCJvcGFjaXR5XCIpICYmICFtb2RpZmllcnMuaW5jbHVkZXMoXCJzY2FsZVwiKTtcclxuICBsZXQgd2FudHNPcGFjaXR5ID0gd2FudHNBbGwgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwib3BhY2l0eVwiKTtcclxuICBsZXQgd2FudHNTY2FsZSA9IHdhbnRzQWxsIHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcInNjYWxlXCIpO1xyXG4gIGxldCBvcGFjaXR5VmFsdWUgPSB3YW50c09wYWNpdHkgPyAwIDogMTtcclxuICBsZXQgc2NhbGVWYWx1ZSA9IHdhbnRzU2NhbGUgPyBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJzY2FsZVwiLCA5NSkgLyAxMDAgOiAxO1xyXG4gIGxldCBkZWxheSA9IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBcImRlbGF5XCIsIDApO1xyXG4gIGxldCBvcmlnaW4gPSBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJvcmlnaW5cIiwgXCJjZW50ZXJcIik7XHJcbiAgbGV0IHByb3BlcnR5ID0gXCJvcGFjaXR5LCB0cmFuc2Zvcm1cIjtcclxuICBsZXQgZHVyYXRpb25JbiA9IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBcImR1cmF0aW9uXCIsIDE1MCkgLyAxZTM7XHJcbiAgbGV0IGR1cmF0aW9uT3V0ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgNzUpIC8gMWUzO1xyXG4gIGxldCBlYXNpbmcgPSBgY3ViaWMtYmV6aWVyKDAuNCwgMC4wLCAwLjIsIDEpYDtcclxuICBpZiAodHJhbnNpdGlvbmluZ0luKSB7XHJcbiAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IHtcclxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBvcmlnaW4sXHJcbiAgICAgIHRyYW5zaXRpb25EZWxheTogZGVsYXksXHJcbiAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7ZHVyYXRpb25Jbn1zYCxcclxuICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBlYXNpbmdcclxuICAgIH07XHJcbiAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0ID0ge1xyXG4gICAgICBvcGFjaXR5OiBvcGFjaXR5VmFsdWUsXHJcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7c2NhbGVWYWx1ZX0pYFxyXG4gICAgfTtcclxuICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZW5kID0ge1xyXG4gICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKWBcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmICh0cmFuc2l0aW9uaW5nT3V0KSB7XHJcbiAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLmR1cmluZyA9IHtcclxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBvcmlnaW4sXHJcbiAgICAgIHRyYW5zaXRpb25EZWxheTogZGVsYXksXHJcbiAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7ZHVyYXRpb25PdXR9c2AsXHJcbiAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogZWFzaW5nXHJcbiAgICB9O1xyXG4gICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5zdGFydCA9IHtcclxuICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoMSlgXHJcbiAgICB9O1xyXG4gICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5lbmQgPSB7XHJcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlWYWx1ZSxcclxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZVZhbHVlfSlgXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25PYmplY3QoZWwsIHNldEZ1bmN0aW9uLCBkZWZhdWx0VmFsdWUgPSB7fSkge1xyXG4gIGlmICghZWwuX3hfdHJhbnNpdGlvbilcclxuICAgIGVsLl94X3RyYW5zaXRpb24gPSB7XHJcbiAgICAgIGVudGVyOiB7IGR1cmluZzogZGVmYXVsdFZhbHVlLCBzdGFydDogZGVmYXVsdFZhbHVlLCBlbmQ6IGRlZmF1bHRWYWx1ZSB9LFxyXG4gICAgICBsZWF2ZTogeyBkdXJpbmc6IGRlZmF1bHRWYWx1ZSwgc3RhcnQ6IGRlZmF1bHRWYWx1ZSwgZW5kOiBkZWZhdWx0VmFsdWUgfSxcclxuICAgICAgaW4oYmVmb3JlID0gKCkgPT4ge1xyXG4gICAgICB9LCBhZnRlciA9ICgpID0+IHtcclxuICAgICAgfSkge1xyXG4gICAgICAgIHRyYW5zaXRpb24oZWwsIHNldEZ1bmN0aW9uLCB7XHJcbiAgICAgICAgICBkdXJpbmc6IHRoaXMuZW50ZXIuZHVyaW5nLFxyXG4gICAgICAgICAgc3RhcnQ6IHRoaXMuZW50ZXIuc3RhcnQsXHJcbiAgICAgICAgICBlbmQ6IHRoaXMuZW50ZXIuZW5kXHJcbiAgICAgICAgfSwgYmVmb3JlLCBhZnRlcik7XHJcbiAgICAgIH0sXHJcbiAgICAgIG91dChiZWZvcmUgPSAoKSA9PiB7XHJcbiAgICAgIH0sIGFmdGVyID0gKCkgPT4ge1xyXG4gICAgICB9KSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtcclxuICAgICAgICAgIGR1cmluZzogdGhpcy5sZWF2ZS5kdXJpbmcsXHJcbiAgICAgICAgICBzdGFydDogdGhpcy5sZWF2ZS5zdGFydCxcclxuICAgICAgICAgIGVuZDogdGhpcy5sZWF2ZS5lbmRcclxuICAgICAgICB9LCBiZWZvcmUsIGFmdGVyKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxufVxyXG53aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuX3hfdG9nZ2xlQW5kQ2FzY2FkZVdpdGhUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKGVsLCB2YWx1ZSwgc2hvdywgaGlkZSkge1xyXG4gIGNvbnN0IG5leHRUaWNrMiA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRUaW1lb3V0O1xyXG4gIGxldCBjbGlja0F3YXlDb21wYXRpYmxlU2hvdyA9ICgpID0+IG5leHRUaWNrMihzaG93KTtcclxuICBpZiAodmFsdWUpIHtcclxuICAgIGlmIChlbC5feF90cmFuc2l0aW9uICYmIChlbC5feF90cmFuc2l0aW9uLmVudGVyIHx8IGVsLl94X3RyYW5zaXRpb24ubGVhdmUpKSB7XHJcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIgJiYgKE9iamVjdC5lbnRyaWVzKGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZHVyaW5nKS5sZW5ndGggfHwgT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5zdGFydCkubGVuZ3RoIHx8IE9iamVjdC5lbnRyaWVzKGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZW5kKS5sZW5ndGgpID8gZWwuX3hfdHJhbnNpdGlvbi5pbihzaG93KSA6IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5feF90cmFuc2l0aW9uID8gZWwuX3hfdHJhbnNpdGlvbi5pbihzaG93KSA6IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGVsLl94X2hpZGVQcm9taXNlID0gZWwuX3hfdHJhbnNpdGlvbiA/IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGVsLl94X3RyYW5zaXRpb24ub3V0KCgpID0+IHtcclxuICAgIH0sICgpID0+IHJlc29sdmUoaGlkZSkpO1xyXG4gICAgZWwuX3hfdHJhbnNpdGlvbmluZy5iZWZvcmVDYW5jZWwoKCkgPT4gcmVqZWN0KHsgaXNGcm9tQ2FuY2VsbGVkVHJhbnNpdGlvbjogdHJ1ZSB9KSk7XHJcbiAgfSkgOiBQcm9taXNlLnJlc29sdmUoaGlkZSk7XHJcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgbGV0IGNsb3Nlc3QgPSBjbG9zZXN0SGlkZShlbCk7XHJcbiAgICBpZiAoY2xvc2VzdCkge1xyXG4gICAgICBpZiAoIWNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuKVxyXG4gICAgICAgIGNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuID0gW107XHJcbiAgICAgIGNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuLnB1c2goZWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmV4dFRpY2syKCgpID0+IHtcclxuICAgICAgICBsZXQgaGlkZUFmdGVyQ2hpbGRyZW4gPSAoZWwyKSA9PiB7XHJcbiAgICAgICAgICBsZXQgY2FycnkgPSBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIGVsMi5feF9oaWRlUHJvbWlzZSxcclxuICAgICAgICAgICAgLi4uKGVsMi5feF9oaWRlQ2hpbGRyZW4gfHwgW10pLm1hcChoaWRlQWZ0ZXJDaGlsZHJlbilcclxuICAgICAgICAgIF0pLnRoZW4oKFtpXSkgPT4gaSgpKTtcclxuICAgICAgICAgIGRlbGV0ZSBlbDIuX3hfaGlkZVByb21pc2U7XHJcbiAgICAgICAgICBkZWxldGUgZWwyLl94X2hpZGVDaGlsZHJlbjtcclxuICAgICAgICAgIHJldHVybiBjYXJyeTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGhpZGVBZnRlckNoaWxkcmVuKGVsKS5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgaWYgKCFlLmlzRnJvbUNhbmNlbGxlZFRyYW5zaXRpb24pXHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5mdW5jdGlvbiBjbG9zZXN0SGlkZShlbCkge1xyXG4gIGxldCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gIGlmICghcGFyZW50KVxyXG4gICAgcmV0dXJuO1xyXG4gIHJldHVybiBwYXJlbnQuX3hfaGlkZVByb21pc2UgPyBwYXJlbnQgOiBjbG9zZXN0SGlkZShwYXJlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zaXRpb24oZWwsIHNldEZ1bmN0aW9uLCB7IGR1cmluZywgc3RhcnQ6IHN0YXJ0MiwgZW5kIH0gPSB7fSwgYmVmb3JlID0gKCkgPT4ge1xyXG59LCBhZnRlciA9ICgpID0+IHtcclxufSkge1xyXG4gIGlmIChlbC5feF90cmFuc2l0aW9uaW5nKVxyXG4gICAgZWwuX3hfdHJhbnNpdGlvbmluZy5jYW5jZWwoKTtcclxuICBpZiAoT2JqZWN0LmtleXMoZHVyaW5nKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoc3RhcnQyKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoZW5kKS5sZW5ndGggPT09IDApIHtcclxuICAgIGJlZm9yZSgpO1xyXG4gICAgYWZ0ZXIoKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgbGV0IHVuZG9TdGFydCwgdW5kb0R1cmluZywgdW5kb0VuZDtcclxuICBwZXJmb3JtVHJhbnNpdGlvbihlbCwge1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgIHVuZG9TdGFydCA9IHNldEZ1bmN0aW9uKGVsLCBzdGFydDIpO1xyXG4gICAgfSxcclxuICAgIGR1cmluZygpIHtcclxuICAgICAgdW5kb0R1cmluZyA9IHNldEZ1bmN0aW9uKGVsLCBkdXJpbmcpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZSxcclxuICAgIGVuZCgpIHtcclxuICAgICAgdW5kb1N0YXJ0KCk7XHJcbiAgICAgIHVuZG9FbmQgPSBzZXRGdW5jdGlvbihlbCwgZW5kKTtcclxuICAgIH0sXHJcbiAgICBhZnRlcixcclxuICAgIGNsZWFudXAoKSB7XHJcbiAgICAgIHVuZG9EdXJpbmcoKTtcclxuICAgICAgdW5kb0VuZCgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHBlcmZvcm1UcmFuc2l0aW9uKGVsLCBzdGFnZXMpIHtcclxuICBsZXQgaW50ZXJydXB0ZWQsIHJlYWNoZWRCZWZvcmUsIHJlYWNoZWRFbmQ7XHJcbiAgbGV0IGZpbmlzaCA9IG9uY2UoKCkgPT4ge1xyXG4gICAgbXV0YXRlRG9tKCgpID0+IHtcclxuICAgICAgaW50ZXJydXB0ZWQgPSB0cnVlO1xyXG4gICAgICBpZiAoIXJlYWNoZWRCZWZvcmUpXHJcbiAgICAgICAgc3RhZ2VzLmJlZm9yZSgpO1xyXG4gICAgICBpZiAoIXJlYWNoZWRFbmQpIHtcclxuICAgICAgICBzdGFnZXMuZW5kKCk7XHJcbiAgICAgICAgcmVsZWFzZU5leHRUaWNrcygpO1xyXG4gICAgICB9XHJcbiAgICAgIHN0YWdlcy5hZnRlcigpO1xyXG4gICAgICBpZiAoZWwuaXNDb25uZWN0ZWQpXHJcbiAgICAgICAgc3RhZ2VzLmNsZWFudXAoKTtcclxuICAgICAgZGVsZXRlIGVsLl94X3RyYW5zaXRpb25pbmc7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICBlbC5feF90cmFuc2l0aW9uaW5nID0ge1xyXG4gICAgYmVmb3JlQ2FuY2VsczogW10sXHJcbiAgICBiZWZvcmVDYW5jZWwoY2FsbGJhY2spIHtcclxuICAgICAgdGhpcy5iZWZvcmVDYW5jZWxzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfSxcclxuICAgIGNhbmNlbDogb25jZShmdW5jdGlvbigpIHtcclxuICAgICAgd2hpbGUgKHRoaXMuYmVmb3JlQ2FuY2Vscy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmJlZm9yZUNhbmNlbHMuc2hpZnQoKSgpO1xyXG4gICAgICB9XHJcbiAgICAgIDtcclxuICAgICAgZmluaXNoKCk7XHJcbiAgICB9KSxcclxuICAgIGZpbmlzaFxyXG4gIH07XHJcbiAgbXV0YXRlRG9tKCgpID0+IHtcclxuICAgIHN0YWdlcy5zdGFydCgpO1xyXG4gICAgc3RhZ2VzLmR1cmluZygpO1xyXG4gIH0pO1xyXG4gIGhvbGROZXh0VGlja3MoKTtcclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgaWYgKGludGVycnVwdGVkKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBsZXQgZHVyYXRpb24gPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNpdGlvbkR1cmF0aW9uLnJlcGxhY2UoLywuKi8sIFwiXCIpLnJlcGxhY2UoXCJzXCIsIFwiXCIpKSAqIDFlMztcclxuICAgIGxldCBkZWxheSA9IE51bWJlcihnZXRDb21wdXRlZFN0eWxlKGVsKS50cmFuc2l0aW9uRGVsYXkucmVwbGFjZSgvLC4qLywgXCJcIikucmVwbGFjZShcInNcIiwgXCJcIikpICogMWUzO1xyXG4gICAgaWYgKGR1cmF0aW9uID09PSAwKVxyXG4gICAgICBkdXJhdGlvbiA9IE51bWJlcihnZXRDb21wdXRlZFN0eWxlKGVsKS5hbmltYXRpb25EdXJhdGlvbi5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XHJcbiAgICBtdXRhdGVEb20oKCkgPT4ge1xyXG4gICAgICBzdGFnZXMuYmVmb3JlKCk7XHJcbiAgICB9KTtcclxuICAgIHJlYWNoZWRCZWZvcmUgPSB0cnVlO1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgaWYgKGludGVycnVwdGVkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcclxuICAgICAgICBzdGFnZXMuZW5kKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZWxlYXNlTmV4dFRpY2tzKCk7XHJcbiAgICAgIHNldFRpbWVvdXQoZWwuX3hfdHJhbnNpdGlvbmluZy5maW5pc2gsIGR1cmF0aW9uICsgZGVsYXkpO1xyXG4gICAgICByZWFjaGVkRW5kID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBrZXksIGZhbGxiYWNrKSB7XHJcbiAgaWYgKG1vZGlmaWVycy5pbmRleE9mKGtleSkgPT09IC0xKVxyXG4gICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gIGNvbnN0IHJhd1ZhbHVlID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAxXTtcclxuICBpZiAoIXJhd1ZhbHVlKVxyXG4gICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gIGlmIChrZXkgPT09IFwic2NhbGVcIikge1xyXG4gICAgaWYgKGlzTmFOKHJhd1ZhbHVlKSlcclxuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gIH1cclxuICBpZiAoa2V5ID09PSBcImR1cmF0aW9uXCIpIHtcclxuICAgIGxldCBtYXRjaCA9IHJhd1ZhbHVlLm1hdGNoKC8oWzAtOV0rKW1zLyk7XHJcbiAgICBpZiAobWF0Y2gpXHJcbiAgICAgIHJldHVybiBtYXRjaFsxXTtcclxuICB9XHJcbiAgaWYgKGtleSA9PT0gXCJvcmlnaW5cIikge1xyXG4gICAgaWYgKFtcInRvcFwiLCBcInJpZ2h0XCIsIFwibGVmdFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwiXS5pbmNsdWRlcyhtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdKSkge1xyXG4gICAgICByZXR1cm4gW3Jhd1ZhbHVlLCBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdXS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJhd1ZhbHVlO1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvY2xvbmUuanNcclxudmFyIGlzQ2xvbmluZyA9IGZhbHNlO1xyXG5mdW5jdGlvbiBza2lwRHVyaW5nQ2xvbmUoY2FsbGJhY2ssIGZhbGxiYWNrID0gKCkgPT4ge1xyXG59KSB7XHJcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBpc0Nsb25pbmcgPyBmYWxsYmFjayguLi5hcmdzKSA6IGNhbGxiYWNrKC4uLmFyZ3MpO1xyXG59XHJcbmZ1bmN0aW9uIG9ubHlEdXJpbmdDbG9uZShjYWxsYmFjaykge1xyXG4gIHJldHVybiAoLi4uYXJncykgPT4gaXNDbG9uaW5nICYmIGNhbGxiYWNrKC4uLmFyZ3MpO1xyXG59XHJcbmZ1bmN0aW9uIGNsb25lKG9sZEVsLCBuZXdFbCkge1xyXG4gIGlmICghbmV3RWwuX3hfZGF0YVN0YWNrKVxyXG4gICAgbmV3RWwuX3hfZGF0YVN0YWNrID0gb2xkRWwuX3hfZGF0YVN0YWNrO1xyXG4gIGlzQ2xvbmluZyA9IHRydWU7XHJcbiAgZG9udFJlZ2lzdGVyUmVhY3RpdmVTaWRlRWZmZWN0cygoKSA9PiB7XHJcbiAgICBjbG9uZVRyZWUobmV3RWwpO1xyXG4gIH0pO1xyXG4gIGlzQ2xvbmluZyA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGNsb25lVHJlZShlbCkge1xyXG4gIGxldCBoYXNSdW5UaHJvdWdoRmlyc3RFbCA9IGZhbHNlO1xyXG4gIGxldCBzaGFsbG93V2Fsa2VyID0gKGVsMiwgY2FsbGJhY2spID0+IHtcclxuICAgIHdhbGsoZWwyLCAoZWwzLCBza2lwKSA9PiB7XHJcbiAgICAgIGlmIChoYXNSdW5UaHJvdWdoRmlyc3RFbCAmJiBpc1Jvb3QoZWwzKSlcclxuICAgICAgICByZXR1cm4gc2tpcCgpO1xyXG4gICAgICBoYXNSdW5UaHJvdWdoRmlyc3RFbCA9IHRydWU7XHJcbiAgICAgIGNhbGxiYWNrKGVsMywgc2tpcCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIGluaXRUcmVlKGVsLCBzaGFsbG93V2Fsa2VyKTtcclxufVxyXG5mdW5jdGlvbiBkb250UmVnaXN0ZXJSZWFjdGl2ZVNpZGVFZmZlY3RzKGNhbGxiYWNrKSB7XHJcbiAgbGV0IGNhY2hlID0gZWZmZWN0O1xyXG4gIG92ZXJyaWRlRWZmZWN0KChjYWxsYmFjazIsIGVsKSA9PiB7XHJcbiAgICBsZXQgc3RvcmVkRWZmZWN0ID0gY2FjaGUoY2FsbGJhY2syKTtcclxuICAgIHJlbGVhc2Uoc3RvcmVkRWZmZWN0KTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG4gIGNhbGxiYWNrKCk7XHJcbiAgb3ZlcnJpZGVFZmZlY3QoY2FjaGUpO1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvYmluZC5qc1xyXG5mdW5jdGlvbiBiaW5kKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzID0gW10pIHtcclxuICBpZiAoIWVsLl94X2JpbmRpbmdzKVxyXG4gICAgZWwuX3hfYmluZGluZ3MgPSByZWFjdGl2ZSh7fSk7XHJcbiAgZWwuX3hfYmluZGluZ3NbbmFtZV0gPSB2YWx1ZTtcclxuICBuYW1lID0gbW9kaWZpZXJzLmluY2x1ZGVzKFwiY2FtZWxcIikgPyBjYW1lbENhc2UobmFtZSkgOiBuYW1lO1xyXG4gIHN3aXRjaCAobmFtZSkge1xyXG4gICAgY2FzZSBcInZhbHVlXCI6XHJcbiAgICAgIGJpbmRJbnB1dFZhbHVlKGVsLCB2YWx1ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcInN0eWxlXCI6XHJcbiAgICAgIGJpbmRTdHlsZXMoZWwsIHZhbHVlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiY2xhc3NcIjpcclxuICAgICAgYmluZENsYXNzZXMoZWwsIHZhbHVlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBiaW5kQXR0cmlidXRlKGVsLCBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBiaW5kSW5wdXRWYWx1ZShlbCwgdmFsdWUpIHtcclxuICBpZiAoZWwudHlwZSA9PT0gXCJyYWRpb1wiKSB7XHJcbiAgICBpZiAoZWwuYXR0cmlidXRlcy52YWx1ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGVsLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAod2luZG93LmZyb21Nb2RlbCkge1xyXG4gICAgICBlbC5jaGVja2VkID0gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUoZWwudmFsdWUsIHZhbHVlKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGVsLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xyXG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XHJcbiAgICAgIGVsLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIiAmJiAhW251bGwsIHZvaWQgMF0uaW5jbHVkZXModmFsdWUpKSB7XHJcbiAgICAgIGVsLnZhbHVlID0gU3RyaW5nKHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5zb21lKCh2YWwpID0+IGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbCwgZWwudmFsdWUpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gISF2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoZWwudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xyXG4gICAgdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChlbC52YWx1ZSA9PT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuICAgIGVsLnZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGJpbmRDbGFzc2VzKGVsLCB2YWx1ZSkge1xyXG4gIGlmIChlbC5feF91bmRvQWRkZWRDbGFzc2VzKVxyXG4gICAgZWwuX3hfdW5kb0FkZGVkQ2xhc3NlcygpO1xyXG4gIGVsLl94X3VuZG9BZGRlZENsYXNzZXMgPSBzZXRDbGFzc2VzKGVsLCB2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gYmluZFN0eWxlcyhlbCwgdmFsdWUpIHtcclxuICBpZiAoZWwuX3hfdW5kb0FkZGVkU3R5bGVzKVxyXG4gICAgZWwuX3hfdW5kb0FkZGVkU3R5bGVzKCk7XHJcbiAgZWwuX3hfdW5kb0FkZGVkU3R5bGVzID0gc2V0U3R5bGVzKGVsLCB2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpIHtcclxuICBpZiAoW251bGwsIHZvaWQgMCwgZmFsc2VdLmluY2x1ZGVzKHZhbHVlKSAmJiBhdHRyaWJ1dGVTaG91bGRudEJlUHJlc2VydmVkSWZGYWxzeShuYW1lKSkge1xyXG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoaXNCb29sZWFuQXR0cihuYW1lKSlcclxuICAgICAgdmFsdWUgPSBuYW1lO1xyXG4gICAgc2V0SWZDaGFuZ2VkKGVsLCBuYW1lLCB2YWx1ZSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldElmQ2hhbmdlZChlbCwgYXR0ck5hbWUsIHZhbHVlKSB7XHJcbiAgaWYgKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgIT0gdmFsdWUpIHtcclxuICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsdWUpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB1cGRhdGVTZWxlY3QoZWwsIHZhbHVlKSB7XHJcbiAgY29uc3QgYXJyYXlXcmFwcGVkVmFsdWUgPSBbXS5jb25jYXQodmFsdWUpLm1hcCgodmFsdWUyKSA9PiB7XHJcbiAgICByZXR1cm4gdmFsdWUyICsgXCJcIjtcclxuICB9KTtcclxuICBBcnJheS5mcm9tKGVsLm9wdGlvbnMpLmZvckVhY2goKG9wdGlvbikgPT4ge1xyXG4gICAgb3B0aW9uLnNlbGVjdGVkID0gYXJyYXlXcmFwcGVkVmFsdWUuaW5jbHVkZXMob3B0aW9uLnZhbHVlKTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjYW1lbENhc2Uoc3ViamVjdCkge1xyXG4gIHJldHVybiBzdWJqZWN0LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShcXHcpL2csIChtYXRjaCwgY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpKTtcclxufVxyXG5mdW5jdGlvbiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZSh2YWx1ZUEsIHZhbHVlQikge1xyXG4gIHJldHVybiB2YWx1ZUEgPT0gdmFsdWVCO1xyXG59XHJcbmZ1bmN0aW9uIGlzQm9vbGVhbkF0dHIoYXR0ck5hbWUpIHtcclxuICBjb25zdCBib29sZWFuQXR0cmlidXRlcyA9IFtcclxuICAgIFwiZGlzYWJsZWRcIixcclxuICAgIFwiY2hlY2tlZFwiLFxyXG4gICAgXCJyZXF1aXJlZFwiLFxyXG4gICAgXCJyZWFkb25seVwiLFxyXG4gICAgXCJoaWRkZW5cIixcclxuICAgIFwib3BlblwiLFxyXG4gICAgXCJzZWxlY3RlZFwiLFxyXG4gICAgXCJhdXRvZm9jdXNcIixcclxuICAgIFwiaXRlbXNjb3BlXCIsXHJcbiAgICBcIm11bHRpcGxlXCIsXHJcbiAgICBcIm5vdmFsaWRhdGVcIixcclxuICAgIFwiYWxsb3dmdWxsc2NyZWVuXCIsXHJcbiAgICBcImFsbG93cGF5bWVudHJlcXVlc3RcIixcclxuICAgIFwiZm9ybW5vdmFsaWRhdGVcIixcclxuICAgIFwiYXV0b3BsYXlcIixcclxuICAgIFwiY29udHJvbHNcIixcclxuICAgIFwibG9vcFwiLFxyXG4gICAgXCJtdXRlZFwiLFxyXG4gICAgXCJwbGF5c2lubGluZVwiLFxyXG4gICAgXCJkZWZhdWx0XCIsXHJcbiAgICBcImlzbWFwXCIsXHJcbiAgICBcInJldmVyc2VkXCIsXHJcbiAgICBcImFzeW5jXCIsXHJcbiAgICBcImRlZmVyXCIsXHJcbiAgICBcIm5vbW9kdWxlXCJcclxuICBdO1xyXG4gIHJldHVybiBib29sZWFuQXR0cmlidXRlcy5pbmNsdWRlcyhhdHRyTmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gYXR0cmlidXRlU2hvdWxkbnRCZVByZXNlcnZlZElmRmFsc3kobmFtZSkge1xyXG4gIHJldHVybiAhW1wiYXJpYS1wcmVzc2VkXCIsIFwiYXJpYS1jaGVja2VkXCIsIFwiYXJpYS1leHBhbmRlZFwiLCBcImFyaWEtc2VsZWN0ZWRcIl0uaW5jbHVkZXMobmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QmluZGluZyhlbCwgbmFtZSwgZmFsbGJhY2spIHtcclxuICBpZiAoZWwuX3hfYmluZGluZ3MgJiYgZWwuX3hfYmluZGluZ3NbbmFtZV0gIT09IHZvaWQgMClcclxuICAgIHJldHVybiBlbC5feF9iaW5kaW5nc1tuYW1lXTtcclxuICBsZXQgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcclxuICBpZiAoYXR0ciA9PT0gbnVsbClcclxuICAgIHJldHVybiB0eXBlb2YgZmFsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiA/IGZhbGxiYWNrKCkgOiBmYWxsYmFjaztcclxuICBpZiAoYXR0ciA9PT0gXCJcIilcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIGlmIChpc0Jvb2xlYW5BdHRyKG5hbWUpKSB7XHJcbiAgICByZXR1cm4gISFbbmFtZSwgXCJ0cnVlXCJdLmluY2x1ZGVzKGF0dHIpO1xyXG4gIH1cclxuICByZXR1cm4gYXR0cjtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2RlYm91bmNlLmpzXHJcbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcclxuICB2YXIgdGltZW91dDtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy90aHJvdHRsZS5qc1xyXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCBsaW1pdCkge1xyXG4gIGxldCBpblRocm90dGxlO1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIGxldCBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcclxuICAgIGlmICghaW5UaHJvdHRsZSkge1xyXG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICBpblRocm90dGxlID0gdHJ1ZTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiBpblRocm90dGxlID0gZmFsc2UsIGxpbWl0KTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvcGx1Z2luLmpzXHJcbmZ1bmN0aW9uIHBsdWdpbihjYWxsYmFjaykge1xyXG4gIGNhbGxiYWNrKGFscGluZV9kZWZhdWx0KTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3N0b3JlLmpzXHJcbnZhciBzdG9yZXMgPSB7fTtcclxudmFyIGlzUmVhY3RpdmUgPSBmYWxzZTtcclxuZnVuY3Rpb24gc3RvcmUobmFtZSwgdmFsdWUpIHtcclxuICBpZiAoIWlzUmVhY3RpdmUpIHtcclxuICAgIHN0b3JlcyA9IHJlYWN0aXZlKHN0b3Jlcyk7XHJcbiAgICBpc1JlYWN0aXZlID0gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcclxuICAgIHJldHVybiBzdG9yZXNbbmFtZV07XHJcbiAgfVxyXG4gIHN0b3Jlc1tuYW1lXSA9IHZhbHVlO1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoXCJpbml0XCIpICYmIHR5cGVvZiB2YWx1ZS5pbml0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIHN0b3Jlc1tuYW1lXS5pbml0KCk7XHJcbiAgfVxyXG4gIGluaXRJbnRlcmNlcHRvcnMoc3RvcmVzW25hbWVdKTtcclxufVxyXG5mdW5jdGlvbiBnZXRTdG9yZXMoKSB7XHJcbiAgcmV0dXJuIHN0b3JlcztcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2JpbmRzLmpzXHJcbnZhciBiaW5kcyA9IHt9O1xyXG5mdW5jdGlvbiBiaW5kMihuYW1lLCBiaW5kaW5ncykge1xyXG4gIGxldCBnZXRCaW5kaW5ncyA9IHR5cGVvZiBiaW5kaW5ncyAhPT0gXCJmdW5jdGlvblwiID8gKCkgPT4gYmluZGluZ3MgOiBiaW5kaW5ncztcclxuICBpZiAobmFtZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcclxuICAgIGFwcGx5QmluZGluZ3NPYmplY3QobmFtZSwgZ2V0QmluZGluZ3MoKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGJpbmRzW25hbWVdID0gZ2V0QmluZGluZ3M7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdEJpbmRpbmdQcm92aWRlcnMob2JqKSB7XHJcbiAgT2JqZWN0LmVudHJpZXMoYmluZHMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcclxuICAgICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlCaW5kaW5nc09iamVjdChlbCwgb2JqLCBvcmlnaW5hbCkge1xyXG4gIGxldCBjbGVhbnVwUnVubmVycyA9IFtdO1xyXG4gIHdoaWxlIChjbGVhbnVwUnVubmVycy5sZW5ndGgpXHJcbiAgICBjbGVhbnVwUnVubmVycy5wb3AoKSgpO1xyXG4gIGxldCBhdHRyaWJ1dGVzID0gT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+ICh7IG5hbWUsIHZhbHVlIH0pKTtcclxuICBsZXQgc3RhdGljQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNPbmx5KGF0dHJpYnV0ZXMpO1xyXG4gIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLm1hcCgoYXR0cmlidXRlKSA9PiB7XHJcbiAgICBpZiAoc3RhdGljQXR0cmlidXRlcy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09IGF0dHJpYnV0ZS5uYW1lKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IGB4LWJpbmQ6JHthdHRyaWJ1dGUubmFtZX1gLFxyXG4gICAgICAgIHZhbHVlOiBgXCIke2F0dHJpYnV0ZS52YWx1ZX1cImBcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBhdHRyaWJ1dGU7XHJcbiAgfSk7XHJcbiAgZGlyZWN0aXZlcyhlbCwgYXR0cmlidXRlcywgb3JpZ2luYWwpLm1hcCgoaGFuZGxlKSA9PiB7XHJcbiAgICBjbGVhbnVwUnVubmVycy5wdXNoKGhhbmRsZS5ydW5DbGVhbnVwcyk7XHJcbiAgICBoYW5kbGUoKTtcclxuICB9KTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RhdGFzLmpzXHJcbnZhciBkYXRhcyA9IHt9O1xyXG5mdW5jdGlvbiBkYXRhKG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgZGF0YXNbbmFtZV0gPSBjYWxsYmFjaztcclxufVxyXG5mdW5jdGlvbiBpbmplY3REYXRhUHJvdmlkZXJzKG9iaiwgY29udGV4dCkge1xyXG4gIE9iamVjdC5lbnRyaWVzKGRhdGFzKS5mb3JFYWNoKChbbmFtZSwgY2FsbGJhY2tdKSA9PiB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XHJcbiAgICAgIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5iaW5kKGNvbnRleHQpKC4uLmFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvYWxwaW5lLmpzXHJcbnZhciBBbHBpbmUgPSB7XHJcbiAgZ2V0IHJlYWN0aXZlKCkge1xyXG4gICAgcmV0dXJuIHJlYWN0aXZlO1xyXG4gIH0sXHJcbiAgZ2V0IHJlbGVhc2UoKSB7XHJcbiAgICByZXR1cm4gcmVsZWFzZTtcclxuICB9LFxyXG4gIGdldCBlZmZlY3QoKSB7XHJcbiAgICByZXR1cm4gZWZmZWN0O1xyXG4gIH0sXHJcbiAgZ2V0IHJhdygpIHtcclxuICAgIHJldHVybiByYXc7XHJcbiAgfSxcclxuICB2ZXJzaW9uOiBcIjMuMTIuMFwiLFxyXG4gIGZsdXNoQW5kU3RvcERlZmVycmluZ011dGF0aW9ucyxcclxuICBkb250QXV0b0V2YWx1YXRlRnVuY3Rpb25zLFxyXG4gIGRpc2FibGVFZmZlY3RTY2hlZHVsaW5nLFxyXG4gIHN0YXJ0T2JzZXJ2aW5nTXV0YXRpb25zLFxyXG4gIHN0b3BPYnNlcnZpbmdNdXRhdGlvbnMsXHJcbiAgc2V0UmVhY3Rpdml0eUVuZ2luZSxcclxuICBjbG9zZXN0RGF0YVN0YWNrLFxyXG4gIHNraXBEdXJpbmdDbG9uZSxcclxuICBvbmx5RHVyaW5nQ2xvbmUsXHJcbiAgYWRkUm9vdFNlbGVjdG9yLFxyXG4gIGFkZEluaXRTZWxlY3RvcixcclxuICBhZGRTY29wZVRvTm9kZSxcclxuICBkZWZlck11dGF0aW9ucyxcclxuICBtYXBBdHRyaWJ1dGVzLFxyXG4gIGV2YWx1YXRlTGF0ZXIsXHJcbiAgaW50ZXJjZXB0SW5pdCxcclxuICBzZXRFdmFsdWF0b3IsXHJcbiAgbWVyZ2VQcm94aWVzLFxyXG4gIGZpbmRDbG9zZXN0LFxyXG4gIGNsb3Nlc3RSb290LFxyXG4gIGRlc3Ryb3lUcmVlLFxyXG4gIGludGVyY2VwdG9yLFxyXG4gIC8vIElOVEVSTkFMOiBub3QgcHVibGljIEFQSSBhbmQgaXMgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBtYWpvciByZWxlYXNlLlxyXG4gIHRyYW5zaXRpb24sXHJcbiAgLy8gSU5URVJOQUxcclxuICBzZXRTdHlsZXMsXHJcbiAgLy8gSU5URVJOQUxcclxuICBtdXRhdGVEb20sXHJcbiAgZGlyZWN0aXZlLFxyXG4gIHRocm90dGxlLFxyXG4gIGRlYm91bmNlLFxyXG4gIGV2YWx1YXRlLFxyXG4gIGluaXRUcmVlLFxyXG4gIG5leHRUaWNrLFxyXG4gIHByZWZpeGVkOiBwcmVmaXgsXHJcbiAgcHJlZml4OiBzZXRQcmVmaXgsXHJcbiAgcGx1Z2luLFxyXG4gIG1hZ2ljLFxyXG4gIHN0b3JlLFxyXG4gIHN0YXJ0LFxyXG4gIGNsb25lLFxyXG4gIGJvdW5kOiBnZXRCaW5kaW5nLFxyXG4gICRkYXRhOiBzY29wZSxcclxuICB3YWxrLFxyXG4gIGRhdGEsXHJcbiAgYmluZDogYmluZDJcclxufTtcclxudmFyIGFscGluZV9kZWZhdWx0ID0gQWxwaW5lO1xyXG5cclxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzXHJcbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XHJcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdChcIixcIik7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/ICh2YWwpID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6ICh2YWwpID0+ICEhbWFwW3ZhbF07XHJcbn1cclxudmFyIHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcclxudmFyIGlzQm9vbGVhbkF0dHIyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xyXG52YXIgRU1QVFlfT0JKID0gdHJ1ZSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XHJcbnZhciBFTVBUWV9BUlIgPSB0cnVlID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcclxudmFyIGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbnZhciBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbnZhciBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xyXG52YXIgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xyXG52YXIgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xyXG52YXIgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcclxudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxudmFyIHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcbnZhciB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcclxuICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XHJcbn07XHJcbnZhciBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmIGtleSAhPT0gXCJOYU5cIiAmJiBrZXlbMF0gIT09IFwiLVwiICYmIFwiXCIgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xyXG52YXIgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgcmV0dXJuIChzdHIpID0+IHtcclxuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgfTtcclxufTtcclxudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XHJcbnZhciBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCIpO1xyXG59KTtcclxudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcclxudmFyIGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xyXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcclxudmFyIHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKTtcclxudmFyIGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiB2YWx1ZSAhPT0gb2xkVmFsdWUgJiYgKHZhbHVlID09PSB2YWx1ZSB8fCBvbGRWYWx1ZSA9PT0gb2xkVmFsdWUpO1xyXG5cclxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuZXNtLWJ1bmRsZXIuanNcclxudmFyIHRhcmdldE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xyXG52YXIgZWZmZWN0U3RhY2sgPSBbXTtcclxudmFyIGFjdGl2ZUVmZmVjdDtcclxudmFyIElURVJBVEVfS0VZID0gU3ltYm9sKHRydWUgPyBcIml0ZXJhdGVcIiA6IFwiXCIpO1xyXG52YXIgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCh0cnVlID8gXCJNYXAga2V5IGl0ZXJhdGVcIiA6IFwiXCIpO1xyXG5mdW5jdGlvbiBpc0VmZmVjdChmbikge1xyXG4gIHJldHVybiBmbiAmJiBmbi5faXNFZmZlY3QgPT09IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZWZmZWN0Mihmbiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xyXG4gIGlmIChpc0VmZmVjdChmbikpIHtcclxuICAgIGZuID0gZm4ucmF3O1xyXG4gIH1cclxuICBjb25zdCBlZmZlY3QzID0gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpO1xyXG4gIGlmICghb3B0aW9ucy5sYXp5KSB7XHJcbiAgICBlZmZlY3QzKCk7XHJcbiAgfVxyXG4gIHJldHVybiBlZmZlY3QzO1xyXG59XHJcbmZ1bmN0aW9uIHN0b3AoZWZmZWN0Mykge1xyXG4gIGlmIChlZmZlY3QzLmFjdGl2ZSkge1xyXG4gICAgY2xlYW51cChlZmZlY3QzKTtcclxuICAgIGlmIChlZmZlY3QzLm9wdGlvbnMub25TdG9wKSB7XHJcbiAgICAgIGVmZmVjdDMub3B0aW9ucy5vblN0b3AoKTtcclxuICAgIH1cclxuICAgIGVmZmVjdDMuYWN0aXZlID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcbnZhciB1aWQgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucykge1xyXG4gIGNvbnN0IGVmZmVjdDMgPSBmdW5jdGlvbiByZWFjdGl2ZUVmZmVjdCgpIHtcclxuICAgIGlmICghZWZmZWN0My5hY3RpdmUpIHtcclxuICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWVmZmVjdFN0YWNrLmluY2x1ZGVzKGVmZmVjdDMpKSB7XHJcbiAgICAgIGNsZWFudXAoZWZmZWN0Myk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZW5hYmxlVHJhY2tpbmcoKTtcclxuICAgICAgICBlZmZlY3RTdGFjay5wdXNoKGVmZmVjdDMpO1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdDM7XHJcbiAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgZWZmZWN0U3RhY2sucG9wKCk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdFN0YWNrW2VmZmVjdFN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICBlZmZlY3QzLmlkID0gdWlkKys7XHJcbiAgZWZmZWN0My5hbGxvd1JlY3Vyc2UgPSAhIW9wdGlvbnMuYWxsb3dSZWN1cnNlO1xyXG4gIGVmZmVjdDMuX2lzRWZmZWN0ID0gdHJ1ZTtcclxuICBlZmZlY3QzLmFjdGl2ZSA9IHRydWU7XHJcbiAgZWZmZWN0My5yYXcgPSBmbjtcclxuICBlZmZlY3QzLmRlcHMgPSBbXTtcclxuICBlZmZlY3QzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gIHJldHVybiBlZmZlY3QzO1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFudXAoZWZmZWN0Mykge1xyXG4gIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0MztcclxuICBpZiAoZGVwcy5sZW5ndGgpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBkZXBzW2ldLmRlbGV0ZShlZmZlY3QzKTtcclxuICAgIH1cclxuICAgIGRlcHMubGVuZ3RoID0gMDtcclxuICB9XHJcbn1cclxudmFyIHNob3VsZFRyYWNrID0gdHJ1ZTtcclxudmFyIHRyYWNrU3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcclxuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XHJcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICBzaG91bGRUcmFjayA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcclxuICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcclxuICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XHJcbiAgaWYgKCFzaG91bGRUcmFjayB8fCBhY3RpdmVFZmZlY3QgPT09IHZvaWQgMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBsZXQgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICBpZiAoIWRlcHNNYXApIHtcclxuICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCBkZXBzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XHJcbiAgfVxyXG4gIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xyXG4gIGlmICghZGVwKSB7XHJcbiAgICBkZXBzTWFwLnNldChrZXksIGRlcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xyXG4gIH1cclxuICBpZiAoIWRlcC5oYXMoYWN0aXZlRWZmZWN0KSkge1xyXG4gICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xyXG4gICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xyXG4gICAgaWYgKGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2spIHtcclxuICAgICAgYWN0aXZlRWZmZWN0Lm9wdGlvbnMub25UcmFjayh7XHJcbiAgICAgICAgZWZmZWN0OiBhY3RpdmVFZmZlY3QsXHJcbiAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAga2V5XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xyXG4gIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgaWYgKCFkZXBzTWFwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IGVmZmVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xyXG4gIGNvbnN0IGFkZDIgPSAoZWZmZWN0c1RvQWRkKSA9PiB7XHJcbiAgICBpZiAoZWZmZWN0c1RvQWRkKSB7XHJcbiAgICAgIGVmZmVjdHNUb0FkZC5mb3JFYWNoKChlZmZlY3QzKSA9PiB7XHJcbiAgICAgICAgaWYgKGVmZmVjdDMgIT09IGFjdGl2ZUVmZmVjdCB8fCBlZmZlY3QzLmFsbG93UmVjdXJzZSkge1xyXG4gICAgICAgICAgZWZmZWN0cy5hZGQoZWZmZWN0Myk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcclxuICAgIGRlcHNNYXAuZm9yRWFjaChhZGQyKTtcclxuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsZW5ndGhcIiAmJiBpc0FycmF5KHRhcmdldCkpIHtcclxuICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkyKSA9PiB7XHJcbiAgICAgIGlmIChrZXkyID09PSBcImxlbmd0aFwiIHx8IGtleTIgPj0gbmV3VmFsdWUpIHtcclxuICAgICAgICBhZGQyKGRlcCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcclxuICAgICAgYWRkMihkZXBzTWFwLmdldChrZXkpKTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlIFwiYWRkXCI6XHJcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNJbnRlZ2VyS2V5KGtleSkpIHtcclxuICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoXCJsZW5ndGhcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcImRlbGV0ZVwiOlxyXG4gICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJzZXRcIjpcclxuICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgYWRkMihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgcnVuID0gKGVmZmVjdDMpID0+IHtcclxuICAgIGlmIChlZmZlY3QzLm9wdGlvbnMub25UcmlnZ2VyKSB7XHJcbiAgICAgIGVmZmVjdDMub3B0aW9ucy5vblRyaWdnZXIoe1xyXG4gICAgICAgIGVmZmVjdDogZWZmZWN0MyxcclxuICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAga2V5LFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgb2xkVmFsdWUsXHJcbiAgICAgICAgb2xkVGFyZ2V0XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGVmZmVjdDMub3B0aW9ucy5zY2hlZHVsZXIpIHtcclxuICAgICAgZWZmZWN0My5vcHRpb25zLnNjaGVkdWxlcihlZmZlY3QzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVmZmVjdDMoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGVmZmVjdHMuZm9yRWFjaChydW4pO1xyXG59XHJcbnZhciBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XHJcbnZhciBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5tYXAoKGtleSkgPT4gU3ltYm9sW2tleV0pLmZpbHRlcihpc1N5bWJvbCkpO1xyXG52YXIgZ2V0MiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIoKTtcclxudmFyIHNoYWxsb3dHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcclxudmFyIHJlYWRvbmx5R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcih0cnVlKTtcclxudmFyIHNoYWxsb3dSZWFkb25seUdldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XHJcbnZhciBhcnJheUluc3RydW1lbnRhdGlvbnMgPSB7fTtcclxuW1wiaW5jbHVkZXNcIiwgXCJpbmRleE9mXCIsIFwibGFzdEluZGV4T2ZcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XHJcbiAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XHJcbiAgICBjb25zdCBhcnIgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgdHJhY2soYXJyLCBcImdldFwiLCBpICsgXCJcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkoYXJyLCBhcmdzKTtcclxuICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShhcnIsIGFyZ3MubWFwKHRvUmF3KSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pO1xyXG5bXCJwdXNoXCIsIFwicG9wXCIsIFwic2hpZnRcIiwgXCJ1bnNoaWZ0XCIsIFwic3BsaWNlXCJdLmZvckVhY2goKGtleSkgPT4ge1xyXG4gIGNvbnN0IG1ldGhvZCA9IEFycmF5LnByb3RvdHlwZVtrZXldO1xyXG4gIGFycmF5SW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24oLi4uYXJncykge1xyXG4gICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgY29uc3QgcmVzID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgcmV0dXJuIHJlcztcclxuICB9O1xyXG59KTtcclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldDModGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcclxuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xyXG4gICAgICByZXR1cm4gaXNSZWFkb25seTtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAmJiByZWNlaXZlciA9PT0gKGlzUmVhZG9ubHkgPyBzaGFsbG93ID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBzaGFsbG93ID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XHJcbiAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xyXG4gICAgaWYgKCFpc1JlYWRvbmx5ICYmIHRhcmdldElzQXJyYXkgJiYgaGFzT3duKGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5KSkge1xyXG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGlmICghaXNSZWFkb25seSkge1xyXG4gICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIGtleSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhbGxvdykge1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUmVmKHJlcykpIHtcclxuICAgICAgY29uc3Qgc2hvdWxkVW53cmFwID0gIXRhcmdldElzQXJyYXkgfHwgIWlzSW50ZWdlcktleShrZXkpO1xyXG4gICAgICByZXR1cm4gc2hvdWxkVW53cmFwID8gcmVzLnZhbHVlIDogcmVzO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcclxuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUyKHJlcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH07XHJcbn1cclxudmFyIHNldDIgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2V0dGVyKCk7XHJcbnZhciBzaGFsbG93U2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNldHRlcih0cnVlKTtcclxuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbiBzZXQzKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcclxuICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgaWYgKCFzaGFsbG93KSB7XHJcbiAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcclxuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYWRLZXkgPSBpc0FycmF5KHRhcmdldCkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGggOiBoYXNPd24odGFyZ2V0LCBrZXkpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcclxuICAgICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcclxuICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xyXG4gIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XHJcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcclxuICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XHJcbiAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xyXG4gICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XHJcbiAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiwgaXNBcnJheSh0YXJnZXQpID8gXCJsZW5ndGhcIiA6IElURVJBVEVfS0VZKTtcclxuICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XHJcbn1cclxudmFyIG11dGFibGVIYW5kbGVycyA9IHtcclxuICBnZXQ6IGdldDIsXHJcbiAgc2V0OiBzZXQyLFxyXG4gIGRlbGV0ZVByb3BlcnR5LFxyXG4gIGhhcyxcclxuICBvd25LZXlzXHJcbn07XHJcbnZhciByZWFkb25seUhhbmRsZXJzID0ge1xyXG4gIGdldDogcmVhZG9ubHlHZXQsXHJcbiAgc2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICBpZiAodHJ1ZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgaWYgKHRydWUpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxufTtcclxudmFyIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzID0gZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcclxuICBnZXQ6IHNoYWxsb3dHZXQsXHJcbiAgc2V0OiBzaGFsbG93U2V0XHJcbn0pO1xyXG52YXIgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSBleHRlbmQoe30sIHJlYWRvbmx5SGFuZGxlcnMsIHtcclxuICBnZXQ6IHNoYWxsb3dSZWFkb25seUdldFxyXG59KTtcclxudmFyIHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlMih2YWx1ZSkgOiB2YWx1ZTtcclxudmFyIHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xyXG52YXIgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcclxudmFyIGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XHJcbmZ1bmN0aW9uIGdldCQxKHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgdGFyZ2V0ID0gdGFyZ2V0W1xyXG4gICAgXCJfX3ZfcmF3XCJcclxuICAgIC8qIFJBVyAqL1xyXG4gIF07XHJcbiAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xyXG4gIH1cclxuICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIHJhd0tleSk7XHJcbiAgY29uc3QgeyBoYXM6IGhhczIgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XHJcbiAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICBpZiAoaGFzMi5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xyXG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcclxuICB9IGVsc2UgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcclxuICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XHJcbiAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xyXG4gICAgdGFyZ2V0LmdldChrZXkpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBoYXMkMShrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gIGNvbnN0IHRhcmdldCA9IHRoaXNbXHJcbiAgICBcIl9fdl9yYXdcIlxyXG4gICAgLyogUkFXICovXHJcbiAgXTtcclxuICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XHJcbiAgfVxyXG4gICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwgcmF3S2V5KTtcclxuICByZXR1cm4ga2V5ID09PSByYXdLZXkgPyB0YXJnZXQuaGFzKGtleSkgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcclxuICB0YXJnZXQgPSB0YXJnZXRbXHJcbiAgICBcIl9fdl9yYXdcIlxyXG4gICAgLyogUkFXICovXHJcbiAgXTtcclxuICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xyXG4gIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xyXG4gIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcclxuICBpZiAoIWhhZEtleSkge1xyXG4gICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XHJcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwgdmFsdWUsIHZhbHVlKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gc2V0JDEoa2V5LCB2YWx1ZSkge1xyXG4gIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gIGNvbnN0IHsgaGFzOiBoYXMyLCBnZXQ6IGdldDMgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgaWYgKCFoYWRLZXkpIHtcclxuICAgIGtleSA9IHRvUmF3KGtleSk7XHJcbiAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gIH0gZWxzZSBpZiAodHJ1ZSkge1xyXG4gICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpO1xyXG4gIH1cclxuICBjb25zdCBvbGRWYWx1ZSA9IGdldDMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcclxuICBpZiAoIWhhZEtleSkge1xyXG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xyXG4gIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcclxuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICBjb25zdCB7IGhhczogaGFzMiwgZ2V0OiBnZXQzIH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gIGxldCBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gIGlmICghaGFkS2V5KSB7XHJcbiAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcclxuICB9IGVsc2UgaWYgKHRydWUpIHtcclxuICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KTtcclxuICB9XHJcbiAgY29uc3Qgb2xkVmFsdWUgPSBnZXQzID8gZ2V0My5jYWxsKHRhcmdldCwga2V5KSA6IHZvaWQgMDtcclxuICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XHJcbiAgaWYgKGhhZEtleSkge1xyXG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcclxuICBjb25zdCBvbGRUYXJnZXQgPSB0cnVlID8gaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KSA6IHZvaWQgMDtcclxuICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcclxuICBpZiAoaGFkSXRlbXMpIHtcclxuICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIsIHZvaWQgMCwgdm9pZCAwLCBvbGRUYXJnZXQpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcclxuICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1xyXG4gICAgICBcIl9fdl9yYXdcIlxyXG4gICAgICAvKiBSQVcgKi9cclxuICAgIF07XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcclxuICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXHJcbiAgICAgIFwiX192X3Jhd1wiXHJcbiAgICAgIC8qIFJBVyAqL1xyXG4gICAgXTtcclxuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XHJcbiAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09IFwiZW50cmllc1wiIHx8IG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwO1xyXG4gICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSBcImtleXNcIiAmJiB0YXJnZXRJc01hcDtcclxuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcclxuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiLCBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcclxuICAgICAgbmV4dCgpIHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICByZXR1cm4gZG9uZSA/IHsgdmFsdWUsIGRvbmUgfSA6IHtcclxuICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxyXG4gICAgICAgICAgZG9uZVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXHJcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XHJcbiAgICBpZiAodHJ1ZSkge1xyXG4gICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XHJcbiAgICAgIGNvbnNvbGUud2FybihgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcodGhpcykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgPyBmYWxzZSA6IHRoaXM7XHJcbiAgfTtcclxufVxyXG52YXIgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgZ2V0KGtleSkge1xyXG4gICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSk7XHJcbiAgfSxcclxuICBnZXQgc2l6ZSgpIHtcclxuICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gIH0sXHJcbiAgaGFzOiBoYXMkMSxcclxuICBhZGQsXHJcbiAgc2V0OiBzZXQkMSxcclxuICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gIGNsZWFyLFxyXG4gIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxyXG59O1xyXG52YXIgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgZ2V0KGtleSkge1xyXG4gICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xyXG4gIH0sXHJcbiAgZ2V0IHNpemUoKSB7XHJcbiAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICB9LFxyXG4gIGhhczogaGFzJDEsXHJcbiAgYWRkLFxyXG4gIHNldDogc2V0JDEsXHJcbiAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICBjbGVhcixcclxuICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxyXG59O1xyXG52YXIgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gIGdldChrZXkpIHtcclxuICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUpO1xyXG4gIH0sXHJcbiAgZ2V0IHNpemUoKSB7XHJcbiAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcclxuICB9LFxyXG4gIGhhcyhrZXkpIHtcclxuICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgfSxcclxuICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFxyXG4gICAgXCJhZGRcIlxyXG4gICAgLyogQUREICovXHJcbiAgKSxcclxuICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFxyXG4gICAgXCJzZXRcIlxyXG4gICAgLyogU0VUICovXHJcbiAgKSxcclxuICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFxyXG4gICAgXCJkZWxldGVcIlxyXG4gICAgLyogREVMRVRFICovXHJcbiAgKSxcclxuICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXHJcbiAgICBcImNsZWFyXCJcclxuICAgIC8qIENMRUFSICovXHJcbiAgKSxcclxuICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxyXG59O1xyXG52YXIgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICBnZXQoa2V5KSB7XHJcbiAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcclxuICB9LFxyXG4gIGdldCBzaXplKCkge1xyXG4gICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XHJcbiAgfSxcclxuICBoYXMoa2V5KSB7XHJcbiAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xyXG4gIH0sXHJcbiAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcclxuICAgIFwiYWRkXCJcclxuICAgIC8qIEFERCAqL1xyXG4gICksXHJcbiAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcclxuICAgIFwic2V0XCJcclxuICAgIC8qIFNFVCAqL1xyXG4gICksXHJcbiAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcclxuICAgIFwiZGVsZXRlXCJcclxuICAgIC8qIERFTEVURSAqL1xyXG4gICksXHJcbiAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFxyXG4gICAgXCJjbGVhclwiXHJcbiAgICAvKiBDTEVBUiAqL1xyXG4gICksXHJcbiAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxyXG59O1xyXG52YXIgaXRlcmF0b3JNZXRob2RzID0gW1wia2V5c1wiLCBcInZhbHVlc1wiLCBcImVudHJpZXNcIiwgU3ltYm9sLml0ZXJhdG9yXTtcclxuaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xyXG4gIG11dGFibGVJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCBmYWxzZSk7XHJcbiAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIGZhbHNlKTtcclxuICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCB0cnVlKTtcclxufSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XHJcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHNoYWxsb3cgPyBpc1JlYWRvbmx5ID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zIDogaXNSZWFkb25seSA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xyXG4gIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XHJcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcclxuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xyXG4gICAgICByZXR1cm4gaXNSZWFkb25seTtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xyXG4gICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXQgPyBpbnN0cnVtZW50YXRpb25zIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcclxuICB9O1xyXG59XHJcbnZhciBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcclxufTtcclxudmFyIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXHJcbn07XHJcbnZhciByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcclxufTtcclxudmFyIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxyXG59O1xyXG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSkge1xyXG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhczIuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcclxuICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodGFyZ2V0KTtcclxuICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYCk7XHJcbiAgfVxyXG59XHJcbnZhciByZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xyXG52YXIgc2hhbGxvd1JlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XHJcbnZhciByZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xyXG52YXIgc2hhbGxvd1JlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xyXG4gIHN3aXRjaCAocmF3VHlwZSkge1xyXG4gICAgY2FzZSBcIk9iamVjdFwiOlxyXG4gICAgY2FzZSBcIkFycmF5XCI6XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgY2FzZSBcIk1hcFwiOlxyXG4gICAgY2FzZSBcIlNldFwiOlxyXG4gICAgY2FzZSBcIldlYWtNYXBcIjpcclxuICAgIGNhc2UgXCJXZWFrU2V0XCI6XHJcbiAgICAgIHJldHVybiAyO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWVbXHJcbiAgICBcIl9fdl9za2lwXCJcclxuICAgIC8qIFNLSVAgKi9cclxuICBdIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSA/IDAgOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWN0aXZlMih0YXJnZXQpIHtcclxuICBpZiAodGFyZ2V0ICYmIHRhcmdldFtcclxuICAgIFwiX192X2lzUmVhZG9ubHlcIlxyXG4gICAgLyogSVNfUkVBRE9OTFkgKi9cclxuICBdKSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgbXV0YWJsZUhhbmRsZXJzLCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLCByZWFjdGl2ZU1hcCk7XHJcbn1cclxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHksIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xyXG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgaWYgKHRydWUpIHtcclxuICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfVxyXG4gIGlmICh0YXJnZXRbXHJcbiAgICBcIl9fdl9yYXdcIlxyXG4gICAgLyogUkFXICovXHJcbiAgXSAmJiAhKGlzUmVhZG9ubHkgJiYgdGFyZ2V0W1xyXG4gICAgXCJfX3ZfaXNSZWFjdGl2ZVwiXHJcbiAgICAvKiBJU19SRUFDVElWRSAqL1xyXG4gIF0pKSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XHJcbiAgaWYgKGV4aXN0aW5nUHJveHkpIHtcclxuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xyXG4gIH1cclxuICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xyXG4gIGlmICh0YXJnZXRUeXBlID09PSAwKSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHRhcmdldFR5cGUgPT09IDIgPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnMpO1xyXG4gIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcclxuICByZXR1cm4gcHJveHk7XHJcbn1cclxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcclxuICByZXR1cm4gb2JzZXJ2ZWQgJiYgdG9SYXcob2JzZXJ2ZWRbXHJcbiAgICBcIl9fdl9yYXdcIlxyXG4gICAgLyogUkFXICovXHJcbiAgXSkgfHwgb2JzZXJ2ZWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWYocikge1xyXG4gIHJldHVybiBCb29sZWFuKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRuZXh0VGljay5qc1xyXG5tYWdpYyhcIm5leHRUaWNrXCIsICgpID0+IG5leHRUaWNrKTtcclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGRpc3BhdGNoLmpzXHJcbm1hZ2ljKFwiZGlzcGF0Y2hcIiwgKGVsKSA9PiBkaXNwYXRjaC5iaW5kKGRpc3BhdGNoLCBlbCkpO1xyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kd2F0Y2guanNcclxubWFnaWMoXCJ3YXRjaFwiLCAoZWwsIHsgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjIsIGVmZmVjdDogZWZmZWN0MyB9KSA9PiAoa2V5LCBjYWxsYmFjaykgPT4ge1xyXG4gIGxldCBldmFsdWF0ZTIgPSBldmFsdWF0ZUxhdGVyMihrZXkpO1xyXG4gIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xyXG4gIGxldCBvbGRWYWx1ZTtcclxuICBsZXQgZWZmZWN0UmVmZXJlbmNlID0gZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XHJcbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICBpZiAoIWZpcnN0VGltZSkge1xyXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgY2FsbGJhY2sodmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9sZFZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcclxuICB9KSk7XHJcbiAgZWwuX3hfZWZmZWN0cy5kZWxldGUoZWZmZWN0UmVmZXJlbmNlKTtcclxufSk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRzdG9yZS5qc1xyXG5tYWdpYyhcInN0b3JlXCIsIGdldFN0b3Jlcyk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRkYXRhLmpzXHJcbm1hZ2ljKFwiZGF0YVwiLCAoZWwpID0+IHNjb3BlKGVsKSk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRyb290LmpzXHJcbm1hZ2ljKFwicm9vdFwiLCAoZWwpID0+IGNsb3Nlc3RSb290KGVsKSk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRyZWZzLmpzXHJcbm1hZ2ljKFwicmVmc1wiLCAoZWwpID0+IHtcclxuICBpZiAoZWwuX3hfcmVmc19wcm94eSlcclxuICAgIHJldHVybiBlbC5feF9yZWZzX3Byb3h5O1xyXG4gIGVsLl94X3JlZnNfcHJveHkgPSBtZXJnZVByb3hpZXMoZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkpO1xyXG4gIHJldHVybiBlbC5feF9yZWZzX3Byb3h5O1xyXG59KTtcclxuZnVuY3Rpb24gZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkge1xyXG4gIGxldCByZWZPYmplY3RzID0gW107XHJcbiAgbGV0IGN1cnJlbnRFbCA9IGVsO1xyXG4gIHdoaWxlIChjdXJyZW50RWwpIHtcclxuICAgIGlmIChjdXJyZW50RWwuX3hfcmVmcylcclxuICAgICAgcmVmT2JqZWN0cy5wdXNoKGN1cnJlbnRFbC5feF9yZWZzKTtcclxuICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnROb2RlO1xyXG4gIH1cclxuICByZXR1cm4gcmVmT2JqZWN0cztcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2lkcy5qc1xyXG52YXIgZ2xvYmFsSWRNZW1vID0ge307XHJcbmZ1bmN0aW9uIGZpbmRBbmRJbmNyZW1lbnRJZChuYW1lKSB7XHJcbiAgaWYgKCFnbG9iYWxJZE1lbW9bbmFtZV0pXHJcbiAgICBnbG9iYWxJZE1lbW9bbmFtZV0gPSAwO1xyXG4gIHJldHVybiArK2dsb2JhbElkTWVtb1tuYW1lXTtcclxufVxyXG5mdW5jdGlvbiBjbG9zZXN0SWRSb290KGVsLCBuYW1lKSB7XHJcbiAgcmV0dXJuIGZpbmRDbG9zZXN0KGVsLCAoZWxlbWVudCkgPT4ge1xyXG4gICAgaWYgKGVsZW1lbnQuX3hfaWRzICYmIGVsZW1lbnQuX3hfaWRzW25hbWVdKVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRJZFJvb3QoZWwsIG5hbWUpIHtcclxuICBpZiAoIWVsLl94X2lkcylcclxuICAgIGVsLl94X2lkcyA9IHt9O1xyXG4gIGlmICghZWwuX3hfaWRzW25hbWVdKVxyXG4gICAgZWwuX3hfaWRzW25hbWVdID0gZmluZEFuZEluY3JlbWVudElkKG5hbWUpO1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRpZC5qc1xyXG5tYWdpYyhcImlkXCIsIChlbCkgPT4gKG5hbWUsIGtleSA9IG51bGwpID0+IHtcclxuICBsZXQgcm9vdCA9IGNsb3Nlc3RJZFJvb3QoZWwsIG5hbWUpO1xyXG4gIGxldCBpZCA9IHJvb3QgPyByb290Ll94X2lkc1tuYW1lXSA6IGZpbmRBbmRJbmNyZW1lbnRJZChuYW1lKTtcclxuICByZXR1cm4ga2V5ID8gYCR7bmFtZX0tJHtpZH0tJHtrZXl9YCA6IGAke25hbWV9LSR7aWR9YDtcclxufSk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRlbC5qc1xyXG5tYWdpYyhcImVsXCIsIChlbCkgPT4gZWwpO1xyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy9pbmRleC5qc1xyXG53YXJuTWlzc2luZ1BsdWdpbk1hZ2ljKFwiRm9jdXNcIiwgXCJmb2N1c1wiLCBcImZvY3VzXCIpO1xyXG53YXJuTWlzc2luZ1BsdWdpbk1hZ2ljKFwiUGVyc2lzdFwiLCBcInBlcnNpc3RcIiwgXCJwZXJzaXN0XCIpO1xyXG5mdW5jdGlvbiB3YXJuTWlzc2luZ1BsdWdpbk1hZ2ljKG5hbWUsIG1hZ2ljTmFtZSwgc2x1Zykge1xyXG4gIG1hZ2ljKG1hZ2ljTmFtZSwgKGVsKSA9PiB3YXJuKGBZb3UgY2FuJ3QgdXNlIFskJHtkaXJlY3RpdmVOYW1lfV0gd2l0aG91dCBmaXJzdCBpbnN0YWxsaW5nIHRoZSBcIiR7bmFtZX1cIiBwbHVnaW4gaGVyZTogaHR0cHM6Ly9hbHBpbmVqcy5kZXYvcGx1Z2lucy8ke3NsdWd9YCwgZWwpKTtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2VudGFuZ2xlLmpzXHJcbmZ1bmN0aW9uIGVudGFuZ2xlKHsgZ2V0OiBvdXRlckdldCwgc2V0OiBvdXRlclNldCB9LCB7IGdldDogaW5uZXJHZXQsIHNldDogaW5uZXJTZXQgfSkge1xyXG4gIGxldCBmaXJzdFJ1biA9IHRydWU7XHJcbiAgbGV0IG91dGVySGFzaCwgaW5uZXJIYXNoLCBvdXRlckhhc2hMYXRlc3QsIGlubmVySGFzaExhdGVzdDtcclxuICBsZXQgcmVmZXJlbmNlID0gZWZmZWN0KCgpID0+IHtcclxuICAgIGxldCBvdXRlciwgaW5uZXI7XHJcbiAgICBpZiAoZmlyc3RSdW4pIHtcclxuICAgICAgb3V0ZXIgPSBvdXRlckdldCgpO1xyXG4gICAgICBpbm5lclNldChvdXRlcik7XHJcbiAgICAgIGlubmVyID0gaW5uZXJHZXQoKTtcclxuICAgICAgZmlyc3RSdW4gPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG91dGVyID0gb3V0ZXJHZXQoKTtcclxuICAgICAgaW5uZXIgPSBpbm5lckdldCgpO1xyXG4gICAgICBvdXRlckhhc2hMYXRlc3QgPSBKU09OLnN0cmluZ2lmeShvdXRlcik7XHJcbiAgICAgIGlubmVySGFzaExhdGVzdCA9IEpTT04uc3RyaW5naWZ5KGlubmVyKTtcclxuICAgICAgaWYgKG91dGVySGFzaExhdGVzdCAhPT0gb3V0ZXJIYXNoKSB7XHJcbiAgICAgICAgaW5uZXIgPSBpbm5lckdldCgpO1xyXG4gICAgICAgIGlubmVyU2V0KG91dGVyKTtcclxuICAgICAgICBpbm5lciA9IG91dGVyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG91dGVyU2V0KGlubmVyKTtcclxuICAgICAgICBvdXRlciA9IGlubmVyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBvdXRlckhhc2ggPSBKU09OLnN0cmluZ2lmeShvdXRlcik7XHJcbiAgICBpbm5lckhhc2ggPSBKU09OLnN0cmluZ2lmeShpbm5lcik7XHJcbiAgfSk7XHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIHJlbGVhc2UocmVmZXJlbmNlKTtcclxuICB9O1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LW1vZGVsYWJsZS5qc1xyXG5kaXJlY3RpdmUoXCJtb2RlbGFibGVcIiwgKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMsIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIyLCBjbGVhbnVwOiBjbGVhbnVwMiB9KSA9PiB7XHJcbiAgbGV0IGZ1bmMgPSBldmFsdWF0ZUxhdGVyMihleHByZXNzaW9uKTtcclxuICBsZXQgaW5uZXJHZXQgPSAoKSA9PiB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgZnVuYygoaSkgPT4gcmVzdWx0ID0gaSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcbiAgbGV0IGV2YWx1YXRlSW5uZXJTZXQgPSBldmFsdWF0ZUxhdGVyMihgJHtleHByZXNzaW9ufSA9IF9fcGxhY2Vob2xkZXJgKTtcclxuICBsZXQgaW5uZXJTZXQgPSAodmFsKSA9PiBldmFsdWF0ZUlubmVyU2V0KCgpID0+IHtcclxuICB9LCB7IHNjb3BlOiB7IFwiX19wbGFjZWhvbGRlclwiOiB2YWwgfSB9KTtcclxuICBsZXQgaW5pdGlhbFZhbHVlID0gaW5uZXJHZXQoKTtcclxuICBpbm5lclNldChpbml0aWFsVmFsdWUpO1xyXG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgIGlmICghZWwuX3hfbW9kZWwpXHJcbiAgICAgIHJldHVybjtcclxuICAgIGVsLl94X3JlbW92ZU1vZGVsTGlzdGVuZXJzW1wiZGVmYXVsdFwiXSgpO1xyXG4gICAgbGV0IG91dGVyR2V0ID0gZWwuX3hfbW9kZWwuZ2V0O1xyXG4gICAgbGV0IG91dGVyU2V0ID0gZWwuX3hfbW9kZWwuc2V0O1xyXG4gICAgbGV0IHJlbGVhc2VFbnRhbmdsZW1lbnQgPSBlbnRhbmdsZShcclxuICAgICAge1xyXG4gICAgICAgIGdldCgpIHtcclxuICAgICAgICAgIHJldHVybiBvdXRlckdldCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgICBvdXRlclNldCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgcmV0dXJuIGlubmVyR2V0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQodmFsdWUpIHtcclxuICAgICAgICAgIGlubmVyU2V0KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBjbGVhbnVwMihyZWxlYXNlRW50YW5nbGVtZW50KTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRlbGVwb3J0LmpzXHJcbnZhciB0ZWxlcG9ydENvbnRhaW5lckR1cmluZ0Nsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuZGlyZWN0aXZlKFwidGVsZXBvcnRcIiwgKGVsLCB7IG1vZGlmaWVycywgZXhwcmVzc2lvbiB9LCB7IGNsZWFudXA6IGNsZWFudXAyIH0pID0+IHtcclxuICBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInRlbXBsYXRlXCIpXHJcbiAgICB3YXJuKFwieC10ZWxlcG9ydCBjYW4gb25seSBiZSB1c2VkIG9uIGEgPHRlbXBsYXRlPiB0YWdcIiwgZWwpO1xyXG4gIGxldCB0YXJnZXQgPSBza2lwRHVyaW5nQ2xvbmUoKCkgPT4ge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZXhwcmVzc2lvbik7XHJcbiAgfSwgKCkgPT4ge1xyXG4gICAgcmV0dXJuIHRlbGVwb3J0Q29udGFpbmVyRHVyaW5nQ2xvbmU7XHJcbiAgfSkoKTtcclxuICBpZiAoIXRhcmdldClcclxuICAgIHdhcm4oYENhbm5vdCBmaW5kIHgtdGVsZXBvcnQgZWxlbWVudCBmb3Igc2VsZWN0b3I6IFwiJHtleHByZXNzaW9ufVwiYCk7XHJcbiAgbGV0IGNsb25lMiA9IGVsLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLmZpcnN0RWxlbWVudENoaWxkO1xyXG4gIGVsLl94X3RlbGVwb3J0ID0gY2xvbmUyO1xyXG4gIGNsb25lMi5feF90ZWxlcG9ydEJhY2sgPSBlbDtcclxuICBpZiAoZWwuX3hfZm9yd2FyZEV2ZW50cykge1xyXG4gICAgZWwuX3hfZm9yd2FyZEV2ZW50cy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcclxuICAgICAgY2xvbmUyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoZSkgPT4ge1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgZS5jb25zdHJ1Y3RvcihlLnR5cGUsIGUpKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCB7fSwgZWwpO1xyXG4gIG11dGF0ZURvbSgoKSA9PiB7XHJcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwicHJlcGVuZFwiKSkge1xyXG4gICAgICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmUyLCB0YXJnZXQpO1xyXG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJhcHBlbmRcIikpIHtcclxuICAgICAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lMiwgdGFyZ2V0Lm5leHRTaWJsaW5nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChjbG9uZTIpO1xyXG4gICAgfVxyXG4gICAgaW5pdFRyZWUoY2xvbmUyKTtcclxuICAgIGNsb25lMi5feF9pZ25vcmUgPSB0cnVlO1xyXG4gIH0pO1xyXG4gIGNsZWFudXAyKCgpID0+IGNsb25lMi5yZW1vdmUoKSk7XHJcbn0pO1xyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pZ25vcmUuanNcclxudmFyIGhhbmRsZXIgPSAoKSA9PiB7XHJcbn07XHJcbmhhbmRsZXIuaW5saW5lID0gKGVsLCB7IG1vZGlmaWVycyB9LCB7IGNsZWFudXA6IGNsZWFudXAyIH0pID0+IHtcclxuICBtb2RpZmllcnMuaW5jbHVkZXMoXCJzZWxmXCIpID8gZWwuX3hfaWdub3JlU2VsZiA9IHRydWUgOiBlbC5feF9pZ25vcmUgPSB0cnVlO1xyXG4gIGNsZWFudXAyKCgpID0+IHtcclxuICAgIG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikgPyBkZWxldGUgZWwuX3hfaWdub3JlU2VsZiA6IGRlbGV0ZSBlbC5feF9pZ25vcmU7XHJcbiAgfSk7XHJcbn07XHJcbmRpcmVjdGl2ZShcImlnbm9yZVwiLCBoYW5kbGVyKTtcclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtZWZmZWN0LmpzXHJcbmRpcmVjdGl2ZShcImVmZmVjdFwiLCAoZWwsIHsgZXhwcmVzc2lvbiB9LCB7IGVmZmVjdDogZWZmZWN0MyB9KSA9PiBlZmZlY3QzKGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pKSk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvb24uanNcclxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBtb2RpZmllcnMsIGNhbGxiYWNrKSB7XHJcbiAgbGV0IGxpc3RlbmVyVGFyZ2V0ID0gZWw7XHJcbiAgbGV0IGhhbmRsZXIzID0gKGUpID0+IGNhbGxiYWNrKGUpO1xyXG4gIGxldCBvcHRpb25zID0ge307XHJcbiAgbGV0IHdyYXBIYW5kbGVyID0gKGNhbGxiYWNrMiwgd3JhcHBlcikgPT4gKGUpID0+IHdyYXBwZXIoY2FsbGJhY2syLCBlKTtcclxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiZG90XCIpKVxyXG4gICAgZXZlbnQgPSBkb3RTeW50YXgoZXZlbnQpO1xyXG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJjYW1lbFwiKSlcclxuICAgIGV2ZW50ID0gY2FtZWxDYXNlMihldmVudCk7XHJcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInBhc3NpdmVcIikpXHJcbiAgICBvcHRpb25zLnBhc3NpdmUgPSB0cnVlO1xyXG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJjYXB0dXJlXCIpKVxyXG4gICAgb3B0aW9ucy5jYXB0dXJlID0gdHJ1ZTtcclxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwid2luZG93XCIpKVxyXG4gICAgbGlzdGVuZXJUYXJnZXQgPSB3aW5kb3c7XHJcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImRvY3VtZW50XCIpKVxyXG4gICAgbGlzdGVuZXJUYXJnZXQgPSBkb2N1bWVudDtcclxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwicHJldmVudFwiKSlcclxuICAgIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgbmV4dChlKTtcclxuICAgIH0pO1xyXG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJzdG9wXCIpKVxyXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgbmV4dChlKTtcclxuICAgIH0pO1xyXG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJzZWxmXCIpKVxyXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcclxuICAgICAgZS50YXJnZXQgPT09IGVsICYmIG5leHQoZSk7XHJcbiAgICB9KTtcclxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiYXdheVwiKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJvdXRzaWRlXCIpKSB7XHJcbiAgICBsaXN0ZW5lclRhcmdldCA9IGRvY3VtZW50O1xyXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcclxuICAgICAgaWYgKGVsLmNvbnRhaW5zKGUudGFyZ2V0KSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGlmIChlLnRhcmdldC5pc0Nvbm5lY3RlZCA9PT0gZmFsc2UpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBpZiAoZWwub2Zmc2V0V2lkdGggPCAxICYmIGVsLm9mZnNldEhlaWdodCA8IDEpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBpZiAoZWwuX3hfaXNTaG93biA9PT0gZmFsc2UpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBuZXh0KGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJvbmNlXCIpKSB7XHJcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xyXG4gICAgICBuZXh0KGUpO1xyXG4gICAgICBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyMywgb3B0aW9ucyk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcclxuICAgIGlmIChpc0tleUV2ZW50KGV2ZW50KSkge1xyXG4gICAgICBpZiAoaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBuZXh0KGUpO1xyXG4gIH0pO1xyXG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkZWJvdW5jZVwiKSkge1xyXG4gICAgbGV0IG5leHRNb2RpZmllciA9IG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihcImRlYm91bmNlXCIpICsgMV0gfHwgXCJpbnZhbGlkLXdhaXRcIjtcclxuICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA/IE51bWJlcihuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgOiAyNTA7XHJcbiAgICBoYW5kbGVyMyA9IGRlYm91bmNlKGhhbmRsZXIzLCB3YWl0KTtcclxuICB9XHJcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInRocm90dGxlXCIpKSB7XHJcbiAgICBsZXQgbmV4dE1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKFwidGhyb3R0bGVcIikgKyAxXSB8fCBcImludmFsaWQtd2FpdFwiO1xyXG4gICAgbGV0IHdhaXQgPSBpc051bWVyaWMobmV4dE1vZGlmaWVyLnNwbGl0KFwibXNcIilbMF0pID8gTnVtYmVyKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA6IDI1MDtcclxuICAgIGhhbmRsZXIzID0gdGhyb3R0bGUoaGFuZGxlcjMsIHdhaXQpO1xyXG4gIH1cclxuICBsaXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyMywgb3B0aW9ucyk7XHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIzLCBvcHRpb25zKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRvdFN5bnRheChzdWJqZWN0KSB7XHJcbiAgcmV0dXJuIHN1YmplY3QucmVwbGFjZSgvLS9nLCBcIi5cIik7XHJcbn1cclxuZnVuY3Rpb24gY2FtZWxDYXNlMihzdWJqZWN0KSB7XHJcbiAgcmV0dXJuIHN1YmplY3QudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFxcdykvZywgKG1hdGNoLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzTnVtZXJpYyhzdWJqZWN0KSB7XHJcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcclxufVxyXG5mdW5jdGlvbiBrZWJhYkNhc2UyKHN1YmplY3QpIHtcclxuICBpZiAoW1wiIFwiLCBcIl9cIl0uaW5jbHVkZXMoXHJcbiAgICBzdWJqZWN0XHJcbiAgKSlcclxuICAgIHJldHVybiBzdWJqZWN0O1xyXG4gIHJldHVybiBzdWJqZWN0LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikucmVwbGFjZSgvW19cXHNdLywgXCItXCIpLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuZnVuY3Rpb24gaXNLZXlFdmVudChldmVudCkge1xyXG4gIHJldHVybiBbXCJrZXlkb3duXCIsIFwia2V5dXBcIl0uaW5jbHVkZXMoZXZlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSB7XHJcbiAgbGV0IGtleU1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoKGkpID0+IHtcclxuICAgIHJldHVybiAhW1wid2luZG93XCIsIFwiZG9jdW1lbnRcIiwgXCJwcmV2ZW50XCIsIFwic3RvcFwiLCBcIm9uY2VcIiwgXCJjYXB0dXJlXCJdLmluY2x1ZGVzKGkpO1xyXG4gIH0pO1xyXG4gIGlmIChrZXlNb2RpZmllcnMuaW5jbHVkZXMoXCJkZWJvdW5jZVwiKSkge1xyXG4gICAgbGV0IGRlYm91bmNlSW5kZXggPSBrZXlNb2RpZmllcnMuaW5kZXhPZihcImRlYm91bmNlXCIpO1xyXG4gICAga2V5TW9kaWZpZXJzLnNwbGljZShkZWJvdW5jZUluZGV4LCBpc051bWVyaWMoKGtleU1vZGlmaWVyc1tkZWJvdW5jZUluZGV4ICsgMV0gfHwgXCJpbnZhbGlkLXdhaXRcIikuc3BsaXQoXCJtc1wiKVswXSkgPyAyIDogMSk7XHJcbiAgfVxyXG4gIGlmIChrZXlNb2RpZmllcnMuaW5jbHVkZXMoXCJ0aHJvdHRsZVwiKSkge1xyXG4gICAgbGV0IGRlYm91bmNlSW5kZXggPSBrZXlNb2RpZmllcnMuaW5kZXhPZihcInRocm90dGxlXCIpO1xyXG4gICAga2V5TW9kaWZpZXJzLnNwbGljZShkZWJvdW5jZUluZGV4LCBpc051bWVyaWMoKGtleU1vZGlmaWVyc1tkZWJvdW5jZUluZGV4ICsgMV0gfHwgXCJpbnZhbGlkLXdhaXRcIikuc3BsaXQoXCJtc1wiKVswXSkgPyAyIDogMSk7XHJcbiAgfVxyXG4gIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAwKVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAxICYmIGtleVRvTW9kaWZpZXJzKGUua2V5KS5pbmNsdWRlcyhrZXlNb2RpZmllcnNbMF0pKVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIGNvbnN0IHN5c3RlbUtleU1vZGlmaWVycyA9IFtcImN0cmxcIiwgXCJzaGlmdFwiLCBcImFsdFwiLCBcIm1ldGFcIiwgXCJjbWRcIiwgXCJzdXBlclwiXTtcclxuICBjb25zdCBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycyA9IHN5c3RlbUtleU1vZGlmaWVycy5maWx0ZXIoKG1vZGlmaWVyKSA9PiBrZXlNb2RpZmllcnMuaW5jbHVkZXMobW9kaWZpZXIpKTtcclxuICBrZXlNb2RpZmllcnMgPSBrZXlNb2RpZmllcnMuZmlsdGVyKChpKSA9PiAhc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMuaW5jbHVkZXMoaSkpO1xyXG4gIGlmIChzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zdCBhY3RpdmVseVByZXNzZWRLZXlNb2RpZmllcnMgPSBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5maWx0ZXIoKG1vZGlmaWVyKSA9PiB7XHJcbiAgICAgIGlmIChtb2RpZmllciA9PT0gXCJjbWRcIiB8fCBtb2RpZmllciA9PT0gXCJzdXBlclwiKVxyXG4gICAgICAgIG1vZGlmaWVyID0gXCJtZXRhXCI7XHJcbiAgICAgIHJldHVybiBlW2Ake21vZGlmaWVyfUtleWBdO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoYWN0aXZlbHlQcmVzc2VkS2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICAgIGlmIChrZXlUb01vZGlmaWVycyhlLmtleSkuaW5jbHVkZXMoa2V5TW9kaWZpZXJzWzBdKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGtleVRvTW9kaWZpZXJzKGtleSkge1xyXG4gIGlmICgha2V5KVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIGtleSA9IGtlYmFiQ2FzZTIoa2V5KTtcclxuICBsZXQgbW9kaWZpZXJUb0tleU1hcCA9IHtcclxuICAgIFwiY3RybFwiOiBcImNvbnRyb2xcIixcclxuICAgIFwic2xhc2hcIjogXCIvXCIsXHJcbiAgICBcInNwYWNlXCI6IFwiIFwiLFxyXG4gICAgXCJzcGFjZWJhclwiOiBcIiBcIixcclxuICAgIFwiY21kXCI6IFwibWV0YVwiLFxyXG4gICAgXCJlc2NcIjogXCJlc2NhcGVcIixcclxuICAgIFwidXBcIjogXCJhcnJvdy11cFwiLFxyXG4gICAgXCJkb3duXCI6IFwiYXJyb3ctZG93blwiLFxyXG4gICAgXCJsZWZ0XCI6IFwiYXJyb3ctbGVmdFwiLFxyXG4gICAgXCJyaWdodFwiOiBcImFycm93LXJpZ2h0XCIsXHJcbiAgICBcInBlcmlvZFwiOiBcIi5cIixcclxuICAgIFwiZXF1YWxcIjogXCI9XCIsXHJcbiAgICBcIm1pbnVzXCI6IFwiLVwiLFxyXG4gICAgXCJ1bmRlcnNjb3JlXCI6IFwiX1wiXHJcbiAgfTtcclxuICBtb2RpZmllclRvS2V5TWFwW2tleV0gPSBrZXk7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZGlmaWVyVG9LZXlNYXApLm1hcCgobW9kaWZpZXIpID0+IHtcclxuICAgIGlmIChtb2RpZmllclRvS2V5TWFwW21vZGlmaWVyXSA9PT0ga2V5KVxyXG4gICAgICByZXR1cm4gbW9kaWZpZXI7XHJcbiAgfSkuZmlsdGVyKChtb2RpZmllcikgPT4gbW9kaWZpZXIpO1xyXG59XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LW1vZGVsLmpzXHJcbmRpcmVjdGl2ZShcIm1vZGVsXCIsIChlbCwgeyBtb2RpZmllcnMsIGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXA6IGNsZWFudXAyIH0pID0+IHtcclxuICBsZXQgc2NvcGVUYXJnZXQgPSBlbDtcclxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwicGFyZW50XCIpKSB7XHJcbiAgICBzY29wZVRhcmdldCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgfVxyXG4gIGxldCBldmFsdWF0ZUdldCA9IGV2YWx1YXRlTGF0ZXIoc2NvcGVUYXJnZXQsIGV4cHJlc3Npb24pO1xyXG4gIGxldCBldmFsdWF0ZVNldDtcclxuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwic3RyaW5nXCIpIHtcclxuICAgIGV2YWx1YXRlU2V0ID0gZXZhbHVhdGVMYXRlcihzY29wZVRhcmdldCwgYCR7ZXhwcmVzc2lvbn0gPSBfX3BsYWNlaG9sZGVyYCk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBleHByZXNzaW9uKCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIGV2YWx1YXRlU2V0ID0gZXZhbHVhdGVMYXRlcihzY29wZVRhcmdldCwgYCR7ZXhwcmVzc2lvbigpfSA9IF9fcGxhY2Vob2xkZXJgKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZXZhbHVhdGVTZXQgPSAoKSA9PiB7XHJcbiAgICB9O1xyXG4gIH1cclxuICBsZXQgZ2V0VmFsdWUgPSAoKSA9PiB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgZXZhbHVhdGVHZXQoKHZhbHVlKSA9PiByZXN1bHQgPSB2YWx1ZSk7XHJcbiAgICByZXR1cm4gaXNHZXR0ZXJTZXR0ZXIocmVzdWx0KSA/IHJlc3VsdC5nZXQoKSA6IHJlc3VsdDtcclxuICB9O1xyXG4gIGxldCBzZXRWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGV2YWx1YXRlR2V0KCh2YWx1ZTIpID0+IHJlc3VsdCA9IHZhbHVlMik7XHJcbiAgICBpZiAoaXNHZXR0ZXJTZXR0ZXIocmVzdWx0KSkge1xyXG4gICAgICByZXN1bHQuc2V0KHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGV2YWx1YXRlU2V0KCgpID0+IHtcclxuICAgICAgfSwge1xyXG4gICAgICAgIHNjb3BlOiB7IFwiX19wbGFjZWhvbGRlclwiOiB2YWx1ZSB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImZpbGxcIikgJiYgZWwuaGFzQXR0cmlidXRlKFwidmFsdWVcIikgJiYgKGdldFZhbHVlKCkgPT09IG51bGwgfHwgZ2V0VmFsdWUoKSA9PT0gXCJcIikpIHtcclxuICAgIHNldFZhbHVlKGVsLnZhbHVlKTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiICYmIGVsLnR5cGUgPT09IFwicmFkaW9cIikge1xyXG4gICAgbXV0YXRlRG9tKCgpID0+IHtcclxuICAgICAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoXCJuYW1lXCIpKVxyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgZXhwcmVzc2lvbik7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgdmFyIGV2ZW50ID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiIHx8IFtcImNoZWNrYm94XCIsIFwicmFkaW9cIl0uaW5jbHVkZXMoZWwudHlwZSkgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwibGF6eVwiKSA/IFwiY2hhbmdlXCIgOiBcImlucHV0XCI7XHJcbiAgbGV0IHJlbW92ZUxpc3RlbmVyID0gaXNDbG9uaW5nID8gKCkgPT4ge1xyXG4gIH0gOiBvbihlbCwgZXZlbnQsIG1vZGlmaWVycywgKGUpID0+IHtcclxuICAgIHNldFZhbHVlKGdldElucHV0VmFsdWUoZWwsIG1vZGlmaWVycywgZSwgZ2V0VmFsdWUoKSkpO1xyXG4gIH0pO1xyXG4gIGlmICghZWwuX3hfcmVtb3ZlTW9kZWxMaXN0ZW5lcnMpXHJcbiAgICBlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVycyA9IHt9O1xyXG4gIGVsLl94X3JlbW92ZU1vZGVsTGlzdGVuZXJzW1wiZGVmYXVsdFwiXSA9IHJlbW92ZUxpc3RlbmVyO1xyXG4gIGNsZWFudXAyKCgpID0+IGVsLl94X3JlbW92ZU1vZGVsTGlzdGVuZXJzW1wiZGVmYXVsdFwiXSgpKTtcclxuICBpZiAoZWwuZm9ybSkge1xyXG4gICAgbGV0IHJlbW92ZVJlc2V0TGlzdGVuZXIgPSBvbihlbC5mb3JtLCBcInJlc2V0XCIsIFtdLCAoZSkgPT4ge1xyXG4gICAgICBuZXh0VGljaygoKSA9PiBlbC5feF9tb2RlbCAmJiBlbC5feF9tb2RlbC5zZXQoZWwudmFsdWUpKTtcclxuICAgIH0pO1xyXG4gICAgY2xlYW51cDIoKCkgPT4gcmVtb3ZlUmVzZXRMaXN0ZW5lcigpKTtcclxuICB9XHJcbiAgZWwuX3hfbW9kZWwgPSB7XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgIHJldHVybiBnZXRWYWx1ZSgpO1xyXG4gICAgfSxcclxuICAgIHNldCh2YWx1ZSkge1xyXG4gICAgICBzZXRWYWx1ZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBlbC5feF9mb3JjZU1vZGVsVXBkYXRlID0gKHZhbHVlKSA9PiB7XHJcbiAgICB2YWx1ZSA9IHZhbHVlID09PSB2b2lkIDAgPyBnZXRWYWx1ZSgpIDogdmFsdWU7XHJcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCAmJiB0eXBlb2YgZXhwcmVzc2lvbiA9PT0gXCJzdHJpbmdcIiAmJiBleHByZXNzaW9uLm1hdGNoKC9cXC4vKSlcclxuICAgICAgdmFsdWUgPSBcIlwiO1xyXG4gICAgd2luZG93LmZyb21Nb2RlbCA9IHRydWU7XHJcbiAgICBtdXRhdGVEb20oKCkgPT4gYmluZChlbCwgXCJ2YWx1ZVwiLCB2YWx1ZSkpO1xyXG4gICAgZGVsZXRlIHdpbmRvdy5mcm9tTW9kZWw7XHJcbiAgfTtcclxuICBlZmZlY3QzKCgpID0+IHtcclxuICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKCk7XHJcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwidW5pbnRydXNpdmVcIikgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGVsKSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgZWwuX3hfZm9yY2VNb2RlbFVwZGF0ZSh2YWx1ZSk7XHJcbiAgfSk7XHJcbn0pO1xyXG5mdW5jdGlvbiBnZXRJbnB1dFZhbHVlKGVsLCBtb2RpZmllcnMsIGV2ZW50LCBjdXJyZW50VmFsdWUpIHtcclxuICByZXR1cm4gbXV0YXRlRG9tKCgpID0+IHtcclxuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50ICYmIGV2ZW50LmRldGFpbCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgZXZlbnQuZGV0YWlsICE9IFwidW5kZWZpbmVkXCIgPyBldmVudC5kZXRhaWwgOiBldmVudC50YXJnZXQudmFsdWU7XHJcbiAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XHJcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gbW9kaWZpZXJzLmluY2x1ZGVzKFwibnVtYmVyXCIpID8gc2FmZVBhcnNlTnVtYmVyKGV2ZW50LnRhcmdldC52YWx1ZSkgOiBldmVudC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkID8gY3VycmVudFZhbHVlLmNvbmNhdChbbmV3VmFsdWVdKSA6IGN1cnJlbnRWYWx1ZS5maWx0ZXIoKGVsMikgPT4gIWNoZWNrZWRBdHRyTG9vc2VDb21wYXJlMihlbDIsIG5ld1ZhbHVlKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIiAmJiBlbC5tdWx0aXBsZSkge1xyXG4gICAgICByZXR1cm4gbW9kaWZpZXJzLmluY2x1ZGVzKFwibnVtYmVyXCIpID8gQXJyYXkuZnJvbShldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zKS5tYXAoKG9wdGlvbikgPT4ge1xyXG4gICAgICAgIGxldCByYXdWYWx1ZSA9IG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dDtcclxuICAgICAgICByZXR1cm4gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKTtcclxuICAgICAgfSkgOiBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcCgob3B0aW9uKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dDtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgcmF3VmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XHJcbiAgICAgIHJldHVybiBtb2RpZmllcnMuaW5jbHVkZXMoXCJudW1iZXJcIikgPyBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIDogbW9kaWZpZXJzLmluY2x1ZGVzKFwidHJpbVwiKSA/IHJhd1ZhbHVlLnRyaW0oKSA6IHJhd1ZhbHVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSkge1xyXG4gIGxldCBudW1iZXIgPSByYXdWYWx1ZSA/IHBhcnNlRmxvYXQocmF3VmFsdWUpIDogbnVsbDtcclxuICByZXR1cm4gaXNOdW1lcmljMihudW1iZXIpID8gbnVtYmVyIDogcmF3VmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUyKHZhbHVlQSwgdmFsdWVCKSB7XHJcbiAgcmV0dXJuIHZhbHVlQSA9PSB2YWx1ZUI7XHJcbn1cclxuZnVuY3Rpb24gaXNOdW1lcmljMihzdWJqZWN0KSB7XHJcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcclxufVxyXG5mdW5jdGlvbiBpc0dldHRlclNldHRlcih2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWx1ZS5zZXQgPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1jbG9hay5qc1xyXG5kaXJlY3RpdmUoXCJjbG9ha1wiLCAoZWwpID0+IHF1ZXVlTWljcm90YXNrKCgpID0+IG11dGF0ZURvbSgoKSA9PiBlbC5yZW1vdmVBdHRyaWJ1dGUocHJlZml4KFwiY2xvYWtcIikpKSkpO1xyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pbml0LmpzXHJcbmFkZEluaXRTZWxlY3RvcigoKSA9PiBgWyR7cHJlZml4KFwiaW5pdFwiKX1dYCk7XHJcbmRpcmVjdGl2ZShcImluaXRcIiwgc2tpcER1cmluZ0Nsb25lKChlbCwgeyBleHByZXNzaW9uIH0sIHsgZXZhbHVhdGU6IGV2YWx1YXRlMiB9KSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICByZXR1cm4gISFleHByZXNzaW9uLnRyaW0oKSAmJiBldmFsdWF0ZTIoZXhwcmVzc2lvbiwge30sIGZhbHNlKTtcclxuICB9XHJcbiAgcmV0dXJuIGV2YWx1YXRlMihleHByZXNzaW9uLCB7fSwgZmFsc2UpO1xyXG59KSk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRleHQuanNcclxuZGlyZWN0aXZlKFwidGV4dFwiLCAoZWwsIHsgZXhwcmVzc2lvbiB9LCB7IGVmZmVjdDogZWZmZWN0MywgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjIgfSkgPT4ge1xyXG4gIGxldCBldmFsdWF0ZTIgPSBldmFsdWF0ZUxhdGVyMihleHByZXNzaW9uKTtcclxuICBlZmZlY3QzKCgpID0+IHtcclxuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcclxuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcclxuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaHRtbC5qc1xyXG5kaXJlY3RpdmUoXCJodG1sXCIsIChlbCwgeyBleHByZXNzaW9uIH0sIHsgZWZmZWN0OiBlZmZlY3QzLCBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyMiB9KSA9PiB7XHJcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIyKGV4cHJlc3Npb24pO1xyXG4gIGVmZmVjdDMoKCkgPT4ge1xyXG4gICAgZXZhbHVhdGUyKCh2YWx1ZSkgPT4ge1xyXG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xyXG4gICAgICAgIGVsLmlubmVySFRNTCA9IHZhbHVlO1xyXG4gICAgICAgIGVsLl94X2lnbm9yZVNlbGYgPSB0cnVlO1xyXG4gICAgICAgIGluaXRUcmVlKGVsKTtcclxuICAgICAgICBkZWxldGUgZWwuX3hfaWdub3JlU2VsZjtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWJpbmQuanNcclxubWFwQXR0cmlidXRlcyhzdGFydGluZ1dpdGgoXCI6XCIsIGludG8ocHJlZml4KFwiYmluZDpcIikpKSk7XHJcbmRpcmVjdGl2ZShcImJpbmRcIiwgKGVsLCB7IHZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb24sIG9yaWdpbmFsIH0sIHsgZWZmZWN0OiBlZmZlY3QzIH0pID0+IHtcclxuICBpZiAoIXZhbHVlKSB7XHJcbiAgICBsZXQgYmluZGluZ1Byb3ZpZGVycyA9IHt9O1xyXG4gICAgaW5qZWN0QmluZGluZ1Byb3ZpZGVycyhiaW5kaW5nUHJvdmlkZXJzKTtcclxuICAgIGxldCBnZXRCaW5kaW5ncyA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xyXG4gICAgZ2V0QmluZGluZ3MoKGJpbmRpbmdzKSA9PiB7XHJcbiAgICAgIGFwcGx5QmluZGluZ3NPYmplY3QoZWwsIGJpbmRpbmdzLCBvcmlnaW5hbCk7XHJcbiAgICB9LCB7IHNjb3BlOiBiaW5kaW5nUHJvdmlkZXJzIH0pO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAodmFsdWUgPT09IFwia2V5XCIpXHJcbiAgICByZXR1cm4gc3RvcmVLZXlGb3JYRm9yKGVsLCBleHByZXNzaW9uKTtcclxuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XHJcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHJlc3VsdCkgPT4ge1xyXG4gICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwICYmIHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiICYmIGV4cHJlc3Npb24ubWF0Y2goL1xcLi8pKSB7XHJcbiAgICAgIHJlc3VsdCA9IFwiXCI7XHJcbiAgICB9XHJcbiAgICBtdXRhdGVEb20oKCkgPT4gYmluZChlbCwgdmFsdWUsIHJlc3VsdCwgbW9kaWZpZXJzKSk7XHJcbiAgfSkpO1xyXG59KTtcclxuZnVuY3Rpb24gc3RvcmVLZXlGb3JYRm9yKGVsLCBleHByZXNzaW9uKSB7XHJcbiAgZWwuX3hfa2V5RXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbn1cclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtZGF0YS5qc1xyXG5hZGRSb290U2VsZWN0b3IoKCkgPT4gYFske3ByZWZpeChcImRhdGFcIil9XWApO1xyXG5kaXJlY3RpdmUoXCJkYXRhXCIsIHNraXBEdXJpbmdDbG9uZSgoZWwsIHsgZXhwcmVzc2lvbiB9LCB7IGNsZWFudXA6IGNsZWFudXAyIH0pID0+IHtcclxuICBleHByZXNzaW9uID0gZXhwcmVzc2lvbiA9PT0gXCJcIiA/IFwie31cIiA6IGV4cHJlc3Npb247XHJcbiAgbGV0IG1hZ2ljQ29udGV4dCA9IHt9O1xyXG4gIGluamVjdE1hZ2ljcyhtYWdpY0NvbnRleHQsIGVsKTtcclxuICBsZXQgZGF0YVByb3ZpZGVyQ29udGV4dCA9IHt9O1xyXG4gIGluamVjdERhdGFQcm92aWRlcnMoZGF0YVByb3ZpZGVyQ29udGV4dCwgbWFnaWNDb250ZXh0KTtcclxuICBsZXQgZGF0YTIgPSBldmFsdWF0ZShlbCwgZXhwcmVzc2lvbiwgeyBzY29wZTogZGF0YVByb3ZpZGVyQ29udGV4dCB9KTtcclxuICBpZiAoZGF0YTIgPT09IHZvaWQgMCB8fCBkYXRhMiA9PT0gdHJ1ZSlcclxuICAgIGRhdGEyID0ge307XHJcbiAgaW5qZWN0TWFnaWNzKGRhdGEyLCBlbCk7XHJcbiAgbGV0IHJlYWN0aXZlRGF0YSA9IHJlYWN0aXZlKGRhdGEyKTtcclxuICBpbml0SW50ZXJjZXB0b3JzKHJlYWN0aXZlRGF0YSk7XHJcbiAgbGV0IHVuZG8gPSBhZGRTY29wZVRvTm9kZShlbCwgcmVhY3RpdmVEYXRhKTtcclxuICByZWFjdGl2ZURhdGFbXCJpbml0XCJdICYmIGV2YWx1YXRlKGVsLCByZWFjdGl2ZURhdGFbXCJpbml0XCJdKTtcclxuICBjbGVhbnVwMigoKSA9PiB7XHJcbiAgICByZWFjdGl2ZURhdGFbXCJkZXN0cm95XCJdICYmIGV2YWx1YXRlKGVsLCByZWFjdGl2ZURhdGFbXCJkZXN0cm95XCJdKTtcclxuICAgIHVuZG8oKTtcclxuICB9KTtcclxufSkpO1xyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1zaG93LmpzXHJcbmRpcmVjdGl2ZShcInNob3dcIiwgKGVsLCB7IG1vZGlmaWVycywgZXhwcmVzc2lvbiB9LCB7IGVmZmVjdDogZWZmZWN0MyB9KSA9PiB7XHJcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xyXG4gIGlmICghZWwuX3hfZG9IaWRlKVxyXG4gICAgZWwuX3hfZG9IaWRlID0gKCkgPT4ge1xyXG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xyXG4gICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIm5vbmVcIiwgbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW1wb3J0YW50XCIpID8gXCJpbXBvcnRhbnRcIiA6IHZvaWQgMCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICBpZiAoIWVsLl94X2RvU2hvdylcclxuICAgIGVsLl94X2RvU2hvdyA9ICgpID0+IHtcclxuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcclxuICAgICAgICBpZiAoZWwuc3R5bGUubGVuZ3RoID09PSAxICYmIGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIGxldCBoaWRlID0gKCkgPT4ge1xyXG4gICAgZWwuX3hfZG9IaWRlKCk7XHJcbiAgICBlbC5feF9pc1Nob3duID0gZmFsc2U7XHJcbiAgfTtcclxuICBsZXQgc2hvdyA9ICgpID0+IHtcclxuICAgIGVsLl94X2RvU2hvdygpO1xyXG4gICAgZWwuX3hfaXNTaG93biA9IHRydWU7XHJcbiAgfTtcclxuICBsZXQgY2xpY2tBd2F5Q29tcGF0aWJsZVNob3cgPSAoKSA9PiBzZXRUaW1lb3V0KHNob3cpO1xyXG4gIGxldCB0b2dnbGUgPSBvbmNlKFxyXG4gICAgKHZhbHVlKSA9PiB2YWx1ZSA/IHNob3coKSA6IGhpZGUoKSxcclxuICAgICh2YWx1ZSkgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIGVsLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGVsLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMoZWwsIHZhbHVlLCBzaG93LCBoaWRlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YWx1ZSA/IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCkgOiBoaWRlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICApO1xyXG4gIGxldCBvbGRWYWx1ZTtcclxuICBsZXQgZmlyc3RUaW1lID0gdHJ1ZTtcclxuICBlZmZlY3QzKCgpID0+IGV2YWx1YXRlMigodmFsdWUpID0+IHtcclxuICAgIGlmICghZmlyc3RUaW1lICYmIHZhbHVlID09PSBvbGRWYWx1ZSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImltbWVkaWF0ZVwiKSlcclxuICAgICAgdmFsdWUgPyBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpIDogaGlkZSgpO1xyXG4gICAgdG9nZ2xlKHZhbHVlKTtcclxuICAgIG9sZFZhbHVlID0gdmFsdWU7XHJcbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcclxuICB9KSk7XHJcbn0pO1xyXG5cclxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1mb3IuanNcclxuZGlyZWN0aXZlKFwiZm9yXCIsIChlbCwgeyBleHByZXNzaW9uIH0sIHsgZWZmZWN0OiBlZmZlY3QzLCBjbGVhbnVwOiBjbGVhbnVwMiB9KSA9PiB7XHJcbiAgbGV0IGl0ZXJhdG9yTmFtZXMgPSBwYXJzZUZvckV4cHJlc3Npb24oZXhwcmVzc2lvbik7XHJcbiAgbGV0IGV2YWx1YXRlSXRlbXMgPSBldmFsdWF0ZUxhdGVyKGVsLCBpdGVyYXRvck5hbWVzLml0ZW1zKTtcclxuICBsZXQgZXZhbHVhdGVLZXkgPSBldmFsdWF0ZUxhdGVyKFxyXG4gICAgZWwsXHJcbiAgICAvLyB0aGUgeC1iaW5kOmtleSBleHByZXNzaW9uIGlzIHN0b3JlZCBmb3Igb3VyIHVzZSBpbnN0ZWFkIG9mIGV2YWx1YXRlZC5cclxuICAgIGVsLl94X2tleUV4cHJlc3Npb24gfHwgXCJpbmRleFwiXHJcbiAgKTtcclxuICBlbC5feF9wcmV2S2V5cyA9IFtdO1xyXG4gIGVsLl94X2xvb2t1cCA9IHt9O1xyXG4gIGVmZmVjdDMoKCkgPT4gbG9vcChlbCwgaXRlcmF0b3JOYW1lcywgZXZhbHVhdGVJdGVtcywgZXZhbHVhdGVLZXkpKTtcclxuICBjbGVhbnVwMigoKSA9PiB7XHJcbiAgICBPYmplY3QudmFsdWVzKGVsLl94X2xvb2t1cCkuZm9yRWFjaCgoZWwyKSA9PiBlbDIucmVtb3ZlKCkpO1xyXG4gICAgZGVsZXRlIGVsLl94X3ByZXZLZXlzO1xyXG4gICAgZGVsZXRlIGVsLl94X2xvb2t1cDtcclxuICB9KTtcclxufSk7XHJcbmZ1bmN0aW9uIGxvb3AoZWwsIGl0ZXJhdG9yTmFtZXMsIGV2YWx1YXRlSXRlbXMsIGV2YWx1YXRlS2V5KSB7XHJcbiAgbGV0IGlzT2JqZWN0MiA9IChpKSA9PiB0eXBlb2YgaSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpKTtcclxuICBsZXQgdGVtcGxhdGVFbCA9IGVsO1xyXG4gIGV2YWx1YXRlSXRlbXMoKGl0ZW1zKSA9PiB7XHJcbiAgICBpZiAoaXNOdW1lcmljMyhpdGVtcykgJiYgaXRlbXMgPj0gMCkge1xyXG4gICAgICBpdGVtcyA9IEFycmF5LmZyb20oQXJyYXkoaXRlbXMpLmtleXMoKSwgKGkpID0+IGkgKyAxKTtcclxuICAgIH1cclxuICAgIGlmIChpdGVtcyA9PT0gdm9pZCAwKVxyXG4gICAgICBpdGVtcyA9IFtdO1xyXG4gICAgbGV0IGxvb2t1cCA9IGVsLl94X2xvb2t1cDtcclxuICAgIGxldCBwcmV2S2V5cyA9IGVsLl94X3ByZXZLZXlzO1xyXG4gICAgbGV0IHNjb3BlcyA9IFtdO1xyXG4gICAgbGV0IGtleXMgPSBbXTtcclxuICAgIGlmIChpc09iamVjdDIoaXRlbXMpKSB7XHJcbiAgICAgIGl0ZW1zID0gT2JqZWN0LmVudHJpZXMoaXRlbXMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgICAgbGV0IHNjb3BlMiA9IGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIHZhbHVlLCBrZXksIGl0ZW1zKTtcclxuICAgICAgICBldmFsdWF0ZUtleSgodmFsdWUyKSA9PiBrZXlzLnB1c2godmFsdWUyKSwgeyBzY29wZTogeyBpbmRleDoga2V5LCAuLi5zY29wZTIgfSB9KTtcclxuICAgICAgICBzY29wZXMucHVzaChzY29wZTIpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgc2NvcGUyID0gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbXNbaV0sIGksIGl0ZW1zKTtcclxuICAgICAgICBldmFsdWF0ZUtleSgodmFsdWUpID0+IGtleXMucHVzaCh2YWx1ZSksIHsgc2NvcGU6IHsgaW5kZXg6IGksIC4uLnNjb3BlMiB9IH0pO1xyXG4gICAgICAgIHNjb3Blcy5wdXNoKHNjb3BlMik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBhZGRzID0gW107XHJcbiAgICBsZXQgbW92ZXMgPSBbXTtcclxuICAgIGxldCByZW1vdmVzID0gW107XHJcbiAgICBsZXQgc2FtZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldktleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IGtleSA9IHByZXZLZXlzW2ldO1xyXG4gICAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPT09IC0xKVxyXG4gICAgICAgIHJlbW92ZXMucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gICAgcHJldktleXMgPSBwcmV2S2V5cy5maWx0ZXIoKGtleSkgPT4gIXJlbW92ZXMuaW5jbHVkZXMoa2V5KSk7XHJcbiAgICBsZXQgbGFzdEtleSA9IFwidGVtcGxhdGVcIjtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQga2V5ID0ga2V5c1tpXTtcclxuICAgICAgbGV0IHByZXZJbmRleCA9IHByZXZLZXlzLmluZGV4T2Yoa2V5KTtcclxuICAgICAgaWYgKHByZXZJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBwcmV2S2V5cy5zcGxpY2UoaSwgMCwga2V5KTtcclxuICAgICAgICBhZGRzLnB1c2goW2xhc3RLZXksIGldKTtcclxuICAgICAgfSBlbHNlIGlmIChwcmV2SW5kZXggIT09IGkpIHtcclxuICAgICAgICBsZXQga2V5SW5TcG90ID0gcHJldktleXMuc3BsaWNlKGksIDEpWzBdO1xyXG4gICAgICAgIGxldCBrZXlGb3JTcG90ID0gcHJldktleXMuc3BsaWNlKHByZXZJbmRleCAtIDEsIDEpWzBdO1xyXG4gICAgICAgIHByZXZLZXlzLnNwbGljZShpLCAwLCBrZXlGb3JTcG90KTtcclxuICAgICAgICBwcmV2S2V5cy5zcGxpY2UocHJldkluZGV4LCAwLCBrZXlJblNwb3QpO1xyXG4gICAgICAgIG1vdmVzLnB1c2goW2tleUluU3BvdCwga2V5Rm9yU3BvdF0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNhbWVzLnB1c2goa2V5KTtcclxuICAgICAgfVxyXG4gICAgICBsYXN0S2V5ID0ga2V5O1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBrZXkgPSByZW1vdmVzW2ldO1xyXG4gICAgICBpZiAoISFsb29rdXBba2V5XS5feF9lZmZlY3RzKSB7XHJcbiAgICAgICAgbG9va3VwW2tleV0uX3hfZWZmZWN0cy5mb3JFYWNoKGRlcXVldWVKb2IpO1xyXG4gICAgICB9XHJcbiAgICAgIGxvb2t1cFtrZXldLnJlbW92ZSgpO1xyXG4gICAgICBsb29rdXBba2V5XSA9IG51bGw7XHJcbiAgICAgIGRlbGV0ZSBsb29rdXBba2V5XTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IFtrZXlJblNwb3QsIGtleUZvclNwb3RdID0gbW92ZXNbaV07XHJcbiAgICAgIGxldCBlbEluU3BvdCA9IGxvb2t1cFtrZXlJblNwb3RdO1xyXG4gICAgICBsZXQgZWxGb3JTcG90ID0gbG9va3VwW2tleUZvclNwb3RdO1xyXG4gICAgICBsZXQgbWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcclxuICAgICAgICBlbEZvclNwb3QuYWZ0ZXIobWFya2VyKTtcclxuICAgICAgICBlbEluU3BvdC5hZnRlcihlbEZvclNwb3QpO1xyXG4gICAgICAgIGVsRm9yU3BvdC5feF9jdXJyZW50SWZFbCAmJiBlbEZvclNwb3QuYWZ0ZXIoZWxGb3JTcG90Ll94X2N1cnJlbnRJZkVsKTtcclxuICAgICAgICBtYXJrZXIuYmVmb3JlKGVsSW5TcG90KTtcclxuICAgICAgICBlbEluU3BvdC5feF9jdXJyZW50SWZFbCAmJiBlbEluU3BvdC5hZnRlcihlbEluU3BvdC5feF9jdXJyZW50SWZFbCk7XHJcbiAgICAgICAgbWFya2VyLnJlbW92ZSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmVmcmVzaFNjb3BlKGVsRm9yU3BvdCwgc2NvcGVzW2tleXMuaW5kZXhPZihrZXlGb3JTcG90KV0pO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBbbGFzdEtleTIsIGluZGV4XSA9IGFkZHNbaV07XHJcbiAgICAgIGxldCBsYXN0RWwgPSBsYXN0S2V5MiA9PT0gXCJ0ZW1wbGF0ZVwiID8gdGVtcGxhdGVFbCA6IGxvb2t1cFtsYXN0S2V5Ml07XHJcbiAgICAgIGlmIChsYXN0RWwuX3hfY3VycmVudElmRWwpXHJcbiAgICAgICAgbGFzdEVsID0gbGFzdEVsLl94X2N1cnJlbnRJZkVsO1xyXG4gICAgICBsZXQgc2NvcGUyID0gc2NvcGVzW2luZGV4XTtcclxuICAgICAgbGV0IGtleSA9IGtleXNbaW5kZXhdO1xyXG4gICAgICBsZXQgY2xvbmUyID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZUVsLmNvbnRlbnQsIHRydWUpLmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICBhZGRTY29wZVRvTm9kZShjbG9uZTIsIHJlYWN0aXZlKHNjb3BlMiksIHRlbXBsYXRlRWwpO1xyXG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xyXG4gICAgICAgIGxhc3RFbC5hZnRlcihjbG9uZTIpO1xyXG4gICAgICAgIGluaXRUcmVlKGNsb25lMik7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHdhcm4oXCJ4LWZvciBrZXkgY2Fubm90IGJlIGFuIG9iamVjdCwgaXQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBpbnRlZ2VyXCIsIHRlbXBsYXRlRWwpO1xyXG4gICAgICB9XHJcbiAgICAgIGxvb2t1cFtrZXldID0gY2xvbmUyO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICByZWZyZXNoU2NvcGUobG9va3VwW3NhbWVzW2ldXSwgc2NvcGVzW2tleXMuaW5kZXhPZihzYW1lc1tpXSldKTtcclxuICAgIH1cclxuICAgIHRlbXBsYXRlRWwuX3hfcHJldktleXMgPSBrZXlzO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcbiAgbGV0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XHJcbiAgbGV0IHN0cmlwUGFyZW5zUkUgPSAvXlxccypcXCh8XFwpXFxzKiQvZztcclxuICBsZXQgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcclxuICBsZXQgaW5NYXRjaCA9IGV4cHJlc3Npb24ubWF0Y2goZm9yQWxpYXNSRSk7XHJcbiAgaWYgKCFpbk1hdGNoKVxyXG4gICAgcmV0dXJuO1xyXG4gIGxldCByZXMgPSB7fTtcclxuICByZXMuaXRlbXMgPSBpbk1hdGNoWzJdLnRyaW0oKTtcclxuICBsZXQgaXRlbSA9IGluTWF0Y2hbMV0ucmVwbGFjZShzdHJpcFBhcmVuc1JFLCBcIlwiKS50cmltKCk7XHJcbiAgbGV0IGl0ZXJhdG9yTWF0Y2ggPSBpdGVtLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xyXG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XHJcbiAgICByZXMuaXRlbSA9IGl0ZW0ucmVwbGFjZShmb3JJdGVyYXRvclJFLCBcIlwiKS50cmltKCk7XHJcbiAgICByZXMuaW5kZXggPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcclxuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XHJcbiAgICAgIHJlcy5jb2xsZWN0aW9uID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlcy5pdGVtID0gaXRlbTtcclxuICB9XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBnZXRJdGVyYXRpb25TY29wZVZhcmlhYmxlcyhpdGVyYXRvck5hbWVzLCBpdGVtLCBpbmRleCwgaXRlbXMpIHtcclxuICBsZXQgc2NvcGVWYXJpYWJsZXMgPSB7fTtcclxuICBpZiAoL15cXFsuKlxcXSQvLnRlc3QoaXRlcmF0b3JOYW1lcy5pdGVtKSAmJiBBcnJheS5pc0FycmF5KGl0ZW0pKSB7XHJcbiAgICBsZXQgbmFtZXMgPSBpdGVyYXRvck5hbWVzLml0ZW0ucmVwbGFjZShcIltcIiwgXCJcIikucmVwbGFjZShcIl1cIiwgXCJcIikuc3BsaXQoXCIsXCIpLm1hcCgoaSkgPT4gaS50cmltKCkpO1xyXG4gICAgbmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xyXG4gICAgICBzY29wZVZhcmlhYmxlc1tuYW1lXSA9IGl0ZW1baV07XHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKC9eXFx7LipcXH0kLy50ZXN0KGl0ZXJhdG9yTmFtZXMuaXRlbSkgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSkgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIpIHtcclxuICAgIGxldCBuYW1lcyA9IGl0ZXJhdG9yTmFtZXMuaXRlbS5yZXBsYWNlKFwie1wiLCBcIlwiKS5yZXBsYWNlKFwifVwiLCBcIlwiKS5zcGxpdChcIixcIikubWFwKChpKSA9PiBpLnRyaW0oKSk7XHJcbiAgICBuYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XHJcbiAgICAgIHNjb3BlVmFyaWFibGVzW25hbWVdID0gaXRlbVtuYW1lXTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLml0ZW1dID0gaXRlbTtcclxuICB9XHJcbiAgaWYgKGl0ZXJhdG9yTmFtZXMuaW5kZXgpXHJcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLmluZGV4XSA9IGluZGV4O1xyXG4gIGlmIChpdGVyYXRvck5hbWVzLmNvbGxlY3Rpb24pXHJcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLmNvbGxlY3Rpb25dID0gaXRlbXM7XHJcbiAgcmV0dXJuIHNjb3BlVmFyaWFibGVzO1xyXG59XHJcbmZ1bmN0aW9uIGlzTnVtZXJpYzMoc3ViamVjdCkge1xyXG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShzdWJqZWN0KSAmJiAhaXNOYU4oc3ViamVjdCk7XHJcbn1cclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtcmVmLmpzXHJcbmZ1bmN0aW9uIGhhbmRsZXIyKCkge1xyXG59XHJcbmhhbmRsZXIyLmlubGluZSA9IChlbCwgeyBleHByZXNzaW9uIH0sIHsgY2xlYW51cDogY2xlYW51cDIgfSkgPT4ge1xyXG4gIGxldCByb290ID0gY2xvc2VzdFJvb3QoZWwpO1xyXG4gIGlmICghcm9vdC5feF9yZWZzKVxyXG4gICAgcm9vdC5feF9yZWZzID0ge307XHJcbiAgcm9vdC5feF9yZWZzW2V4cHJlc3Npb25dID0gZWw7XHJcbiAgY2xlYW51cDIoKCkgPT4gZGVsZXRlIHJvb3QuX3hfcmVmc1tleHByZXNzaW9uXSk7XHJcbn07XHJcbmRpcmVjdGl2ZShcInJlZlwiLCBoYW5kbGVyMik7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlmLmpzXHJcbmRpcmVjdGl2ZShcImlmXCIsIChlbCwgeyBleHByZXNzaW9uIH0sIHsgZWZmZWN0OiBlZmZlY3QzLCBjbGVhbnVwOiBjbGVhbnVwMiB9KSA9PiB7XHJcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xyXG4gIGxldCBzaG93ID0gKCkgPT4ge1xyXG4gICAgaWYgKGVsLl94X2N1cnJlbnRJZkVsKVxyXG4gICAgICByZXR1cm4gZWwuX3hfY3VycmVudElmRWw7XHJcbiAgICBsZXQgY2xvbmUyID0gZWwuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICBhZGRTY29wZVRvTm9kZShjbG9uZTIsIHt9LCBlbCk7XHJcbiAgICBtdXRhdGVEb20oKCkgPT4ge1xyXG4gICAgICBlbC5hZnRlcihjbG9uZTIpO1xyXG4gICAgICBpbml0VHJlZShjbG9uZTIpO1xyXG4gICAgfSk7XHJcbiAgICBlbC5feF9jdXJyZW50SWZFbCA9IGNsb25lMjtcclxuICAgIGVsLl94X3VuZG9JZiA9ICgpID0+IHtcclxuICAgICAgd2FsayhjbG9uZTIsIChub2RlKSA9PiB7XHJcbiAgICAgICAgaWYgKCEhbm9kZS5feF9lZmZlY3RzKSB7XHJcbiAgICAgICAgICBub2RlLl94X2VmZmVjdHMuZm9yRWFjaChkZXF1ZXVlSm9iKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBjbG9uZTIucmVtb3ZlKCk7XHJcbiAgICAgIGRlbGV0ZSBlbC5feF9jdXJyZW50SWZFbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gY2xvbmUyO1xyXG4gIH07XHJcbiAgbGV0IGhpZGUgPSAoKSA9PiB7XHJcbiAgICBpZiAoIWVsLl94X3VuZG9JZilcclxuICAgICAgcmV0dXJuO1xyXG4gICAgZWwuX3hfdW5kb0lmKCk7XHJcbiAgICBkZWxldGUgZWwuX3hfdW5kb0lmO1xyXG4gIH07XHJcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XHJcbiAgICB2YWx1ZSA/IHNob3coKSA6IGhpZGUoKTtcclxuICB9KSk7XHJcbiAgY2xlYW51cDIoKCkgPT4gZWwuX3hfdW5kb0lmICYmIGVsLl94X3VuZG9JZigpKTtcclxufSk7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlkLmpzXHJcbmRpcmVjdGl2ZShcImlkXCIsIChlbCwgeyBleHByZXNzaW9uIH0sIHsgZXZhbHVhdGU6IGV2YWx1YXRlMiB9KSA9PiB7XHJcbiAgbGV0IG5hbWVzID0gZXZhbHVhdGUyKGV4cHJlc3Npb24pO1xyXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHNldElkUm9vdChlbCwgbmFtZSkpO1xyXG59KTtcclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtb24uanNcclxubWFwQXR0cmlidXRlcyhzdGFydGluZ1dpdGgoXCJAXCIsIGludG8ocHJlZml4KFwib246XCIpKSkpO1xyXG5kaXJlY3RpdmUoXCJvblwiLCBza2lwRHVyaW5nQ2xvbmUoKGVsLCB7IHZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb24gfSwgeyBjbGVhbnVwOiBjbGVhbnVwMiB9KSA9PiB7XHJcbiAgbGV0IGV2YWx1YXRlMiA9IGV4cHJlc3Npb24gPyBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKSA6ICgpID0+IHtcclxuICB9O1xyXG4gIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidGVtcGxhdGVcIikge1xyXG4gICAgaWYgKCFlbC5feF9mb3J3YXJkRXZlbnRzKVxyXG4gICAgICBlbC5feF9mb3J3YXJkRXZlbnRzID0gW107XHJcbiAgICBpZiAoIWVsLl94X2ZvcndhcmRFdmVudHMuaW5jbHVkZXModmFsdWUpKVxyXG4gICAgICBlbC5feF9mb3J3YXJkRXZlbnRzLnB1c2godmFsdWUpO1xyXG4gIH1cclxuICBsZXQgcmVtb3ZlTGlzdGVuZXIgPSBvbihlbCwgdmFsdWUsIG1vZGlmaWVycywgKGUpID0+IHtcclxuICAgIGV2YWx1YXRlMigoKSA9PiB7XHJcbiAgICB9LCB7IHNjb3BlOiB7IFwiJGV2ZW50XCI6IGUgfSwgcGFyYW1zOiBbZV0gfSk7XHJcbiAgfSk7XHJcbiAgY2xlYW51cDIoKCkgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XHJcbn0pKTtcclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL2luZGV4LmpzXHJcbndhcm5NaXNzaW5nUGx1Z2luRGlyZWN0aXZlKFwiQ29sbGFwc2VcIiwgXCJjb2xsYXBzZVwiLCBcImNvbGxhcHNlXCIpO1xyXG53YXJuTWlzc2luZ1BsdWdpbkRpcmVjdGl2ZShcIkludGVyc2VjdFwiLCBcImludGVyc2VjdFwiLCBcImludGVyc2VjdFwiKTtcclxud2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUoXCJGb2N1c1wiLCBcInRyYXBcIiwgXCJmb2N1c1wiKTtcclxud2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUoXCJNYXNrXCIsIFwibWFza1wiLCBcIm1hc2tcIik7XHJcbmZ1bmN0aW9uIHdhcm5NaXNzaW5nUGx1Z2luRGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZU5hbWUyLCBzbHVnKSB7XHJcbiAgZGlyZWN0aXZlKGRpcmVjdGl2ZU5hbWUyLCAoZWwpID0+IHdhcm4oYFlvdSBjYW4ndCB1c2UgW3gtJHtkaXJlY3RpdmVOYW1lMn1dIHdpdGhvdXQgZmlyc3QgaW5zdGFsbGluZyB0aGUgXCIke25hbWV9XCIgcGx1Z2luIGhlcmU6IGh0dHBzOi8vYWxwaW5lanMuZGV2L3BsdWdpbnMvJHtzbHVnfWAsIGVsKSk7XHJcbn1cclxuXHJcbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9pbmRleC5qc1xyXG5hbHBpbmVfZGVmYXVsdC5zZXRFdmFsdWF0b3Iobm9ybWFsRXZhbHVhdG9yKTtcclxuYWxwaW5lX2RlZmF1bHQuc2V0UmVhY3Rpdml0eUVuZ2luZSh7IHJlYWN0aXZlOiByZWFjdGl2ZTIsIGVmZmVjdDogZWZmZWN0MiwgcmVsZWFzZTogc3RvcCwgcmF3OiB0b1JhdyB9KTtcclxudmFyIHNyY19kZWZhdWx0ID0gYWxwaW5lX2RlZmF1bHQ7XHJcblxyXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9idWlsZHMvbW9kdWxlLmpzXHJcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xyXG5leHBvcnQge1xyXG4gIG1vZHVsZV9kZWZhdWx0IGFzIGRlZmF1bHRcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/alpinejs/dist/module.esm.js\n");

/***/ }),

/***/ "./resources/js/alpine.js":
/*!********************************!*\
  !*** ./resources/js/alpine.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alpinejs */ \"./node_modules/alpinejs/dist/module.esm.js\");\n/* harmony import */ var _alpinejs_mask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @alpinejs/mask */ \"./node_modules/@alpinejs/mask/dist/module.esm.js\");\n/* harmony import */ var _components_navbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/navbar */ \"./resources/js/components/navbar.js\");\n/* harmony import */ var _components_sidebar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/sidebar */ \"./resources/js/components/sidebar.js\");\n\n\nalpinejs__WEBPACK_IMPORTED_MODULE_0__.default.plugin(_alpinejs_mask__WEBPACK_IMPORTED_MODULE_1__.default);\n\n\nalpinejs__WEBPACK_IMPORTED_MODULE_0__.default.data('navbar', _components_navbar__WEBPACK_IMPORTED_MODULE_2__.default);\nalpinejs__WEBPACK_IMPORTED_MODULE_0__.default.data('sidebar', _components_sidebar__WEBPACK_IMPORTED_MODULE_3__.default);\nalpinejs__WEBPACK_IMPORTED_MODULE_0__.default.start();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYWxwaW5lLmpzPzQ0YWEiXSwibmFtZXMiOlsiQWxwaW5lIiwibWFzayIsIm5hdmJhciIsInNpZGViYXIiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFFQTtBQUNBQSxvREFBQSxDQUFjQyxtREFBZDtBQUVBO0FBQ0E7QUFFQUQsa0RBQUEsQ0FBWSxRQUFaLEVBQXNCRSx1REFBdEI7QUFDQUYsa0RBQUEsQ0FBWSxTQUFaLEVBQXVCRyx3REFBdkI7QUFFQUgsbURBQUEiLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYWxwaW5lLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFscGluZSBmcm9tICdhbHBpbmVqcyc7XHJcblxyXG5pbXBvcnQgbWFzayBmcm9tICdAYWxwaW5lanMvbWFzaycgXHJcbkFscGluZS5wbHVnaW4obWFzaylcclxuXHJcbmltcG9ydCBuYXZiYXIgZnJvbSAnLi9jb21wb25lbnRzL25hdmJhcic7XHJcbmltcG9ydCBzaWRlYmFyIGZyb20gJy4vY29tcG9uZW50cy9zaWRlYmFyJztcclxuXHJcbkFscGluZS5kYXRhKCduYXZiYXInLCBuYXZiYXIpO1xyXG5BbHBpbmUuZGF0YSgnc2lkZWJhcicsIHNpZGViYXIpO1xyXG5cclxuQWxwaW5lLnN0YXJ0KCk7XHJcblxyXG5cclxuXHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/alpine.js\n");

/***/ }),

/***/ "./resources/js/components/navbar.js":
/*!*******************************************!*\
  !*** ./resources/js/components/navbar.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {\n  return {\n    open: false,\n    toggle: function toggle() {\n      this.open = !this.open;\n    }\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9uYXZiYXIuanM/MzI3OSJdLCJuYW1lcyI6WyJvcGVuIiwidG9nZ2xlIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWU7QUFBQSxTQUFPO0FBQ2xCQSxRQUFJLEVBQUUsS0FEWTtBQUdsQkMsVUFIa0Isb0JBR1Q7QUFDTCxXQUFLRCxJQUFMLEdBQVksQ0FBRSxLQUFLQSxJQUFuQjtBQUNIO0FBTGlCLEdBQVA7QUFBQSxDQUFmIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvbmF2YmFyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgKCkgPT4gKHtcclxuICAgIG9wZW46IGZhbHNlLFxyXG5cclxuICAgIHRvZ2dsZSgpIHtcclxuICAgICAgICB0aGlzLm9wZW4gPSAhIHRoaXMub3BlblxyXG4gICAgfVxyXG59KSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/navbar.js\n");

/***/ }),

/***/ "./resources/js/components/sidebar.js":
/*!********************************************!*\
  !*** ./resources/js/components/sidebar.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {\n  return {\n    open: false,\n    toggle: function toggle() {\n      this.open = !this.open;\n    }\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9zaWRlYmFyLmpzPzY4OGQiXSwibmFtZXMiOlsib3BlbiIsInRvZ2dsZSJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlO0FBQUEsU0FBTztBQUNsQkEsUUFBSSxFQUFFLEtBRFk7QUFHbEJDLFVBSGtCLG9CQUdUO0FBQ0wsV0FBS0QsSUFBTCxHQUFZLENBQUUsS0FBS0EsSUFBbkI7QUFDSDtBQUxpQixHQUFQO0FBQUEsQ0FBZiIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3NpZGViYXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAoKSA9PiAoe1xyXG4gICAgb3BlbjogZmFsc2UsXHJcblxyXG4gICAgdG9nZ2xlKCkge1xyXG4gICAgICAgIHRoaXMub3BlbiA9ICEgdGhpcy5vcGVuXHJcbiAgICB9XHJcbn0pIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/sidebar.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/alpine.js");
/******/ 	
/******/ })()
;